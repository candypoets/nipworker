// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod nostr {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fb {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTENT_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTENT_DATA: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTENT_DATA: [ContentData; 9] = [
  ContentData::NONE,
  ContentData::CodeData,
  ContentData::HashtagData,
  ContentData::CashuData,
  ContentData::ImageData,
  ContentData::VideoData,
  ContentData::MediaGroupData,
  ContentData::NostrData,
  ContentData::LinkPreviewData,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ContentData(pub u8);
#[allow(non_upper_case_globals)]
impl ContentData {
  pub const NONE: Self = Self(0);
  pub const CodeData: Self = Self(1);
  pub const HashtagData: Self = Self(2);
  pub const CashuData: Self = Self(3);
  pub const ImageData: Self = Self(4);
  pub const VideoData: Self = Self(5);
  pub const MediaGroupData: Self = Self(6);
  pub const NostrData: Self = Self(7);
  pub const LinkPreviewData: Self = Self(8);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CodeData,
    Self::HashtagData,
    Self::CashuData,
    Self::ImageData,
    Self::VideoData,
    Self::MediaGroupData,
    Self::NostrData,
    Self::LinkPreviewData,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CodeData => Some("CodeData"),
      Self::HashtagData => Some("HashtagData"),
      Self::CashuData => Some("CashuData"),
      Self::ImageData => Some("ImageData"),
      Self::VideoData => Some("VideoData"),
      Self::MediaGroupData => Some("MediaGroupData"),
      Self::NostrData => Some("NostrData"),
      Self::LinkPreviewData => Some("LinkPreviewData"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ContentData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ContentData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ContentData {
    type Output = ContentData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ContentData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ContentData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ContentData {}
pub struct ContentDataUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum ContentDataT {
  NONE,
  CodeData(Box<CodeDataT>),
  HashtagData(Box<HashtagDataT>),
  CashuData(Box<CashuDataT>),
  ImageData(Box<ImageDataT>),
  VideoData(Box<VideoDataT>),
  MediaGroupData(Box<MediaGroupDataT>),
  NostrData(Box<NostrDataT>),
  LinkPreviewData(Box<LinkPreviewDataT>),
}
impl Default for ContentDataT {
  fn default() -> Self {
    Self::NONE
  }
}
impl ContentDataT {
  pub fn content_data_type(&self) -> ContentData {
    match self {
      Self::NONE => ContentData::NONE,
      Self::CodeData(_) => ContentData::CodeData,
      Self::HashtagData(_) => ContentData::HashtagData,
      Self::CashuData(_) => ContentData::CashuData,
      Self::ImageData(_) => ContentData::ImageData,
      Self::VideoData(_) => ContentData::VideoData,
      Self::MediaGroupData(_) => ContentData::MediaGroupData,
      Self::NostrData(_) => ContentData::NostrData,
      Self::LinkPreviewData(_) => ContentData::LinkPreviewData,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::CodeData(v) => Some(v.pack(fbb).as_union_value()),
      Self::HashtagData(v) => Some(v.pack(fbb).as_union_value()),
      Self::CashuData(v) => Some(v.pack(fbb).as_union_value()),
      Self::ImageData(v) => Some(v.pack(fbb).as_union_value()),
      Self::VideoData(v) => Some(v.pack(fbb).as_union_value()),
      Self::MediaGroupData(v) => Some(v.pack(fbb).as_union_value()),
      Self::NostrData(v) => Some(v.pack(fbb).as_union_value()),
      Self::LinkPreviewData(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned CodeDataT, setting the union to NONE.
  pub fn take_code_data(&mut self) -> Option<Box<CodeDataT>> {
    if let Self::CodeData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CodeData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CodeDataT.
  pub fn as_code_data(&self) -> Option<&CodeDataT> {
    if let Self::CodeData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CodeDataT.
  pub fn as_code_data_mut(&mut self) -> Option<&mut CodeDataT> {
    if let Self::CodeData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned HashtagDataT, setting the union to NONE.
  pub fn take_hashtag_data(&mut self) -> Option<Box<HashtagDataT>> {
    if let Self::HashtagData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::HashtagData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the HashtagDataT.
  pub fn as_hashtag_data(&self) -> Option<&HashtagDataT> {
    if let Self::HashtagData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the HashtagDataT.
  pub fn as_hashtag_data_mut(&mut self) -> Option<&mut HashtagDataT> {
    if let Self::HashtagData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CashuDataT, setting the union to NONE.
  pub fn take_cashu_data(&mut self) -> Option<Box<CashuDataT>> {
    if let Self::CashuData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CashuData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CashuDataT.
  pub fn as_cashu_data(&self) -> Option<&CashuDataT> {
    if let Self::CashuData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CashuDataT.
  pub fn as_cashu_data_mut(&mut self) -> Option<&mut CashuDataT> {
    if let Self::CashuData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ImageDataT, setting the union to NONE.
  pub fn take_image_data(&mut self) -> Option<Box<ImageDataT>> {
    if let Self::ImageData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ImageData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ImageDataT.
  pub fn as_image_data(&self) -> Option<&ImageDataT> {
    if let Self::ImageData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ImageDataT.
  pub fn as_image_data_mut(&mut self) -> Option<&mut ImageDataT> {
    if let Self::ImageData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned VideoDataT, setting the union to NONE.
  pub fn take_video_data(&mut self) -> Option<Box<VideoDataT>> {
    if let Self::VideoData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::VideoData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the VideoDataT.
  pub fn as_video_data(&self) -> Option<&VideoDataT> {
    if let Self::VideoData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the VideoDataT.
  pub fn as_video_data_mut(&mut self) -> Option<&mut VideoDataT> {
    if let Self::VideoData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MediaGroupDataT, setting the union to NONE.
  pub fn take_media_group_data(&mut self) -> Option<Box<MediaGroupDataT>> {
    if let Self::MediaGroupData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MediaGroupData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MediaGroupDataT.
  pub fn as_media_group_data(&self) -> Option<&MediaGroupDataT> {
    if let Self::MediaGroupData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MediaGroupDataT.
  pub fn as_media_group_data_mut(&mut self) -> Option<&mut MediaGroupDataT> {
    if let Self::MediaGroupData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NostrDataT, setting the union to NONE.
  pub fn take_nostr_data(&mut self) -> Option<Box<NostrDataT>> {
    if let Self::NostrData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NostrData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NostrDataT.
  pub fn as_nostr_data(&self) -> Option<&NostrDataT> {
    if let Self::NostrData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NostrDataT.
  pub fn as_nostr_data_mut(&mut self) -> Option<&mut NostrDataT> {
    if let Self::NostrData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LinkPreviewDataT, setting the union to NONE.
  pub fn take_link_preview_data(&mut self) -> Option<Box<LinkPreviewDataT>> {
    if let Self::LinkPreviewData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LinkPreviewData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LinkPreviewDataT.
  pub fn as_link_preview_data(&self) -> Option<&LinkPreviewDataT> {
    if let Self::LinkPreviewData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LinkPreviewDataT.
  pub fn as_link_preview_data_mut(&mut self) -> Option<&mut LinkPreviewDataT> {
    if let Self::LinkPreviewData(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REACTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REACTION_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REACTION_TYPE: [ReactionType; 4] = [
  ReactionType::Like,
  ReactionType::Dislike,
  ReactionType::Emoji,
  ReactionType::Custom,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReactionType(pub i8);
#[allow(non_upper_case_globals)]
impl ReactionType {
  pub const Like: Self = Self(0);
  pub const Dislike: Self = Self(1);
  pub const Emoji: Self = Self(2);
  pub const Custom: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Like,
    Self::Dislike,
    Self::Emoji,
    Self::Custom,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Like => Some("Like"),
      Self::Dislike => Some("Dislike"),
      Self::Emoji => Some("Emoji"),
      Self::Custom => Some("Custom"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ReactionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ReactionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ReactionType {
    type Output = ReactionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ReactionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ReactionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ReactionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SUBSCRIBE_KIND: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SUBSCRIBE_KIND: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SUBSCRIBE_KIND: [SubscribeKind; 6] = [
  SubscribeKind::CachedEvent,
  SubscribeKind::FetchedEvent,
  SubscribeKind::Count,
  SubscribeKind::ConnectionStatus,
  SubscribeKind::Eoce,
  SubscribeKind::BufferFull,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SubscribeKind(pub i8);
#[allow(non_upper_case_globals)]
impl SubscribeKind {
  pub const CachedEvent: Self = Self(0);
  pub const FetchedEvent: Self = Self(1);
  pub const Count: Self = Self(2);
  pub const ConnectionStatus: Self = Self(3);
  pub const Eoce: Self = Self(4);
  pub const BufferFull: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CachedEvent,
    Self::FetchedEvent,
    Self::Count,
    Self::ConnectionStatus,
    Self::Eoce,
    Self::BufferFull,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CachedEvent => Some("CachedEvent"),
      Self::FetchedEvent => Some("FetchedEvent"),
      Self::Count => Some("Count"),
      Self::ConnectionStatus => Some("ConnectionStatus"),
      Self::Eoce => Some("Eoce"),
      Self::BufferFull => Some("BufferFull"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SubscribeKind {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SubscribeKind {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SubscribeKind {
    type Output = SubscribeKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SubscribeKind {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SubscribeKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SubscribeKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_WITNESS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_WITNESS: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WITNESS: [Witness; 4] = [
  Witness::NONE,
  Witness::WitnessString,
  Witness::P2PKWitness,
  Witness::HTLCWitness,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Witness(pub u8);
#[allow(non_upper_case_globals)]
impl Witness {
  pub const NONE: Self = Self(0);
  pub const WitnessString: Self = Self(1);
  pub const P2PKWitness: Self = Self(2);
  pub const HTLCWitness: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::WitnessString,
    Self::P2PKWitness,
    Self::HTLCWitness,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::WitnessString => Some("WitnessString"),
      Self::P2PKWitness => Some("P2PKWitness"),
      Self::HTLCWitness => Some("HTLCWitness"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Witness {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Witness {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Witness {
    type Output = Witness;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Witness {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Witness {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Witness {}
pub struct WitnessUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum WitnessT {
  NONE,
  WitnessString(Box<WitnessStringT>),
  P2PKWitness(Box<P2PKWitnessT>),
  HTLCWitness(Box<HTLCWitnessT>),
}
impl Default for WitnessT {
  fn default() -> Self {
    Self::NONE
  }
}
impl WitnessT {
  pub fn witness_type(&self) -> Witness {
    match self {
      Self::NONE => Witness::NONE,
      Self::WitnessString(_) => Witness::WitnessString,
      Self::P2PKWitness(_) => Witness::P2PKWitness,
      Self::HTLCWitness(_) => Witness::HTLCWitness,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::WitnessString(v) => Some(v.pack(fbb).as_union_value()),
      Self::P2PKWitness(v) => Some(v.pack(fbb).as_union_value()),
      Self::HTLCWitness(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned WitnessStringT, setting the union to NONE.
  pub fn take_witness_string(&mut self) -> Option<Box<WitnessStringT>> {
    if let Self::WitnessString(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::WitnessString(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the WitnessStringT.
  pub fn as_witness_string(&self) -> Option<&WitnessStringT> {
    if let Self::WitnessString(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the WitnessStringT.
  pub fn as_witness_string_mut(&mut self) -> Option<&mut WitnessStringT> {
    if let Self::WitnessString(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned P2PKWitnessT, setting the union to NONE.
  pub fn take_p2_pkwitness(&mut self) -> Option<Box<P2PKWitnessT>> {
    if let Self::P2PKWitness(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::P2PKWitness(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the P2PKWitnessT.
  pub fn as_p2_pkwitness(&self) -> Option<&P2PKWitnessT> {
    if let Self::P2PKWitness(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the P2PKWitnessT.
  pub fn as_p2_pkwitness_mut(&mut self) -> Option<&mut P2PKWitnessT> {
    if let Self::P2PKWitness(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned HTLCWitnessT, setting the union to NONE.
  pub fn take_htlcwitness(&mut self) -> Option<Box<HTLCWitnessT>> {
    if let Self::HTLCWitness(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::HTLCWitness(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the HTLCWitnessT.
  pub fn as_htlcwitness(&self) -> Option<&HTLCWitnessT> {
    if let Self::HTLCWitness(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the HTLCWitnessT.
  pub fn as_htlcwitness_mut(&mut self) -> Option<&mut HTLCWitnessT> {
    if let Self::HTLCWitness(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SIGNER_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SIGNER_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SIGNER_TYPE: [SignerType; 2] = [
  SignerType::NONE,
  SignerType::PrivateKey,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SignerType(pub u8);
#[allow(non_upper_case_globals)]
impl SignerType {
  pub const NONE: Self = Self(0);
  pub const PrivateKey: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PrivateKey,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PrivateKey => Some("PrivateKey"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SignerType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SignerType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SignerType {
    type Output = SignerType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SignerType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SignerType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SignerType {}
pub struct SignerTypeUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum SignerTypeT {
  NONE,
  PrivateKey(Box<PrivateKeyT>),
}
impl Default for SignerTypeT {
  fn default() -> Self {
    Self::NONE
  }
}
impl SignerTypeT {
  pub fn signer_type_type(&self) -> SignerType {
    match self {
      Self::NONE => SignerType::NONE,
      Self::PrivateKey(_) => SignerType::PrivateKey,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::PrivateKey(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned PrivateKeyT, setting the union to NONE.
  pub fn take_private_key(&mut self) -> Option<Box<PrivateKeyT>> {
    if let Self::PrivateKey(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PrivateKey(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PrivateKeyT.
  pub fn as_private_key(&self) -> Option<&PrivateKeyT> {
    if let Self::PrivateKey(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PrivateKeyT.
  pub fn as_private_key_mut(&mut self) -> Option<&mut PrivateKeyT> {
    if let Self::PrivateKey(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PIPE_CONFIG: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PIPE_CONFIG: u8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PIPE_CONFIG: [PipeConfig; 8] = [
  PipeConfig::NONE,
  PipeConfig::ParsePipeConfig,
  PipeConfig::KindFilterPipeConfig,
  PipeConfig::CounterPipeConfig,
  PipeConfig::NpubLimiterPipeConfig,
  PipeConfig::SaveToDbPipeConfig,
  PipeConfig::SerializeEventsPipeConfig,
  PipeConfig::ProofVerificationPipeConfig,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PipeConfig(pub u8);
#[allow(non_upper_case_globals)]
impl PipeConfig {
  pub const NONE: Self = Self(0);
  pub const ParsePipeConfig: Self = Self(1);
  pub const KindFilterPipeConfig: Self = Self(2);
  pub const CounterPipeConfig: Self = Self(3);
  pub const NpubLimiterPipeConfig: Self = Self(4);
  pub const SaveToDbPipeConfig: Self = Self(5);
  pub const SerializeEventsPipeConfig: Self = Self(6);
  pub const ProofVerificationPipeConfig: Self = Self(7);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ParsePipeConfig,
    Self::KindFilterPipeConfig,
    Self::CounterPipeConfig,
    Self::NpubLimiterPipeConfig,
    Self::SaveToDbPipeConfig,
    Self::SerializeEventsPipeConfig,
    Self::ProofVerificationPipeConfig,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ParsePipeConfig => Some("ParsePipeConfig"),
      Self::KindFilterPipeConfig => Some("KindFilterPipeConfig"),
      Self::CounterPipeConfig => Some("CounterPipeConfig"),
      Self::NpubLimiterPipeConfig => Some("NpubLimiterPipeConfig"),
      Self::SaveToDbPipeConfig => Some("SaveToDbPipeConfig"),
      Self::SerializeEventsPipeConfig => Some("SerializeEventsPipeConfig"),
      Self::ProofVerificationPipeConfig => Some("ProofVerificationPipeConfig"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PipeConfig {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PipeConfig {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PipeConfig {
    type Output = PipeConfig;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PipeConfig {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PipeConfig {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PipeConfig {}
pub struct PipeConfigUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum PipeConfigT {
  NONE,
  ParsePipeConfig(Box<ParsePipeConfigT>),
  KindFilterPipeConfig(Box<KindFilterPipeConfigT>),
  CounterPipeConfig(Box<CounterPipeConfigT>),
  NpubLimiterPipeConfig(Box<NpubLimiterPipeConfigT>),
  SaveToDbPipeConfig(Box<SaveToDbPipeConfigT>),
  SerializeEventsPipeConfig(Box<SerializeEventsPipeConfigT>),
  ProofVerificationPipeConfig(Box<ProofVerificationPipeConfigT>),
}
impl Default for PipeConfigT {
  fn default() -> Self {
    Self::NONE
  }
}
impl PipeConfigT {
  pub fn pipe_config_type(&self) -> PipeConfig {
    match self {
      Self::NONE => PipeConfig::NONE,
      Self::ParsePipeConfig(_) => PipeConfig::ParsePipeConfig,
      Self::KindFilterPipeConfig(_) => PipeConfig::KindFilterPipeConfig,
      Self::CounterPipeConfig(_) => PipeConfig::CounterPipeConfig,
      Self::NpubLimiterPipeConfig(_) => PipeConfig::NpubLimiterPipeConfig,
      Self::SaveToDbPipeConfig(_) => PipeConfig::SaveToDbPipeConfig,
      Self::SerializeEventsPipeConfig(_) => PipeConfig::SerializeEventsPipeConfig,
      Self::ProofVerificationPipeConfig(_) => PipeConfig::ProofVerificationPipeConfig,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::ParsePipeConfig(v) => Some(v.pack(fbb).as_union_value()),
      Self::KindFilterPipeConfig(v) => Some(v.pack(fbb).as_union_value()),
      Self::CounterPipeConfig(v) => Some(v.pack(fbb).as_union_value()),
      Self::NpubLimiterPipeConfig(v) => Some(v.pack(fbb).as_union_value()),
      Self::SaveToDbPipeConfig(v) => Some(v.pack(fbb).as_union_value()),
      Self::SerializeEventsPipeConfig(v) => Some(v.pack(fbb).as_union_value()),
      Self::ProofVerificationPipeConfig(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned ParsePipeConfigT, setting the union to NONE.
  pub fn take_parse_pipe_config(&mut self) -> Option<Box<ParsePipeConfigT>> {
    if let Self::ParsePipeConfig(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ParsePipeConfig(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ParsePipeConfigT.
  pub fn as_parse_pipe_config(&self) -> Option<&ParsePipeConfigT> {
    if let Self::ParsePipeConfig(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ParsePipeConfigT.
  pub fn as_parse_pipe_config_mut(&mut self) -> Option<&mut ParsePipeConfigT> {
    if let Self::ParsePipeConfig(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned KindFilterPipeConfigT, setting the union to NONE.
  pub fn take_kind_filter_pipe_config(&mut self) -> Option<Box<KindFilterPipeConfigT>> {
    if let Self::KindFilterPipeConfig(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::KindFilterPipeConfig(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the KindFilterPipeConfigT.
  pub fn as_kind_filter_pipe_config(&self) -> Option<&KindFilterPipeConfigT> {
    if let Self::KindFilterPipeConfig(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the KindFilterPipeConfigT.
  pub fn as_kind_filter_pipe_config_mut(&mut self) -> Option<&mut KindFilterPipeConfigT> {
    if let Self::KindFilterPipeConfig(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CounterPipeConfigT, setting the union to NONE.
  pub fn take_counter_pipe_config(&mut self) -> Option<Box<CounterPipeConfigT>> {
    if let Self::CounterPipeConfig(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CounterPipeConfig(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CounterPipeConfigT.
  pub fn as_counter_pipe_config(&self) -> Option<&CounterPipeConfigT> {
    if let Self::CounterPipeConfig(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CounterPipeConfigT.
  pub fn as_counter_pipe_config_mut(&mut self) -> Option<&mut CounterPipeConfigT> {
    if let Self::CounterPipeConfig(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NpubLimiterPipeConfigT, setting the union to NONE.
  pub fn take_npub_limiter_pipe_config(&mut self) -> Option<Box<NpubLimiterPipeConfigT>> {
    if let Self::NpubLimiterPipeConfig(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NpubLimiterPipeConfig(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NpubLimiterPipeConfigT.
  pub fn as_npub_limiter_pipe_config(&self) -> Option<&NpubLimiterPipeConfigT> {
    if let Self::NpubLimiterPipeConfig(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NpubLimiterPipeConfigT.
  pub fn as_npub_limiter_pipe_config_mut(&mut self) -> Option<&mut NpubLimiterPipeConfigT> {
    if let Self::NpubLimiterPipeConfig(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SaveToDbPipeConfigT, setting the union to NONE.
  pub fn take_save_to_db_pipe_config(&mut self) -> Option<Box<SaveToDbPipeConfigT>> {
    if let Self::SaveToDbPipeConfig(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SaveToDbPipeConfig(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SaveToDbPipeConfigT.
  pub fn as_save_to_db_pipe_config(&self) -> Option<&SaveToDbPipeConfigT> {
    if let Self::SaveToDbPipeConfig(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SaveToDbPipeConfigT.
  pub fn as_save_to_db_pipe_config_mut(&mut self) -> Option<&mut SaveToDbPipeConfigT> {
    if let Self::SaveToDbPipeConfig(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SerializeEventsPipeConfigT, setting the union to NONE.
  pub fn take_serialize_events_pipe_config(&mut self) -> Option<Box<SerializeEventsPipeConfigT>> {
    if let Self::SerializeEventsPipeConfig(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SerializeEventsPipeConfig(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SerializeEventsPipeConfigT.
  pub fn as_serialize_events_pipe_config(&self) -> Option<&SerializeEventsPipeConfigT> {
    if let Self::SerializeEventsPipeConfig(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SerializeEventsPipeConfigT.
  pub fn as_serialize_events_pipe_config_mut(&mut self) -> Option<&mut SerializeEventsPipeConfigT> {
    if let Self::SerializeEventsPipeConfig(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ProofVerificationPipeConfigT, setting the union to NONE.
  pub fn take_proof_verification_pipe_config(&mut self) -> Option<Box<ProofVerificationPipeConfigT>> {
    if let Self::ProofVerificationPipeConfig(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ProofVerificationPipeConfig(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ProofVerificationPipeConfigT.
  pub fn as_proof_verification_pipe_config(&self) -> Option<&ProofVerificationPipeConfigT> {
    if let Self::ProofVerificationPipeConfig(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ProofVerificationPipeConfigT.
  pub fn as_proof_verification_pipe_config_mut(&mut self) -> Option<&mut ProofVerificationPipeConfigT> {
    if let Self::ProofVerificationPipeConfig(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MAIN_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MAIN_CONTENT: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MAIN_CONTENT: [MainContent; 7] = [
  MainContent::NONE,
  MainContent::Subscribe,
  MainContent::Unsubscribe,
  MainContent::Publish,
  MainContent::SignEvent,
  MainContent::SetSigner,
  MainContent::GetPublicKey,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MainContent(pub u8);
#[allow(non_upper_case_globals)]
impl MainContent {
  pub const NONE: Self = Self(0);
  pub const Subscribe: Self = Self(1);
  pub const Unsubscribe: Self = Self(2);
  pub const Publish: Self = Self(3);
  pub const SignEvent: Self = Self(4);
  pub const SetSigner: Self = Self(5);
  pub const GetPublicKey: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Subscribe,
    Self::Unsubscribe,
    Self::Publish,
    Self::SignEvent,
    Self::SetSigner,
    Self::GetPublicKey,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Subscribe => Some("Subscribe"),
      Self::Unsubscribe => Some("Unsubscribe"),
      Self::Publish => Some("Publish"),
      Self::SignEvent => Some("SignEvent"),
      Self::SetSigner => Some("SetSigner"),
      Self::GetPublicKey => Some("GetPublicKey"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MainContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MainContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MainContent {
    type Output = MainContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MainContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MainContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MainContent {}
pub struct MainContentUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum MainContentT {
  NONE,
  Subscribe(Box<SubscribeT>),
  Unsubscribe(Box<UnsubscribeT>),
  Publish(Box<PublishT>),
  SignEvent(Box<SignEventT>),
  SetSigner(Box<SetSignerT>),
  GetPublicKey(Box<GetPublicKeyT>),
}
impl Default for MainContentT {
  fn default() -> Self {
    Self::NONE
  }
}
impl MainContentT {
  pub fn main_content_type(&self) -> MainContent {
    match self {
      Self::NONE => MainContent::NONE,
      Self::Subscribe(_) => MainContent::Subscribe,
      Self::Unsubscribe(_) => MainContent::Unsubscribe,
      Self::Publish(_) => MainContent::Publish,
      Self::SignEvent(_) => MainContent::SignEvent,
      Self::SetSigner(_) => MainContent::SetSigner,
      Self::GetPublicKey(_) => MainContent::GetPublicKey,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Subscribe(v) => Some(v.pack(fbb).as_union_value()),
      Self::Unsubscribe(v) => Some(v.pack(fbb).as_union_value()),
      Self::Publish(v) => Some(v.pack(fbb).as_union_value()),
      Self::SignEvent(v) => Some(v.pack(fbb).as_union_value()),
      Self::SetSigner(v) => Some(v.pack(fbb).as_union_value()),
      Self::GetPublicKey(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned SubscribeT, setting the union to NONE.
  pub fn take_subscribe(&mut self) -> Option<Box<SubscribeT>> {
    if let Self::Subscribe(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Subscribe(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SubscribeT.
  pub fn as_subscribe(&self) -> Option<&SubscribeT> {
    if let Self::Subscribe(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SubscribeT.
  pub fn as_subscribe_mut(&mut self) -> Option<&mut SubscribeT> {
    if let Self::Subscribe(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned UnsubscribeT, setting the union to NONE.
  pub fn take_unsubscribe(&mut self) -> Option<Box<UnsubscribeT>> {
    if let Self::Unsubscribe(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Unsubscribe(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the UnsubscribeT.
  pub fn as_unsubscribe(&self) -> Option<&UnsubscribeT> {
    if let Self::Unsubscribe(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the UnsubscribeT.
  pub fn as_unsubscribe_mut(&mut self) -> Option<&mut UnsubscribeT> {
    if let Self::Unsubscribe(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PublishT, setting the union to NONE.
  pub fn take_publish(&mut self) -> Option<Box<PublishT>> {
    if let Self::Publish(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Publish(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PublishT.
  pub fn as_publish(&self) -> Option<&PublishT> {
    if let Self::Publish(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PublishT.
  pub fn as_publish_mut(&mut self) -> Option<&mut PublishT> {
    if let Self::Publish(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SignEventT, setting the union to NONE.
  pub fn take_sign_event(&mut self) -> Option<Box<SignEventT>> {
    if let Self::SignEvent(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SignEvent(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SignEventT.
  pub fn as_sign_event(&self) -> Option<&SignEventT> {
    if let Self::SignEvent(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SignEventT.
  pub fn as_sign_event_mut(&mut self) -> Option<&mut SignEventT> {
    if let Self::SignEvent(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SetSignerT, setting the union to NONE.
  pub fn take_set_signer(&mut self) -> Option<Box<SetSignerT>> {
    if let Self::SetSigner(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SetSigner(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SetSignerT.
  pub fn as_set_signer(&self) -> Option<&SetSignerT> {
    if let Self::SetSigner(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SetSignerT.
  pub fn as_set_signer_mut(&mut self) -> Option<&mut SetSignerT> {
    if let Self::SetSigner(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GetPublicKeyT, setting the union to NONE.
  pub fn take_get_public_key(&mut self) -> Option<Box<GetPublicKeyT>> {
    if let Self::GetPublicKey(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GetPublicKey(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GetPublicKeyT.
  pub fn as_get_public_key(&self) -> Option<&GetPublicKeyT> {
    if let Self::GetPublicKey(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GetPublicKeyT.
  pub fn as_get_public_key_mut(&mut self) -> Option<&mut GetPublicKeyT> {
    if let Self::GetPublicKey(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_TYPE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_TYPE: u32 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 10] = [
  MessageType::ParsedNostrEvent,
  MessageType::ConnectionStatus,
  MessageType::CountResponse,
  MessageType::Eoce,
  MessageType::BufferFull,
  MessageType::ValidProofs,
  MessageType::SignedEvent,
  MessageType::Pubkey,
  MessageType::Raw,
  MessageType::NostrEvent,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageType(pub u32);
#[allow(non_upper_case_globals)]
impl MessageType {
  pub const ParsedNostrEvent: Self = Self(0);
  pub const ConnectionStatus: Self = Self(1);
  pub const CountResponse: Self = Self(2);
  pub const Eoce: Self = Self(3);
  pub const BufferFull: Self = Self(4);
  pub const ValidProofs: Self = Self(5);
  pub const SignedEvent: Self = Self(6);
  pub const Pubkey: Self = Self(7);
  pub const Raw: Self = Self(8);
  pub const NostrEvent: Self = Self(9);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ParsedNostrEvent,
    Self::ConnectionStatus,
    Self::CountResponse,
    Self::Eoce,
    Self::BufferFull,
    Self::ValidProofs,
    Self::SignedEvent,
    Self::Pubkey,
    Self::Raw,
    Self::NostrEvent,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ParsedNostrEvent => Some("ParsedNostrEvent"),
      Self::ConnectionStatus => Some("ConnectionStatus"),
      Self::CountResponse => Some("CountResponse"),
      Self::Eoce => Some("Eoce"),
      Self::BufferFull => Some("BufferFull"),
      Self::ValidProofs => Some("ValidProofs"),
      Self::SignedEvent => Some("SignedEvent"),
      Self::Pubkey => Some("Pubkey"),
      Self::Raw => Some("Raw"),
      Self::NostrEvent => Some("NostrEvent"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessageType {
    type Output = MessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessageType {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARSED_DATA_UNION: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARSED_DATA_UNION: u32 = 52000;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARSED_DATA_UNION: [ParsedDataUnion; 19] = [
  ParsedDataUnion::Kind0Parsed,
  ParsedDataUnion::Kind1Parsed,
  ParsedDataUnion::Kind3Parsed,
  ParsedDataUnion::Kind4Parsed,
  ParsedDataUnion::Kind6Parsed,
  ParsedDataUnion::Kind7Parsed,
  ParsedDataUnion::Kind17Parsed,
  ParsedDataUnion::Kind7374Parsed,
  ParsedDataUnion::Kind7375Parsed,
  ParsedDataUnion::Kind7376Parsed,
  ParsedDataUnion::Kind9321Parsed,
  ParsedDataUnion::Kind9735Parsed,
  ParsedDataUnion::Kind10002Parsed,
  ParsedDataUnion::Kind10019Parsed,
  ParsedDataUnion::Kind17375Parsed,
  ParsedDataUnion::Kind30023Parsed,
  ParsedDataUnion::Kind39089Parsed,
  ParsedDataUnion::ListParsed,
  ParsedDataUnion::PreGenericParsed,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ParsedDataUnion(pub u32);
#[allow(non_upper_case_globals)]
impl ParsedDataUnion {
  pub const Kind0Parsed: Self = Self(0);
  pub const Kind1Parsed: Self = Self(1);
  pub const Kind3Parsed: Self = Self(3);
  pub const Kind4Parsed: Self = Self(4);
  pub const Kind6Parsed: Self = Self(6);
  pub const Kind7Parsed: Self = Self(7);
  pub const Kind17Parsed: Self = Self(17);
  pub const Kind7374Parsed: Self = Self(7374);
  pub const Kind7375Parsed: Self = Self(7375);
  pub const Kind7376Parsed: Self = Self(7376);
  pub const Kind9321Parsed: Self = Self(9321);
  pub const Kind9735Parsed: Self = Self(9735);
  pub const Kind10002Parsed: Self = Self(10002);
  pub const Kind10019Parsed: Self = Self(10019);
  pub const Kind17375Parsed: Self = Self(17375);
  pub const Kind30023Parsed: Self = Self(30023);
  pub const Kind39089Parsed: Self = Self(39089);
  pub const ListParsed: Self = Self(51000);
  pub const PreGenericParsed: Self = Self(52000);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 52000;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Kind0Parsed,
    Self::Kind1Parsed,
    Self::Kind3Parsed,
    Self::Kind4Parsed,
    Self::Kind6Parsed,
    Self::Kind7Parsed,
    Self::Kind17Parsed,
    Self::Kind7374Parsed,
    Self::Kind7375Parsed,
    Self::Kind7376Parsed,
    Self::Kind9321Parsed,
    Self::Kind9735Parsed,
    Self::Kind10002Parsed,
    Self::Kind10019Parsed,
    Self::Kind17375Parsed,
    Self::Kind30023Parsed,
    Self::Kind39089Parsed,
    Self::ListParsed,
    Self::PreGenericParsed,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Kind0Parsed => Some("Kind0Parsed"),
      Self::Kind1Parsed => Some("Kind1Parsed"),
      Self::Kind3Parsed => Some("Kind3Parsed"),
      Self::Kind4Parsed => Some("Kind4Parsed"),
      Self::Kind6Parsed => Some("Kind6Parsed"),
      Self::Kind7Parsed => Some("Kind7Parsed"),
      Self::Kind17Parsed => Some("Kind17Parsed"),
      Self::Kind7374Parsed => Some("Kind7374Parsed"),
      Self::Kind7375Parsed => Some("Kind7375Parsed"),
      Self::Kind7376Parsed => Some("Kind7376Parsed"),
      Self::Kind9321Parsed => Some("Kind9321Parsed"),
      Self::Kind9735Parsed => Some("Kind9735Parsed"),
      Self::Kind10002Parsed => Some("Kind10002Parsed"),
      Self::Kind10019Parsed => Some("Kind10019Parsed"),
      Self::Kind17375Parsed => Some("Kind17375Parsed"),
      Self::Kind30023Parsed => Some("Kind30023Parsed"),
      Self::Kind39089Parsed => Some("Kind39089Parsed"),
      Self::ListParsed => Some("ListParsed"),
      Self::PreGenericParsed => Some("PreGenericParsed"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ParsedDataUnion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ParsedDataUnion {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ParsedDataUnion {
    type Output = ParsedDataUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ParsedDataUnion {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ParsedDataUnion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ParsedDataUnion {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARSED_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARSED_DATA: u8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARSED_DATA: [ParsedData; 19] = [
  ParsedData::NONE,
  ParsedData::Kind0Parsed,
  ParsedData::Kind1Parsed,
  ParsedData::Kind3Parsed,
  ParsedData::Kind4Parsed,
  ParsedData::Kind6Parsed,
  ParsedData::Kind7Parsed,
  ParsedData::Kind17Parsed,
  ParsedData::Kind10002Parsed,
  ParsedData::Kind10019Parsed,
  ParsedData::Kind17375Parsed,
  ParsedData::Kind7374Parsed,
  ParsedData::Kind7375Parsed,
  ParsedData::Kind7376Parsed,
  ParsedData::Kind9321Parsed,
  ParsedData::Kind9735Parsed,
  ParsedData::Kind30023Parsed,
  ParsedData::ListParsed,
  ParsedData::PreGenericParsed,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ParsedData(pub u8);
#[allow(non_upper_case_globals)]
impl ParsedData {
  pub const NONE: Self = Self(0);
  pub const Kind0Parsed: Self = Self(1);
  pub const Kind1Parsed: Self = Self(2);
  pub const Kind3Parsed: Self = Self(3);
  pub const Kind4Parsed: Self = Self(4);
  pub const Kind6Parsed: Self = Self(5);
  pub const Kind7Parsed: Self = Self(6);
  pub const Kind17Parsed: Self = Self(7);
  pub const Kind10002Parsed: Self = Self(8);
  pub const Kind10019Parsed: Self = Self(9);
  pub const Kind17375Parsed: Self = Self(10);
  pub const Kind7374Parsed: Self = Self(11);
  pub const Kind7375Parsed: Self = Self(12);
  pub const Kind7376Parsed: Self = Self(13);
  pub const Kind9321Parsed: Self = Self(14);
  pub const Kind9735Parsed: Self = Self(15);
  pub const Kind30023Parsed: Self = Self(16);
  pub const ListParsed: Self = Self(17);
  pub const PreGenericParsed: Self = Self(18);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Kind0Parsed,
    Self::Kind1Parsed,
    Self::Kind3Parsed,
    Self::Kind4Parsed,
    Self::Kind6Parsed,
    Self::Kind7Parsed,
    Self::Kind17Parsed,
    Self::Kind10002Parsed,
    Self::Kind10019Parsed,
    Self::Kind17375Parsed,
    Self::Kind7374Parsed,
    Self::Kind7375Parsed,
    Self::Kind7376Parsed,
    Self::Kind9321Parsed,
    Self::Kind9735Parsed,
    Self::Kind30023Parsed,
    Self::ListParsed,
    Self::PreGenericParsed,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Kind0Parsed => Some("Kind0Parsed"),
      Self::Kind1Parsed => Some("Kind1Parsed"),
      Self::Kind3Parsed => Some("Kind3Parsed"),
      Self::Kind4Parsed => Some("Kind4Parsed"),
      Self::Kind6Parsed => Some("Kind6Parsed"),
      Self::Kind7Parsed => Some("Kind7Parsed"),
      Self::Kind17Parsed => Some("Kind17Parsed"),
      Self::Kind10002Parsed => Some("Kind10002Parsed"),
      Self::Kind10019Parsed => Some("Kind10019Parsed"),
      Self::Kind17375Parsed => Some("Kind17375Parsed"),
      Self::Kind7374Parsed => Some("Kind7374Parsed"),
      Self::Kind7375Parsed => Some("Kind7375Parsed"),
      Self::Kind7376Parsed => Some("Kind7376Parsed"),
      Self::Kind9321Parsed => Some("Kind9321Parsed"),
      Self::Kind9735Parsed => Some("Kind9735Parsed"),
      Self::Kind30023Parsed => Some("Kind30023Parsed"),
      Self::ListParsed => Some("ListParsed"),
      Self::PreGenericParsed => Some("PreGenericParsed"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ParsedData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ParsedData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ParsedData {
    type Output = ParsedData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ParsedData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ParsedData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ParsedData {}
pub struct ParsedDataUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum ParsedDataT {
  NONE,
  Kind0Parsed(Box<Kind0ParsedT>),
  Kind1Parsed(Box<Kind1ParsedT>),
  Kind3Parsed(Box<Kind3ParsedT>),
  Kind4Parsed(Box<Kind4ParsedT>),
  Kind6Parsed(Box<Kind6ParsedT>),
  Kind7Parsed(Box<Kind7ParsedT>),
  Kind17Parsed(Box<Kind17ParsedT>),
  Kind10002Parsed(Box<Kind10002ParsedT>),
  Kind10019Parsed(Box<Kind10019ParsedT>),
  Kind17375Parsed(Box<Kind17375ParsedT>),
  Kind7374Parsed(Box<Kind7374ParsedT>),
  Kind7375Parsed(Box<Kind7375ParsedT>),
  Kind7376Parsed(Box<Kind7376ParsedT>),
  Kind9321Parsed(Box<Kind9321ParsedT>),
  Kind9735Parsed(Box<Kind9735ParsedT>),
  Kind30023Parsed(Box<Kind30023ParsedT>),
  ListParsed(Box<ListParsedT>),
  PreGenericParsed(Box<PreGenericParsedT>),
}
impl Default for ParsedDataT {
  fn default() -> Self {
    Self::NONE
  }
}
impl ParsedDataT {
  pub fn parsed_data_type(&self) -> ParsedData {
    match self {
      Self::NONE => ParsedData::NONE,
      Self::Kind0Parsed(_) => ParsedData::Kind0Parsed,
      Self::Kind1Parsed(_) => ParsedData::Kind1Parsed,
      Self::Kind3Parsed(_) => ParsedData::Kind3Parsed,
      Self::Kind4Parsed(_) => ParsedData::Kind4Parsed,
      Self::Kind6Parsed(_) => ParsedData::Kind6Parsed,
      Self::Kind7Parsed(_) => ParsedData::Kind7Parsed,
      Self::Kind17Parsed(_) => ParsedData::Kind17Parsed,
      Self::Kind10002Parsed(_) => ParsedData::Kind10002Parsed,
      Self::Kind10019Parsed(_) => ParsedData::Kind10019Parsed,
      Self::Kind17375Parsed(_) => ParsedData::Kind17375Parsed,
      Self::Kind7374Parsed(_) => ParsedData::Kind7374Parsed,
      Self::Kind7375Parsed(_) => ParsedData::Kind7375Parsed,
      Self::Kind7376Parsed(_) => ParsedData::Kind7376Parsed,
      Self::Kind9321Parsed(_) => ParsedData::Kind9321Parsed,
      Self::Kind9735Parsed(_) => ParsedData::Kind9735Parsed,
      Self::Kind30023Parsed(_) => ParsedData::Kind30023Parsed,
      Self::ListParsed(_) => ParsedData::ListParsed,
      Self::PreGenericParsed(_) => ParsedData::PreGenericParsed,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Kind0Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind1Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind3Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind4Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind6Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind17Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind10002Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind10019Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind17375Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7374Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7375Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7376Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind9321Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind9735Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind30023Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::ListParsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::PreGenericParsed(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned Kind0ParsedT, setting the union to NONE.
  pub fn take_kind_0_parsed(&mut self) -> Option<Box<Kind0ParsedT>> {
    if let Self::Kind0Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind0Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind0ParsedT.
  pub fn as_kind_0_parsed(&self) -> Option<&Kind0ParsedT> {
    if let Self::Kind0Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind0ParsedT.
  pub fn as_kind_0_parsed_mut(&mut self) -> Option<&mut Kind0ParsedT> {
    if let Self::Kind0Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind1ParsedT, setting the union to NONE.
  pub fn take_kind_1_parsed(&mut self) -> Option<Box<Kind1ParsedT>> {
    if let Self::Kind1Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind1Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind1ParsedT.
  pub fn as_kind_1_parsed(&self) -> Option<&Kind1ParsedT> {
    if let Self::Kind1Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind1ParsedT.
  pub fn as_kind_1_parsed_mut(&mut self) -> Option<&mut Kind1ParsedT> {
    if let Self::Kind1Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind3ParsedT, setting the union to NONE.
  pub fn take_kind_3_parsed(&mut self) -> Option<Box<Kind3ParsedT>> {
    if let Self::Kind3Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind3Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind3ParsedT.
  pub fn as_kind_3_parsed(&self) -> Option<&Kind3ParsedT> {
    if let Self::Kind3Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind3ParsedT.
  pub fn as_kind_3_parsed_mut(&mut self) -> Option<&mut Kind3ParsedT> {
    if let Self::Kind3Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind4ParsedT, setting the union to NONE.
  pub fn take_kind_4_parsed(&mut self) -> Option<Box<Kind4ParsedT>> {
    if let Self::Kind4Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind4Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind4ParsedT.
  pub fn as_kind_4_parsed(&self) -> Option<&Kind4ParsedT> {
    if let Self::Kind4Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind4ParsedT.
  pub fn as_kind_4_parsed_mut(&mut self) -> Option<&mut Kind4ParsedT> {
    if let Self::Kind4Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind6ParsedT, setting the union to NONE.
  pub fn take_kind_6_parsed(&mut self) -> Option<Box<Kind6ParsedT>> {
    if let Self::Kind6Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind6Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind6ParsedT.
  pub fn as_kind_6_parsed(&self) -> Option<&Kind6ParsedT> {
    if let Self::Kind6Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind6ParsedT.
  pub fn as_kind_6_parsed_mut(&mut self) -> Option<&mut Kind6ParsedT> {
    if let Self::Kind6Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7ParsedT, setting the union to NONE.
  pub fn take_kind_7_parsed(&mut self) -> Option<Box<Kind7ParsedT>> {
    if let Self::Kind7Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7ParsedT.
  pub fn as_kind_7_parsed(&self) -> Option<&Kind7ParsedT> {
    if let Self::Kind7Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7ParsedT.
  pub fn as_kind_7_parsed_mut(&mut self) -> Option<&mut Kind7ParsedT> {
    if let Self::Kind7Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind17ParsedT, setting the union to NONE.
  pub fn take_kind_17_parsed(&mut self) -> Option<Box<Kind17ParsedT>> {
    if let Self::Kind17Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind17Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind17ParsedT.
  pub fn as_kind_17_parsed(&self) -> Option<&Kind17ParsedT> {
    if let Self::Kind17Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind17ParsedT.
  pub fn as_kind_17_parsed_mut(&mut self) -> Option<&mut Kind17ParsedT> {
    if let Self::Kind17Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind10002ParsedT, setting the union to NONE.
  pub fn take_kind_10002_parsed(&mut self) -> Option<Box<Kind10002ParsedT>> {
    if let Self::Kind10002Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind10002Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind10002ParsedT.
  pub fn as_kind_10002_parsed(&self) -> Option<&Kind10002ParsedT> {
    if let Self::Kind10002Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind10002ParsedT.
  pub fn as_kind_10002_parsed_mut(&mut self) -> Option<&mut Kind10002ParsedT> {
    if let Self::Kind10002Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind10019ParsedT, setting the union to NONE.
  pub fn take_kind_10019_parsed(&mut self) -> Option<Box<Kind10019ParsedT>> {
    if let Self::Kind10019Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind10019Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind10019ParsedT.
  pub fn as_kind_10019_parsed(&self) -> Option<&Kind10019ParsedT> {
    if let Self::Kind10019Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind10019ParsedT.
  pub fn as_kind_10019_parsed_mut(&mut self) -> Option<&mut Kind10019ParsedT> {
    if let Self::Kind10019Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind17375ParsedT, setting the union to NONE.
  pub fn take_kind_17375_parsed(&mut self) -> Option<Box<Kind17375ParsedT>> {
    if let Self::Kind17375Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind17375Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind17375ParsedT.
  pub fn as_kind_17375_parsed(&self) -> Option<&Kind17375ParsedT> {
    if let Self::Kind17375Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind17375ParsedT.
  pub fn as_kind_17375_parsed_mut(&mut self) -> Option<&mut Kind17375ParsedT> {
    if let Self::Kind17375Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7374ParsedT, setting the union to NONE.
  pub fn take_kind_7374_parsed(&mut self) -> Option<Box<Kind7374ParsedT>> {
    if let Self::Kind7374Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7374Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7374ParsedT.
  pub fn as_kind_7374_parsed(&self) -> Option<&Kind7374ParsedT> {
    if let Self::Kind7374Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7374ParsedT.
  pub fn as_kind_7374_parsed_mut(&mut self) -> Option<&mut Kind7374ParsedT> {
    if let Self::Kind7374Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7375ParsedT, setting the union to NONE.
  pub fn take_kind_7375_parsed(&mut self) -> Option<Box<Kind7375ParsedT>> {
    if let Self::Kind7375Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7375Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7375ParsedT.
  pub fn as_kind_7375_parsed(&self) -> Option<&Kind7375ParsedT> {
    if let Self::Kind7375Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7375ParsedT.
  pub fn as_kind_7375_parsed_mut(&mut self) -> Option<&mut Kind7375ParsedT> {
    if let Self::Kind7375Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7376ParsedT, setting the union to NONE.
  pub fn take_kind_7376_parsed(&mut self) -> Option<Box<Kind7376ParsedT>> {
    if let Self::Kind7376Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7376Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7376ParsedT.
  pub fn as_kind_7376_parsed(&self) -> Option<&Kind7376ParsedT> {
    if let Self::Kind7376Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7376ParsedT.
  pub fn as_kind_7376_parsed_mut(&mut self) -> Option<&mut Kind7376ParsedT> {
    if let Self::Kind7376Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind9321ParsedT, setting the union to NONE.
  pub fn take_kind_9321_parsed(&mut self) -> Option<Box<Kind9321ParsedT>> {
    if let Self::Kind9321Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind9321Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind9321ParsedT.
  pub fn as_kind_9321_parsed(&self) -> Option<&Kind9321ParsedT> {
    if let Self::Kind9321Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind9321ParsedT.
  pub fn as_kind_9321_parsed_mut(&mut self) -> Option<&mut Kind9321ParsedT> {
    if let Self::Kind9321Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind9735ParsedT, setting the union to NONE.
  pub fn take_kind_9735_parsed(&mut self) -> Option<Box<Kind9735ParsedT>> {
    if let Self::Kind9735Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind9735Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind9735ParsedT.
  pub fn as_kind_9735_parsed(&self) -> Option<&Kind9735ParsedT> {
    if let Self::Kind9735Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind9735ParsedT.
  pub fn as_kind_9735_parsed_mut(&mut self) -> Option<&mut Kind9735ParsedT> {
    if let Self::Kind9735Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind30023ParsedT, setting the union to NONE.
  pub fn take_kind_30023_parsed(&mut self) -> Option<Box<Kind30023ParsedT>> {
    if let Self::Kind30023Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind30023Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind30023ParsedT.
  pub fn as_kind_30023_parsed(&self) -> Option<&Kind30023ParsedT> {
    if let Self::Kind30023Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind30023ParsedT.
  pub fn as_kind_30023_parsed_mut(&mut self) -> Option<&mut Kind30023ParsedT> {
    if let Self::Kind30023Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ListParsedT, setting the union to NONE.
  pub fn take_list_parsed(&mut self) -> Option<Box<ListParsedT>> {
    if let Self::ListParsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ListParsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ListParsedT.
  pub fn as_list_parsed(&self) -> Option<&ListParsedT> {
    if let Self::ListParsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ListParsedT.
  pub fn as_list_parsed_mut(&mut self) -> Option<&mut ListParsedT> {
    if let Self::ListParsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PreGenericParsedT, setting the union to NONE.
  pub fn take_pre_generic_parsed(&mut self) -> Option<Box<PreGenericParsedT>> {
    if let Self::PreGenericParsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PreGenericParsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PreGenericParsedT.
  pub fn as_pre_generic_parsed(&self) -> Option<&PreGenericParsedT> {
    if let Self::PreGenericParsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PreGenericParsedT.
  pub fn as_pre_generic_parsed_mut(&mut self) -> Option<&mut PreGenericParsedT> {
    if let Self::PreGenericParsed(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE: [Message; 11] = [
  Message::NONE,
  Message::ParsedEvent,
  Message::NostrEvent,
  Message::ConnectionStatus,
  Message::CountResponse,
  Message::Eoce,
  Message::BufferFull,
  Message::ValidProofs,
  Message::SignedEvent,
  Message::Pubkey,
  Message::Raw,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Message(pub u8);
#[allow(non_upper_case_globals)]
impl Message {
  pub const NONE: Self = Self(0);
  pub const ParsedEvent: Self = Self(1);
  pub const NostrEvent: Self = Self(2);
  pub const ConnectionStatus: Self = Self(3);
  pub const CountResponse: Self = Self(4);
  pub const Eoce: Self = Self(5);
  pub const BufferFull: Self = Self(6);
  pub const ValidProofs: Self = Self(7);
  pub const SignedEvent: Self = Self(8);
  pub const Pubkey: Self = Self(9);
  pub const Raw: Self = Self(10);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ParsedEvent,
    Self::NostrEvent,
    Self::ConnectionStatus,
    Self::CountResponse,
    Self::Eoce,
    Self::BufferFull,
    Self::ValidProofs,
    Self::SignedEvent,
    Self::Pubkey,
    Self::Raw,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ParsedEvent => Some("ParsedEvent"),
      Self::NostrEvent => Some("NostrEvent"),
      Self::ConnectionStatus => Some("ConnectionStatus"),
      Self::CountResponse => Some("CountResponse"),
      Self::Eoce => Some("Eoce"),
      Self::BufferFull => Some("BufferFull"),
      Self::ValidProofs => Some("ValidProofs"),
      Self::SignedEvent => Some("SignedEvent"),
      Self::Pubkey => Some("Pubkey"),
      Self::Raw => Some("Raw"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Message {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Message {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Message {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Message {}
pub struct MessageUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum MessageT {
  NONE,
  ParsedEvent(Box<ParsedEventT>),
  NostrEvent(Box<NostrEventT>),
  ConnectionStatus(Box<ConnectionStatusT>),
  CountResponse(Box<CountResponseT>),
  Eoce(Box<EoceT>),
  BufferFull(Box<BufferFullT>),
  ValidProofs(Box<ValidProofsT>),
  SignedEvent(Box<SignedEventT>),
  Pubkey(Box<PubkeyT>),
  Raw(Box<RawT>),
}
impl Default for MessageT {
  fn default() -> Self {
    Self::NONE
  }
}
impl MessageT {
  pub fn message_type(&self) -> Message {
    match self {
      Self::NONE => Message::NONE,
      Self::ParsedEvent(_) => Message::ParsedEvent,
      Self::NostrEvent(_) => Message::NostrEvent,
      Self::ConnectionStatus(_) => Message::ConnectionStatus,
      Self::CountResponse(_) => Message::CountResponse,
      Self::Eoce(_) => Message::Eoce,
      Self::BufferFull(_) => Message::BufferFull,
      Self::ValidProofs(_) => Message::ValidProofs,
      Self::SignedEvent(_) => Message::SignedEvent,
      Self::Pubkey(_) => Message::Pubkey,
      Self::Raw(_) => Message::Raw,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::ParsedEvent(v) => Some(v.pack(fbb).as_union_value()),
      Self::NostrEvent(v) => Some(v.pack(fbb).as_union_value()),
      Self::ConnectionStatus(v) => Some(v.pack(fbb).as_union_value()),
      Self::CountResponse(v) => Some(v.pack(fbb).as_union_value()),
      Self::Eoce(v) => Some(v.pack(fbb).as_union_value()),
      Self::BufferFull(v) => Some(v.pack(fbb).as_union_value()),
      Self::ValidProofs(v) => Some(v.pack(fbb).as_union_value()),
      Self::SignedEvent(v) => Some(v.pack(fbb).as_union_value()),
      Self::Pubkey(v) => Some(v.pack(fbb).as_union_value()),
      Self::Raw(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned ParsedEventT, setting the union to NONE.
  pub fn take_parsed_event(&mut self) -> Option<Box<ParsedEventT>> {
    if let Self::ParsedEvent(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ParsedEvent(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ParsedEventT.
  pub fn as_parsed_event(&self) -> Option<&ParsedEventT> {
    if let Self::ParsedEvent(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ParsedEventT.
  pub fn as_parsed_event_mut(&mut self) -> Option<&mut ParsedEventT> {
    if let Self::ParsedEvent(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NostrEventT, setting the union to NONE.
  pub fn take_nostr_event(&mut self) -> Option<Box<NostrEventT>> {
    if let Self::NostrEvent(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NostrEvent(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NostrEventT.
  pub fn as_nostr_event(&self) -> Option<&NostrEventT> {
    if let Self::NostrEvent(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NostrEventT.
  pub fn as_nostr_event_mut(&mut self) -> Option<&mut NostrEventT> {
    if let Self::NostrEvent(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ConnectionStatusT, setting the union to NONE.
  pub fn take_connection_status(&mut self) -> Option<Box<ConnectionStatusT>> {
    if let Self::ConnectionStatus(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ConnectionStatus(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ConnectionStatusT.
  pub fn as_connection_status(&self) -> Option<&ConnectionStatusT> {
    if let Self::ConnectionStatus(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ConnectionStatusT.
  pub fn as_connection_status_mut(&mut self) -> Option<&mut ConnectionStatusT> {
    if let Self::ConnectionStatus(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CountResponseT, setting the union to NONE.
  pub fn take_count_response(&mut self) -> Option<Box<CountResponseT>> {
    if let Self::CountResponse(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CountResponse(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CountResponseT.
  pub fn as_count_response(&self) -> Option<&CountResponseT> {
    if let Self::CountResponse(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CountResponseT.
  pub fn as_count_response_mut(&mut self) -> Option<&mut CountResponseT> {
    if let Self::CountResponse(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned EoceT, setting the union to NONE.
  pub fn take_eoce(&mut self) -> Option<Box<EoceT>> {
    if let Self::Eoce(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Eoce(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the EoceT.
  pub fn as_eoce(&self) -> Option<&EoceT> {
    if let Self::Eoce(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the EoceT.
  pub fn as_eoce_mut(&mut self) -> Option<&mut EoceT> {
    if let Self::Eoce(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned BufferFullT, setting the union to NONE.
  pub fn take_buffer_full(&mut self) -> Option<Box<BufferFullT>> {
    if let Self::BufferFull(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::BufferFull(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the BufferFullT.
  pub fn as_buffer_full(&self) -> Option<&BufferFullT> {
    if let Self::BufferFull(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the BufferFullT.
  pub fn as_buffer_full_mut(&mut self) -> Option<&mut BufferFullT> {
    if let Self::BufferFull(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ValidProofsT, setting the union to NONE.
  pub fn take_valid_proofs(&mut self) -> Option<Box<ValidProofsT>> {
    if let Self::ValidProofs(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ValidProofs(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ValidProofsT.
  pub fn as_valid_proofs(&self) -> Option<&ValidProofsT> {
    if let Self::ValidProofs(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ValidProofsT.
  pub fn as_valid_proofs_mut(&mut self) -> Option<&mut ValidProofsT> {
    if let Self::ValidProofs(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SignedEventT, setting the union to NONE.
  pub fn take_signed_event(&mut self) -> Option<Box<SignedEventT>> {
    if let Self::SignedEvent(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SignedEvent(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SignedEventT.
  pub fn as_signed_event(&self) -> Option<&SignedEventT> {
    if let Self::SignedEvent(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SignedEventT.
  pub fn as_signed_event_mut(&mut self) -> Option<&mut SignedEventT> {
    if let Self::SignedEvent(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PubkeyT, setting the union to NONE.
  pub fn take_pubkey(&mut self) -> Option<Box<PubkeyT>> {
    if let Self::Pubkey(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Pubkey(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PubkeyT.
  pub fn as_pubkey(&self) -> Option<&PubkeyT> {
    if let Self::Pubkey(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PubkeyT.
  pub fn as_pubkey_mut(&mut self) -> Option<&mut PubkeyT> {
    if let Self::Pubkey(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned RawT, setting the union to NONE.
  pub fn take_raw(&mut self) -> Option<Box<RawT>> {
    if let Self::Raw(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Raw(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the RawT.
  pub fn as_raw(&self) -> Option<&RawT> {
    if let Self::Raw(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the RawT.
  pub fn as_raw_mut(&mut self) -> Option<&mut RawT> {
    if let Self::Raw(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SIGNER_OP: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SIGNER_OP: u32 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SIGNER_OP: [SignerOp; 9] = [
  SignerOp::GetPubkey,
  SignerOp::SignEvent,
  SignerOp::Nip04Encrypt,
  SignerOp::Nip04Decrypt,
  SignerOp::Nip44Encrypt,
  SignerOp::Nip44Decrypt,
  SignerOp::Nip04DecryptBetween,
  SignerOp::Nip44DecryptBetween,
  SignerOp::VerifyProof,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SignerOp(pub u32);
#[allow(non_upper_case_globals)]
impl SignerOp {
  pub const GetPubkey: Self = Self(0);
  pub const SignEvent: Self = Self(1);
  pub const Nip04Encrypt: Self = Self(2);
  pub const Nip04Decrypt: Self = Self(3);
  pub const Nip44Encrypt: Self = Self(4);
  pub const Nip44Decrypt: Self = Self(5);
  pub const Nip04DecryptBetween: Self = Self(6);
  pub const Nip44DecryptBetween: Self = Self(7);
  pub const VerifyProof: Self = Self(8);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GetPubkey,
    Self::SignEvent,
    Self::Nip04Encrypt,
    Self::Nip04Decrypt,
    Self::Nip44Encrypt,
    Self::Nip44Decrypt,
    Self::Nip04DecryptBetween,
    Self::Nip44DecryptBetween,
    Self::VerifyProof,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::GetPubkey => Some("GetPubkey"),
      Self::SignEvent => Some("SignEvent"),
      Self::Nip04Encrypt => Some("Nip04Encrypt"),
      Self::Nip04Decrypt => Some("Nip04Decrypt"),
      Self::Nip44Encrypt => Some("Nip44Encrypt"),
      Self::Nip44Decrypt => Some("Nip44Decrypt"),
      Self::Nip04DecryptBetween => Some("Nip04DecryptBetween"),
      Self::Nip44DecryptBetween => Some("Nip44DecryptBetween"),
      Self::VerifyProof => Some("VerifyProof"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SignerOp {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SignerOp {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SignerOp {
    type Output = SignerOp;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SignerOp {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SignerOp {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SignerOp {}
pub enum CodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CodeData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CodeData<'a> {
  type Inner = CodeData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CodeData<'a> {
  pub const VT_LANGUAGE: flatbuffers::VOffsetT = 4;
  pub const VT_CODE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CodeData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CodeDataArgs<'args>
  ) -> flatbuffers::WIPOffset<CodeData<'bldr>> {
    let mut builder = CodeDataBuilder::new(_fbb);
    if let Some(x) = args.code { builder.add_code(x); }
    if let Some(x) = args.language { builder.add_language(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CodeDataT {
    let language = self.language().map(|x| {
      x.to_string()
    });
    let code = {
      let x = self.code();
      x.to_string()
    };
    CodeDataT {
      language,
      code,
    }
  }

  #[inline]
  pub fn language(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeData::VT_LANGUAGE, None)}
  }
  #[inline]
  pub fn code(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeData::VT_CODE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for CodeData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, true)?
     .finish();
    Ok(())
  }
}
pub struct CodeDataArgs<'a> {
    pub language: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CodeDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    CodeDataArgs {
      language: None,
      code: None, // required field
    }
  }
}

pub struct CodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CodeDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_language(&mut self, language: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeData::VT_LANGUAGE, language);
  }
  #[inline]
  pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeData::VT_CODE, code);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CodeDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CodeDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CodeData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CodeData::VT_CODE,"code");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CodeData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CodeData");
      ds.field("language", &self.language());
      ds.field("code", &self.code());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CodeDataT {
  pub language: Option<String>,
  pub code: String,
}
impl Default for CodeDataT {
  fn default() -> Self {
    Self {
      language: None,
      code: "".to_string(),
    }
  }
}
impl CodeDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CodeData<'b>> {
    let language = self.language.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let code = Some({
      let x = &self.code;
      _fbb.create_string(x)
    });
    CodeData::create(_fbb, &CodeDataArgs{
      language,
      code,
    })
  }
}
pub enum HashtagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HashtagData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HashtagData<'a> {
  type Inner = HashtagData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HashtagData<'a> {
  pub const VT_TAG: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HashtagData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HashtagDataArgs<'args>
  ) -> flatbuffers::WIPOffset<HashtagData<'bldr>> {
    let mut builder = HashtagDataBuilder::new(_fbb);
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> HashtagDataT {
    let tag = {
      let x = self.tag();
      x.to_string()
    };
    HashtagDataT {
      tag,
    }
  }

  #[inline]
  pub fn tag(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HashtagData::VT_TAG, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for HashtagData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, true)?
     .finish();
    Ok(())
  }
}
pub struct HashtagDataArgs<'a> {
    pub tag: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HashtagDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    HashtagDataArgs {
      tag: None, // required field
    }
  }
}

pub struct HashtagDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HashtagDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HashtagData::VT_TAG, tag);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HashtagDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HashtagDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HashtagData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, HashtagData::VT_TAG,"tag");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HashtagData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HashtagData");
      ds.field("tag", &self.tag());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HashtagDataT {
  pub tag: String,
}
impl Default for HashtagDataT {
  fn default() -> Self {
    Self {
      tag: "".to_string(),
    }
  }
}
impl HashtagDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<HashtagData<'b>> {
    let tag = Some({
      let x = &self.tag;
      _fbb.create_string(x)
    });
    HashtagData::create(_fbb, &HashtagDataArgs{
      tag,
    })
  }
}
pub enum CashuDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CashuData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CashuData<'a> {
  type Inner = CashuData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CashuData<'a> {
  pub const VT_TOKEN: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CashuData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CashuDataArgs<'args>
  ) -> flatbuffers::WIPOffset<CashuData<'bldr>> {
    let mut builder = CashuDataBuilder::new(_fbb);
    if let Some(x) = args.token { builder.add_token(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CashuDataT {
    let token = {
      let x = self.token();
      x.to_string()
    };
    CashuDataT {
      token,
    }
  }

  #[inline]
  pub fn token(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CashuData::VT_TOKEN, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for CashuData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("token", Self::VT_TOKEN, true)?
     .finish();
    Ok(())
  }
}
pub struct CashuDataArgs<'a> {
    pub token: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CashuDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    CashuDataArgs {
      token: None, // required field
    }
  }
}

pub struct CashuDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CashuDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_token(&mut self, token: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CashuData::VT_TOKEN, token);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CashuDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CashuDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CashuData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CashuData::VT_TOKEN,"token");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CashuData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CashuData");
      ds.field("token", &self.token());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CashuDataT {
  pub token: String,
}
impl Default for CashuDataT {
  fn default() -> Self {
    Self {
      token: "".to_string(),
    }
  }
}
impl CashuDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CashuData<'b>> {
    let token = Some({
      let x = &self.token;
      _fbb.create_string(x)
    });
    CashuData::create(_fbb, &CashuDataArgs{
      token,
    })
  }
}
pub enum ImageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageData<'a> {
  type Inner = ImageData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ImageData<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_ALT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ImageDataArgs<'args>
  ) -> flatbuffers::WIPOffset<ImageData<'bldr>> {
    let mut builder = ImageDataBuilder::new(_fbb);
    if let Some(x) = args.alt { builder.add_alt(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ImageDataT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let alt = self.alt().map(|x| {
      x.to_string()
    });
    ImageDataT {
      url,
      alt,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageData::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn alt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageData::VT_ALT, None)}
  }
}

impl flatbuffers::Verifiable for ImageData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alt", Self::VT_ALT, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageDataArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alt: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ImageDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ImageDataArgs {
      url: None, // required field
      alt: None,
    }
  }
}

pub struct ImageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ImageDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageData::VT_URL, url);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageData::VT_ALT, alt);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ImageDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ImageDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ImageData::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageData");
      ds.field("url", &self.url());
      ds.field("alt", &self.alt());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ImageDataT {
  pub url: String,
  pub alt: Option<String>,
}
impl Default for ImageDataT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      alt: None,
    }
  }
}
impl ImageDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ImageData<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let alt = self.alt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ImageData::create(_fbb, &ImageDataArgs{
      url,
      alt,
    })
  }
}
pub enum VideoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VideoData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VideoData<'a> {
  type Inner = VideoData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VideoData<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_THUMBNAIL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VideoData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VideoDataArgs<'args>
  ) -> flatbuffers::WIPOffset<VideoData<'bldr>> {
    let mut builder = VideoDataBuilder::new(_fbb);
    if let Some(x) = args.thumbnail { builder.add_thumbnail(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> VideoDataT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let thumbnail = self.thumbnail().map(|x| {
      x.to_string()
    });
    VideoDataT {
      url,
      thumbnail,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VideoData::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn thumbnail(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VideoData::VT_THUMBNAIL, None)}
  }
}

impl flatbuffers::Verifiable for VideoData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("thumbnail", Self::VT_THUMBNAIL, false)?
     .finish();
    Ok(())
  }
}
pub struct VideoDataArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub thumbnail: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for VideoDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    VideoDataArgs {
      url: None, // required field
      thumbnail: None,
    }
  }
}

pub struct VideoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VideoDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VideoData::VT_URL, url);
  }
  #[inline]
  pub fn add_thumbnail(&mut self, thumbnail: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VideoData::VT_THUMBNAIL, thumbnail);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VideoDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VideoDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VideoData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, VideoData::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VideoData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VideoData");
      ds.field("url", &self.url());
      ds.field("thumbnail", &self.thumbnail());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VideoDataT {
  pub url: String,
  pub thumbnail: Option<String>,
}
impl Default for VideoDataT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      thumbnail: None,
    }
  }
}
impl VideoDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<VideoData<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let thumbnail = self.thumbnail.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    VideoData::create(_fbb, &VideoDataArgs{
      url,
      thumbnail,
    })
  }
}
pub enum MediaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MediaItem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MediaItem<'a> {
  type Inner = MediaItem<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MediaItem<'a> {
  pub const VT_IMAGE: flatbuffers::VOffsetT = 4;
  pub const VT_VIDEO: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MediaItem { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MediaItemArgs<'args>
  ) -> flatbuffers::WIPOffset<MediaItem<'bldr>> {
    let mut builder = MediaItemBuilder::new(_fbb);
    if let Some(x) = args.video { builder.add_video(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MediaItemT {
    let image = self.image().map(|x| {
      Box::new(x.unpack())
    });
    let video = self.video().map(|x| {
      Box::new(x.unpack())
    });
    MediaItemT {
      image,
      video,
    }
  }

  #[inline]
  pub fn image(&self) -> Option<ImageData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ImageData>>(MediaItem::VT_IMAGE, None)}
  }
  #[inline]
  pub fn video(&self) -> Option<VideoData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VideoData>>(MediaItem::VT_VIDEO, None)}
  }
}

impl flatbuffers::Verifiable for MediaItem<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ImageData>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VideoData>>("video", Self::VT_VIDEO, false)?
     .finish();
    Ok(())
  }
}
pub struct MediaItemArgs<'a> {
    pub image: Option<flatbuffers::WIPOffset<ImageData<'a>>>,
    pub video: Option<flatbuffers::WIPOffset<VideoData<'a>>>,
}
impl<'a> Default for MediaItemArgs<'a> {
  #[inline]
  fn default() -> Self {
    MediaItemArgs {
      image: None,
      video: None,
    }
  }
}

pub struct MediaItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MediaItemBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<ImageData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ImageData>>(MediaItem::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_video(&mut self, video: flatbuffers::WIPOffset<VideoData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VideoData>>(MediaItem::VT_VIDEO, video);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MediaItemBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MediaItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MediaItem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MediaItem<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MediaItem");
      ds.field("image", &self.image());
      ds.field("video", &self.video());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MediaItemT {
  pub image: Option<Box<ImageDataT>>,
  pub video: Option<Box<VideoDataT>>,
}
impl Default for MediaItemT {
  fn default() -> Self {
    Self {
      image: None,
      video: None,
    }
  }
}
impl MediaItemT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MediaItem<'b>> {
    let image = self.image.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let video = self.video.as_ref().map(|x|{
      x.pack(_fbb)
    });
    MediaItem::create(_fbb, &MediaItemArgs{
      image,
      video,
    })
  }
}
pub enum MediaGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MediaGroupData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MediaGroupData<'a> {
  type Inner = MediaGroupData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MediaGroupData<'a> {
  pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MediaGroupData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MediaGroupDataArgs<'args>
  ) -> flatbuffers::WIPOffset<MediaGroupData<'bldr>> {
    let mut builder = MediaGroupDataBuilder::new(_fbb);
    if let Some(x) = args.items { builder.add_items(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MediaGroupDataT {
    let items = self.items().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MediaGroupDataT {
      items,
    }
  }

  #[inline]
  pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MediaItem<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MediaItem>>>>(MediaGroupData::VT_ITEMS, None)}
  }
}

impl flatbuffers::Verifiable for MediaGroupData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MediaItem>>>>("items", Self::VT_ITEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct MediaGroupDataArgs<'a> {
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MediaItem<'a>>>>>,
}
impl<'a> Default for MediaGroupDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MediaGroupDataArgs {
      items: None,
    }
  }
}

pub struct MediaGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MediaGroupDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_items(&mut self, items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MediaItem<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MediaGroupData::VT_ITEMS, items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MediaGroupDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MediaGroupDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MediaGroupData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MediaGroupData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MediaGroupData");
      ds.field("items", &self.items());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MediaGroupDataT {
  pub items: Option<Vec<MediaItemT>>,
}
impl Default for MediaGroupDataT {
  fn default() -> Self {
    Self {
      items: None,
    }
  }
}
impl MediaGroupDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MediaGroupData<'b>> {
    let items = self.items.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MediaGroupData::create(_fbb, &MediaGroupDataArgs{
      items,
    })
  }
}
pub enum NostrDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NostrData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NostrData<'a> {
  type Inner = NostrData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NostrData<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITY: flatbuffers::VOffsetT = 6;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 8;
  pub const VT_AUTHOR: flatbuffers::VOffsetT = 10;
  pub const VT_KIND: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NostrData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NostrDataArgs<'args>
  ) -> flatbuffers::WIPOffset<NostrData<'bldr>> {
    let mut builder = NostrDataBuilder::new(_fbb);
    builder.add_kind(args.kind);
    if let Some(x) = args.author { builder.add_author(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.entity { builder.add_entity(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> NostrDataT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let entity = {
      let x = self.entity();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let author = self.author().map(|x| {
      x.to_string()
    });
    let kind = self.kind();
    NostrDataT {
      id,
      entity,
      relays,
      author,
      kind,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrData::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn entity(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrData::VT_ENTITY, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(NostrData::VT_RELAYS, None)}
  }
  #[inline]
  pub fn author(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrData::VT_AUTHOR, None)}
  }
  #[inline]
  pub fn kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(NostrData::VT_KIND, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for NostrData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entity", Self::VT_ENTITY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("author", Self::VT_AUTHOR, false)?
     .visit_field::<u64>("kind", Self::VT_KIND, false)?
     .finish();
    Ok(())
  }
}
pub struct NostrDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub author: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u64,
}
impl<'a> Default for NostrDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    NostrDataArgs {
      id: None, // required field
      entity: None, // required field
      relays: None,
      author: None,
      kind: 0,
    }
  }
}

pub struct NostrDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NostrDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_ID, id);
  }
  #[inline]
  pub fn add_entity(&mut self, entity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_ENTITY, entity);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_author(&mut self, author: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_AUTHOR, author);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u64) {
    self.fbb_.push_slot::<u64>(NostrData::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NostrDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NostrDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NostrData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, NostrData::VT_ID,"id");
    self.fbb_.required(o, NostrData::VT_ENTITY,"entity");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NostrData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NostrData");
      ds.field("id", &self.id());
      ds.field("entity", &self.entity());
      ds.field("relays", &self.relays());
      ds.field("author", &self.author());
      ds.field("kind", &self.kind());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NostrDataT {
  pub id: String,
  pub entity: String,
  pub relays: Option<Vec<String>>,
  pub author: Option<String>,
  pub kind: u64,
}
impl Default for NostrDataT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      entity: "".to_string(),
      relays: None,
      author: None,
      kind: 0,
    }
  }
}
impl NostrDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<NostrData<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let entity = Some({
      let x = &self.entity;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let author = self.author.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let kind = self.kind;
    NostrData::create(_fbb, &NostrDataArgs{
      id,
      entity,
      relays,
      author,
      kind,
    })
  }
}
pub enum LinkPreviewDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LinkPreviewData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinkPreviewData<'a> {
  type Inner = LinkPreviewData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinkPreviewData<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_TITLE: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinkPreviewData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LinkPreviewDataArgs<'args>
  ) -> flatbuffers::WIPOffset<LinkPreviewData<'bldr>> {
    let mut builder = LinkPreviewDataBuilder::new(_fbb);
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> LinkPreviewDataT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let title = self.title().map(|x| {
      x.to_string()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    LinkPreviewDataT {
      url,
      title,
      description,
      image,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_TITLE, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_IMAGE, None)}
  }
}

impl flatbuffers::Verifiable for LinkPreviewData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct LinkPreviewDataArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LinkPreviewDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinkPreviewDataArgs {
      url: None, // required field
      title: None,
      description: None,
      image: None,
    }
  }
}

pub struct LinkPreviewDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LinkPreviewDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_URL, url);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_TITLE, title);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_IMAGE, image);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LinkPreviewDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LinkPreviewDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinkPreviewData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LinkPreviewData::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinkPreviewData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinkPreviewData");
      ds.field("url", &self.url());
      ds.field("title", &self.title());
      ds.field("description", &self.description());
      ds.field("image", &self.image());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LinkPreviewDataT {
  pub url: String,
  pub title: Option<String>,
  pub description: Option<String>,
  pub image: Option<String>,
}
impl Default for LinkPreviewDataT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      title: None,
      description: None,
      image: None,
    }
  }
}
impl LinkPreviewDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LinkPreviewData<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let title = self.title.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    LinkPreviewData::create(_fbb, &LinkPreviewDataArgs{
      url,
      title,
      description,
      image,
    })
  }
}
pub enum ContentBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentBlock<'a> {
  type Inner = ContentBlock<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentBlock<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentBlock { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentBlockArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentBlock<'bldr>> {
    let mut builder = ContentBlockBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.add_data_type(args.data_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ContentBlockT {
    let type_ = {
      let x = self.type_();
      x.to_string()
    };
    let text = {
      let x = self.text();
      x.to_string()
    };
    let data = match self.data_type() {
      ContentData::NONE => ContentDataT::NONE,
      ContentData::CodeData => ContentDataT::CodeData(Box::new(
        self.data_as_code_data()
            .expect("Invalid union table, expected `ContentData::CodeData`.")
            .unpack()
      )),
      ContentData::HashtagData => ContentDataT::HashtagData(Box::new(
        self.data_as_hashtag_data()
            .expect("Invalid union table, expected `ContentData::HashtagData`.")
            .unpack()
      )),
      ContentData::CashuData => ContentDataT::CashuData(Box::new(
        self.data_as_cashu_data()
            .expect("Invalid union table, expected `ContentData::CashuData`.")
            .unpack()
      )),
      ContentData::ImageData => ContentDataT::ImageData(Box::new(
        self.data_as_image_data()
            .expect("Invalid union table, expected `ContentData::ImageData`.")
            .unpack()
      )),
      ContentData::VideoData => ContentDataT::VideoData(Box::new(
        self.data_as_video_data()
            .expect("Invalid union table, expected `ContentData::VideoData`.")
            .unpack()
      )),
      ContentData::MediaGroupData => ContentDataT::MediaGroupData(Box::new(
        self.data_as_media_group_data()
            .expect("Invalid union table, expected `ContentData::MediaGroupData`.")
            .unpack()
      )),
      ContentData::NostrData => ContentDataT::NostrData(Box::new(
        self.data_as_nostr_data()
            .expect("Invalid union table, expected `ContentData::NostrData`.")
            .unpack()
      )),
      ContentData::LinkPreviewData => ContentDataT::LinkPreviewData(Box::new(
        self.data_as_link_preview_data()
            .expect("Invalid union table, expected `ContentData::LinkPreviewData`.")
            .unpack()
      )),
      _ => ContentDataT::NONE,
    };
    ContentBlockT {
      type_,
      text,
      data,
    }
  }

  #[inline]
  pub fn type_(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentBlock::VT_TYPE_, None).unwrap()}
  }
  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentBlock::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn data_type(&self) -> ContentData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ContentData>(ContentBlock::VT_DATA_TYPE, Some(ContentData::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ContentBlock::VT_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_code_data(&self) -> Option<CodeData<'a>> {
    if self.data_type() == ContentData::CodeData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CodeData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_hashtag_data(&self) -> Option<HashtagData<'a>> {
    if self.data_type() == ContentData::HashtagData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HashtagData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_cashu_data(&self) -> Option<CashuData<'a>> {
    if self.data_type() == ContentData::CashuData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CashuData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_image_data(&self) -> Option<ImageData<'a>> {
    if self.data_type() == ContentData::ImageData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ImageData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_video_data(&self) -> Option<VideoData<'a>> {
    if self.data_type() == ContentData::VideoData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { VideoData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_media_group_data(&self) -> Option<MediaGroupData<'a>> {
    if self.data_type() == ContentData::MediaGroupData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MediaGroupData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_nostr_data(&self) -> Option<NostrData<'a>> {
    if self.data_type() == ContentData::NostrData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NostrData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_link_preview_data(&self) -> Option<LinkPreviewData<'a>> {
    if self.data_type() == ContentData::LinkPreviewData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LinkPreviewData::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ContentBlock<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_union::<ContentData, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, false, |key, v, pos| {
        match key {
          ContentData::CodeData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CodeData>>("ContentData::CodeData", pos),
          ContentData::HashtagData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtagData>>("ContentData::HashtagData", pos),
          ContentData::CashuData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CashuData>>("ContentData::CashuData", pos),
          ContentData::ImageData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ImageData>>("ContentData::ImageData", pos),
          ContentData::VideoData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VideoData>>("ContentData::VideoData", pos),
          ContentData::MediaGroupData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MediaGroupData>>("ContentData::MediaGroupData", pos),
          ContentData::NostrData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NostrData>>("ContentData::NostrData", pos),
          ContentData::LinkPreviewData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LinkPreviewData>>("ContentData::LinkPreviewData", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ContentBlockArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_type: ContentData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ContentBlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentBlockArgs {
      type_: None, // required field
      text: None, // required field
      data_type: ContentData::NONE,
      data: None,
    }
  }
}

pub struct ContentBlockBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentBlockBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentBlock::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentBlock::VT_TEXT, text);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: ContentData) {
    self.fbb_.push_slot::<ContentData>(ContentBlock::VT_DATA_TYPE, data_type, ContentData::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentBlock::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentBlockBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContentBlock::VT_TYPE_,"type_");
    self.fbb_.required(o, ContentBlock::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentBlock<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentBlock");
      ds.field("type_", &self.type_());
      ds.field("text", &self.text());
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        ContentData::CodeData => {
          if let Some(x) = self.data_as_code_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::HashtagData => {
          if let Some(x) = self.data_as_hashtag_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::CashuData => {
          if let Some(x) = self.data_as_cashu_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::ImageData => {
          if let Some(x) = self.data_as_image_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::VideoData => {
          if let Some(x) = self.data_as_video_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::MediaGroupData => {
          if let Some(x) = self.data_as_media_group_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::NostrData => {
          if let Some(x) = self.data_as_nostr_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::LinkPreviewData => {
          if let Some(x) = self.data_as_link_preview_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContentBlockT {
  pub type_: String,
  pub text: String,
  pub data: ContentDataT,
}
impl Default for ContentBlockT {
  fn default() -> Self {
    Self {
      type_: "".to_string(),
      text: "".to_string(),
      data: ContentDataT::NONE,
    }
  }
}
impl ContentBlockT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContentBlock<'b>> {
    let type_ = Some({
      let x = &self.type_;
      _fbb.create_string(x)
    });
    let text = Some({
      let x = &self.text;
      _fbb.create_string(x)
    });
    let data_type = self.data.content_data_type();
    let data = self.data.pack(_fbb);
    ContentBlock::create(_fbb, &ContentBlockArgs{
      type_,
      text,
      data_type,
      data,
    })
  }
}
pub enum StringVecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringVec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringVec<'a> {
  type Inner = StringVec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringVec<'a> {
  pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringVec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringVecArgs<'args>
  ) -> flatbuffers::WIPOffset<StringVec<'bldr>> {
    let mut builder = StringVecBuilder::new(_fbb);
    if let Some(x) = args.items { builder.add_items(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> StringVecT {
    let items = self.items().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    StringVecT {
      items,
    }
  }

  #[inline]
  pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StringVec::VT_ITEMS, None)}
  }
}

impl flatbuffers::Verifiable for StringVec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("items", Self::VT_ITEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct StringVecArgs<'a> {
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for StringVecArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringVecArgs {
      items: None,
    }
  }
}

pub struct StringVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringVecBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_items(&mut self, items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringVec::VT_ITEMS, items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringVecBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringVecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringVec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringVec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringVec");
      ds.field("items", &self.items());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StringVecT {
  pub items: Option<Vec<String>>,
}
impl Default for StringVecT {
  fn default() -> Self {
    Self {
      items: None,
    }
  }
}
impl StringVecT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StringVec<'b>> {
    let items = self.items.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    StringVec::create(_fbb, &StringVecArgs{
      items,
    })
  }
}
pub enum ProfilePointerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProfilePointer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProfilePointer<'a> {
  type Inner = ProfilePointer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProfilePointer<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProfilePointer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProfilePointerArgs<'args>
  ) -> flatbuffers::WIPOffset<ProfilePointer<'bldr>> {
    let mut builder = ProfilePointerBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ProfilePointerT {
    let public_key = {
      let x = self.public_key();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    ProfilePointerT {
      public_key,
      relays,
    }
  }

  #[inline]
  pub fn public_key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProfilePointer::VT_PUBLIC_KEY, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ProfilePointer::VT_RELAYS, None)}
  }
}

impl flatbuffers::Verifiable for ProfilePointer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("public_key", Self::VT_PUBLIC_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct ProfilePointerArgs<'a> {
    pub public_key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ProfilePointerArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProfilePointerArgs {
      public_key: None, // required field
      relays: None,
    }
  }
}

pub struct ProfilePointerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProfilePointerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilePointer::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilePointer::VT_RELAYS, relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProfilePointerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProfilePointerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProfilePointer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ProfilePointer::VT_PUBLIC_KEY,"public_key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProfilePointer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProfilePointer");
      ds.field("public_key", &self.public_key());
      ds.field("relays", &self.relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ProfilePointerT {
  pub public_key: String,
  pub relays: Option<Vec<String>>,
}
impl Default for ProfilePointerT {
  fn default() -> Self {
    Self {
      public_key: "".to_string(),
      relays: None,
    }
  }
}
impl ProfilePointerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ProfilePointer<'b>> {
    let public_key = Some({
      let x = &self.public_key;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    ProfilePointer::create(_fbb, &ProfilePointerArgs{
      public_key,
      relays,
    })
  }
}
pub enum EventPointerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EventPointer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventPointer<'a> {
  type Inner = EventPointer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EventPointer<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 6;
  pub const VT_AUTHOR: flatbuffers::VOffsetT = 8;
  pub const VT_KIND: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EventPointer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EventPointerArgs<'args>
  ) -> flatbuffers::WIPOffset<EventPointer<'bldr>> {
    let mut builder = EventPointerBuilder::new(_fbb);
    builder.add_kind(args.kind);
    if let Some(x) = args.author { builder.add_author(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EventPointerT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let author = self.author().map(|x| {
      x.to_string()
    });
    let kind = self.kind();
    EventPointerT {
      id,
      relays,
      author,
      kind,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventPointer::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EventPointer::VT_RELAYS, None)}
  }
  #[inline]
  pub fn author(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventPointer::VT_AUTHOR, None)}
  }
  #[inline]
  pub fn kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(EventPointer::VT_KIND, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EventPointer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("author", Self::VT_AUTHOR, false)?
     .visit_field::<u64>("kind", Self::VT_KIND, false)?
     .finish();
    Ok(())
  }
}
pub struct EventPointerArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub author: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u64,
}
impl<'a> Default for EventPointerArgs<'a> {
  #[inline]
  fn default() -> Self {
    EventPointerArgs {
      id: None, // required field
      relays: None,
      author: None,
      kind: 0,
    }
  }
}

pub struct EventPointerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventPointerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventPointer::VT_ID, id);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventPointer::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_author(&mut self, author: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventPointer::VT_AUTHOR, author);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u64) {
    self.fbb_.push_slot::<u64>(EventPointer::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EventPointerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EventPointerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventPointer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EventPointer::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EventPointer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EventPointer");
      ds.field("id", &self.id());
      ds.field("relays", &self.relays());
      ds.field("author", &self.author());
      ds.field("kind", &self.kind());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EventPointerT {
  pub id: String,
  pub relays: Option<Vec<String>>,
  pub author: Option<String>,
  pub kind: u64,
}
impl Default for EventPointerT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      relays: None,
      author: None,
      kind: 0,
    }
  }
}
impl EventPointerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EventPointer<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let author = self.author.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let kind = self.kind;
    EventPointer::create(_fbb, &EventPointerArgs{
      id,
      relays,
      author,
      kind,
    })
  }
}
pub enum RelayInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelayInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayInfo<'a> {
  type Inner = RelayInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelayInfo<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_READ: flatbuffers::VOffsetT = 6;
  pub const VT_WRITE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelayInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RelayInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<RelayInfo<'bldr>> {
    let mut builder = RelayInfoBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    builder.add_write(args.write);
    builder.add_read(args.read);
    builder.finish()
  }

  pub fn unpack(&self) -> RelayInfoT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let read = self.read();
    let write = self.write();
    RelayInfoT {
      url,
      read,
      write,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RelayInfo::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn read(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RelayInfo::VT_READ, Some(false)).unwrap()}
  }
  #[inline]
  pub fn write(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RelayInfo::VT_WRITE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RelayInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<bool>("read", Self::VT_READ, false)?
     .visit_field::<bool>("write", Self::VT_WRITE, false)?
     .finish();
    Ok(())
  }
}
pub struct RelayInfoArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub read: bool,
    pub write: bool,
}
impl<'a> Default for RelayInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelayInfoArgs {
      url: None, // required field
      read: false,
      write: false,
    }
  }
}

pub struct RelayInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RelayInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayInfo::VT_URL, url);
  }
  #[inline]
  pub fn add_read(&mut self, read: bool) {
    self.fbb_.push_slot::<bool>(RelayInfo::VT_READ, read, false);
  }
  #[inline]
  pub fn add_write(&mut self, write: bool) {
    self.fbb_.push_slot::<bool>(RelayInfo::VT_WRITE, write, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RelayInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RelayInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RelayInfo::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelayInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelayInfo");
      ds.field("url", &self.url());
      ds.field("read", &self.read());
      ds.field("write", &self.write());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RelayInfoT {
  pub url: String,
  pub read: bool,
  pub write: bool,
}
impl Default for RelayInfoT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      read: false,
      write: false,
    }
  }
}
impl RelayInfoT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RelayInfo<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let read = self.read;
    let write = self.write;
    RelayInfo::create(_fbb, &RelayInfoArgs{
      url,
      read,
      write,
    })
  }
}
pub enum MintInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MintInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MintInfo<'a> {
  type Inner = MintInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MintInfo<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_BASE_UNITS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MintInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MintInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<MintInfo<'bldr>> {
    let mut builder = MintInfoBuilder::new(_fbb);
    if let Some(x) = args.base_units { builder.add_base_units(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MintInfoT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let base_units = {
      let x = self.base_units();
      x.iter().map(|s| s.to_string()).collect()
    };
    MintInfoT {
      url,
      base_units,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MintInfo::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn base_units(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MintInfo::VT_BASE_UNITS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for MintInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("base_units", Self::VT_BASE_UNITS, true)?
     .finish();
    Ok(())
  }
}
pub struct MintInfoArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub base_units: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MintInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    MintInfoArgs {
      url: None, // required field
      base_units: None, // required field
    }
  }
}

pub struct MintInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MintInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintInfo::VT_URL, url);
  }
  #[inline]
  pub fn add_base_units(&mut self, base_units: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintInfo::VT_BASE_UNITS, base_units);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MintInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MintInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MintInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, MintInfo::VT_URL,"url");
    self.fbb_.required(o, MintInfo::VT_BASE_UNITS,"base_units");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MintInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MintInfo");
      ds.field("url", &self.url());
      ds.field("base_units", &self.base_units());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MintInfoT {
  pub url: String,
  pub base_units: Vec<String>,
}
impl Default for MintInfoT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      base_units: Default::default(),
    }
  }
}
impl MintInfoT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MintInfo<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let base_units = Some({
      let x = &self.base_units;
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    MintInfo::create(_fbb, &MintInfoArgs{
      url,
      base_units,
    })
  }
}
pub enum EmojiOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Emoji<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Emoji<'a> {
  type Inner = Emoji<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Emoji<'a> {
  pub const VT_SHORTCODE: flatbuffers::VOffsetT = 4;
  pub const VT_URL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Emoji { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EmojiArgs<'args>
  ) -> flatbuffers::WIPOffset<Emoji<'bldr>> {
    let mut builder = EmojiBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.shortcode { builder.add_shortcode(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EmojiT {
    let shortcode = {
      let x = self.shortcode();
      x.to_string()
    };
    let url = {
      let x = self.url();
      x.to_string()
    };
    EmojiT {
      shortcode,
      url,
    }
  }

  #[inline]
  pub fn shortcode(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Emoji::VT_SHORTCODE, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Emoji::VT_URL, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Emoji<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shortcode", Self::VT_SHORTCODE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .finish();
    Ok(())
  }
}
pub struct EmojiArgs<'a> {
    pub shortcode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EmojiArgs<'a> {
  #[inline]
  fn default() -> Self {
    EmojiArgs {
      shortcode: None, // required field
      url: None, // required field
    }
  }
}

pub struct EmojiBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EmojiBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shortcode(&mut self, shortcode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Emoji::VT_SHORTCODE, shortcode);
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Emoji::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EmojiBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EmojiBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Emoji<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Emoji::VT_SHORTCODE,"shortcode");
    self.fbb_.required(o, Emoji::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Emoji<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Emoji");
      ds.field("shortcode", &self.shortcode());
      ds.field("url", &self.url());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EmojiT {
  pub shortcode: String,
  pub url: String,
}
impl Default for EmojiT {
  fn default() -> Self {
    Self {
      shortcode: "".to_string(),
      url: "".to_string(),
    }
  }
}
impl EmojiT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Emoji<'b>> {
    let shortcode = Some({
      let x = &self.shortcode;
      _fbb.create_string(x)
    });
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    Emoji::create(_fbb, &EmojiArgs{
      shortcode,
      url,
    })
  }
}
pub enum ContactOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Contact<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Contact<'a> {
  type Inner = Contact<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Contact<'a> {
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 6;
  pub const VT_PETNAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Contact { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContactArgs<'args>
  ) -> flatbuffers::WIPOffset<Contact<'bldr>> {
    let mut builder = ContactBuilder::new(_fbb);
    if let Some(x) = args.petname { builder.add_petname(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContactT {
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let petname = self.petname().map(|x| {
      x.to_string()
    });
    ContactT {
      pubkey,
      relays,
      petname,
    }
  }

  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Contact::VT_RELAYS, None)}
  }
  #[inline]
  pub fn petname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_PETNAME, None)}
  }
}

impl flatbuffers::Verifiable for Contact<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("petname", Self::VT_PETNAME, false)?
     .finish();
    Ok(())
  }
}
pub struct ContactArgs<'a> {
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub petname: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ContactArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContactArgs {
      pubkey: None, // required field
      relays: None,
      petname: None,
    }
  }
}

pub struct ContactBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContactBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_petname(&mut self, petname: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_PETNAME, petname);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContactBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContactBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Contact<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Contact::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Contact<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Contact");
      ds.field("pubkey", &self.pubkey());
      ds.field("relays", &self.relays());
      ds.field("petname", &self.petname());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContactT {
  pub pubkey: String,
  pub relays: Option<Vec<String>>,
  pub petname: Option<String>,
}
impl Default for ContactT {
  fn default() -> Self {
    Self {
      pubkey: "".to_string(),
      relays: None,
      petname: None,
    }
  }
}
impl ContactT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Contact<'b>> {
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let petname = self.petname.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Contact::create(_fbb, &ContactArgs{
      pubkey,
      relays,
      petname,
    })
  }
}
pub enum DLEQProofOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DLEQProof<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DLEQProof<'a> {
  type Inner = DLEQProof<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DLEQProof<'a> {
  pub const VT_E: flatbuffers::VOffsetT = 4;
  pub const VT_S: flatbuffers::VOffsetT = 6;
  pub const VT_R: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DLEQProof { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DLEQProofArgs<'args>
  ) -> flatbuffers::WIPOffset<DLEQProof<'bldr>> {
    let mut builder = DLEQProofBuilder::new(_fbb);
    if let Some(x) = args.r { builder.add_r(x); }
    if let Some(x) = args.s { builder.add_s(x); }
    if let Some(x) = args.e { builder.add_e(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> DLEQProofT {
    let e = {
      let x = self.e();
      x.to_string()
    };
    let s = {
      let x = self.s();
      x.to_string()
    };
    let r = {
      let x = self.r();
      x.to_string()
    };
    DLEQProofT {
      e,
      s,
      r,
    }
  }

  #[inline]
  pub fn e(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DLEQProof::VT_E, None).unwrap()}
  }
  #[inline]
  pub fn s(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DLEQProof::VT_S, None).unwrap()}
  }
  #[inline]
  pub fn r(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DLEQProof::VT_R, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for DLEQProof<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("e", Self::VT_E, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("s", Self::VT_S, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("r", Self::VT_R, true)?
     .finish();
    Ok(())
  }
}
pub struct DLEQProofArgs<'a> {
    pub e: Option<flatbuffers::WIPOffset<&'a str>>,
    pub s: Option<flatbuffers::WIPOffset<&'a str>>,
    pub r: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DLEQProofArgs<'a> {
  #[inline]
  fn default() -> Self {
    DLEQProofArgs {
      e: None, // required field
      s: None, // required field
      r: None, // required field
    }
  }
}

pub struct DLEQProofBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DLEQProofBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_e(&mut self, e: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DLEQProof::VT_E, e);
  }
  #[inline]
  pub fn add_s(&mut self, s: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DLEQProof::VT_S, s);
  }
  #[inline]
  pub fn add_r(&mut self, r: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DLEQProof::VT_R, r);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DLEQProofBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DLEQProofBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DLEQProof<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DLEQProof::VT_E,"e");
    self.fbb_.required(o, DLEQProof::VT_S,"s");
    self.fbb_.required(o, DLEQProof::VT_R,"r");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DLEQProof<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DLEQProof");
      ds.field("e", &self.e());
      ds.field("s", &self.s());
      ds.field("r", &self.r());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DLEQProofT {
  pub e: String,
  pub s: String,
  pub r: String,
}
impl Default for DLEQProofT {
  fn default() -> Self {
    Self {
      e: "".to_string(),
      s: "".to_string(),
      r: "".to_string(),
    }
  }
}
impl DLEQProofT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DLEQProof<'b>> {
    let e = Some({
      let x = &self.e;
      _fbb.create_string(x)
    });
    let s = Some({
      let x = &self.s;
      _fbb.create_string(x)
    });
    let r = Some({
      let x = &self.r;
      _fbb.create_string(x)
    });
    DLEQProof::create(_fbb, &DLEQProofArgs{
      e,
      s,
      r,
    })
  }
}
pub enum P2PKWitnessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct P2PKWitness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for P2PKWitness<'a> {
  type Inner = P2PKWitness<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> P2PKWitness<'a> {
  pub const VT_SIGNATURES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    P2PKWitness { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args P2PKWitnessArgs<'args>
  ) -> flatbuffers::WIPOffset<P2PKWitness<'bldr>> {
    let mut builder = P2PKWitnessBuilder::new(_fbb);
    if let Some(x) = args.signatures { builder.add_signatures(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> P2PKWitnessT {
    let signatures = self.signatures().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    P2PKWitnessT {
      signatures,
    }
  }

  #[inline]
  pub fn signatures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(P2PKWitness::VT_SIGNATURES, None)}
  }
}

impl flatbuffers::Verifiable for P2PKWitness<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("signatures", Self::VT_SIGNATURES, false)?
     .finish();
    Ok(())
  }
}
pub struct P2PKWitnessArgs<'a> {
    pub signatures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for P2PKWitnessArgs<'a> {
  #[inline]
  fn default() -> Self {
    P2PKWitnessArgs {
      signatures: None,
    }
  }
}

pub struct P2PKWitnessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> P2PKWitnessBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_signatures(&mut self, signatures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(P2PKWitness::VT_SIGNATURES, signatures);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> P2PKWitnessBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    P2PKWitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<P2PKWitness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for P2PKWitness<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("P2PKWitness");
      ds.field("signatures", &self.signatures());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct P2PKWitnessT {
  pub signatures: Option<Vec<String>>,
}
impl Default for P2PKWitnessT {
  fn default() -> Self {
    Self {
      signatures: None,
    }
  }
}
impl P2PKWitnessT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<P2PKWitness<'b>> {
    let signatures = self.signatures.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    P2PKWitness::create(_fbb, &P2PKWitnessArgs{
      signatures,
    })
  }
}
pub enum HTLCWitnessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HTLCWitness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HTLCWitness<'a> {
  type Inner = HTLCWitness<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HTLCWitness<'a> {
  pub const VT_PREIMAGE: flatbuffers::VOffsetT = 4;
  pub const VT_SIGNATURES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HTLCWitness { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HTLCWitnessArgs<'args>
  ) -> flatbuffers::WIPOffset<HTLCWitness<'bldr>> {
    let mut builder = HTLCWitnessBuilder::new(_fbb);
    if let Some(x) = args.signatures { builder.add_signatures(x); }
    if let Some(x) = args.preimage { builder.add_preimage(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> HTLCWitnessT {
    let preimage = {
      let x = self.preimage();
      x.to_string()
    };
    let signatures = self.signatures().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    HTLCWitnessT {
      preimage,
      signatures,
    }
  }

  #[inline]
  pub fn preimage(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HTLCWitness::VT_PREIMAGE, None).unwrap()}
  }
  #[inline]
  pub fn signatures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(HTLCWitness::VT_SIGNATURES, None)}
  }
}

impl flatbuffers::Verifiable for HTLCWitness<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preimage", Self::VT_PREIMAGE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("signatures", Self::VT_SIGNATURES, false)?
     .finish();
    Ok(())
  }
}
pub struct HTLCWitnessArgs<'a> {
    pub preimage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub signatures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for HTLCWitnessArgs<'a> {
  #[inline]
  fn default() -> Self {
    HTLCWitnessArgs {
      preimage: None, // required field
      signatures: None,
    }
  }
}

pub struct HTLCWitnessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HTLCWitnessBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preimage(&mut self, preimage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HTLCWitness::VT_PREIMAGE, preimage);
  }
  #[inline]
  pub fn add_signatures(&mut self, signatures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HTLCWitness::VT_SIGNATURES, signatures);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HTLCWitnessBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HTLCWitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HTLCWitness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, HTLCWitness::VT_PREIMAGE,"preimage");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HTLCWitness<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HTLCWitness");
      ds.field("preimage", &self.preimage());
      ds.field("signatures", &self.signatures());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HTLCWitnessT {
  pub preimage: String,
  pub signatures: Option<Vec<String>>,
}
impl Default for HTLCWitnessT {
  fn default() -> Self {
    Self {
      preimage: "".to_string(),
      signatures: None,
    }
  }
}
impl HTLCWitnessT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<HTLCWitness<'b>> {
    let preimage = Some({
      let x = &self.preimage;
      _fbb.create_string(x)
    });
    let signatures = self.signatures.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    HTLCWitness::create(_fbb, &HTLCWitnessArgs{
      preimage,
      signatures,
    })
  }
}
pub enum WitnessStringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WitnessString<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WitnessString<'a> {
  type Inner = WitnessString<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WitnessString<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WitnessString { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WitnessStringArgs<'args>
  ) -> flatbuffers::WIPOffset<WitnessString<'bldr>> {
    let mut builder = WitnessStringBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> WitnessStringT {
    let value = self.value().map(|x| {
      x.to_string()
    });
    WitnessStringT {
      value,
    }
  }

  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WitnessString::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for WitnessString<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct WitnessStringArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WitnessStringArgs<'a> {
  #[inline]
  fn default() -> Self {
    WitnessStringArgs {
      value: None,
    }
  }
}

pub struct WitnessStringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WitnessStringBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WitnessString::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WitnessStringBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WitnessStringBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WitnessString<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WitnessString<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WitnessString");
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WitnessStringT {
  pub value: Option<String>,
}
impl Default for WitnessStringT {
  fn default() -> Self {
    Self {
      value: None,
    }
  }
}
impl WitnessStringT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WitnessString<'b>> {
    let value = self.value.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    WitnessString::create(_fbb, &WitnessStringArgs{
      value,
    })
  }
}
pub enum ProofOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Proof<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Proof<'a> {
  type Inner = Proof<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Proof<'a> {
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SECRET: flatbuffers::VOffsetT = 8;
  pub const VT_C: flatbuffers::VOffsetT = 10;
  pub const VT_DLEQ: flatbuffers::VOffsetT = 12;
  pub const VT_WITNESS_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_WITNESS: flatbuffers::VOffsetT = 16;
  pub const VT_VERSION: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Proof { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProofArgs<'args>
  ) -> flatbuffers::WIPOffset<Proof<'bldr>> {
    let mut builder = ProofBuilder::new(_fbb);
    builder.add_amount(args.amount);
    if let Some(x) = args.witness { builder.add_witness(x); }
    if let Some(x) = args.dleq { builder.add_dleq(x); }
    if let Some(x) = args.c { builder.add_c(x); }
    if let Some(x) = args.secret { builder.add_secret(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_version(args.version);
    builder.add_witness_type(args.witness_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ProofT {
    let amount = self.amount();
    let id = {
      let x = self.id();
      x.to_string()
    };
    let secret = {
      let x = self.secret();
      x.to_string()
    };
    let c = {
      let x = self.c();
      x.to_string()
    };
    let dleq = self.dleq().map(|x| {
      Box::new(x.unpack())
    });
    let witness = match self.witness_type() {
      Witness::NONE => WitnessT::NONE,
      Witness::WitnessString => WitnessT::WitnessString(Box::new(
        self.witness_as_witness_string()
            .expect("Invalid union table, expected `Witness::WitnessString`.")
            .unpack()
      )),
      Witness::P2PKWitness => WitnessT::P2PKWitness(Box::new(
        self.witness_as_p2_pkwitness()
            .expect("Invalid union table, expected `Witness::P2PKWitness`.")
            .unpack()
      )),
      Witness::HTLCWitness => WitnessT::HTLCWitness(Box::new(
        self.witness_as_htlcwitness()
            .expect("Invalid union table, expected `Witness::HTLCWitness`.")
            .unpack()
      )),
      _ => WitnessT::NONE,
    };
    let version = self.version();
    ProofT {
      amount,
      id,
      secret,
      c,
      dleq,
      witness,
      version,
    }
  }

  #[inline]
  pub fn amount(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Proof::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Proof::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn secret(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Proof::VT_SECRET, None).unwrap()}
  }
  #[inline]
  pub fn c(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Proof::VT_C, None).unwrap()}
  }
  #[inline]
  pub fn dleq(&self) -> Option<DLEQProof<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DLEQProof>>(Proof::VT_DLEQ, None)}
  }
  #[inline]
  pub fn witness_type(&self) -> Witness {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Witness>(Proof::VT_WITNESS_TYPE, Some(Witness::NONE)).unwrap()}
  }
  #[inline]
  pub fn witness(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Proof::VT_WITNESS, None)}
  }
  #[inline]
  pub fn version(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Proof::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn witness_as_witness_string(&self) -> Option<WitnessString<'a>> {
    if self.witness_type() == Witness::WitnessString {
      self.witness().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { WitnessString::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn witness_as_p2_pkwitness(&self) -> Option<P2PKWitness<'a>> {
    if self.witness_type() == Witness::P2PKWitness {
      self.witness().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { P2PKWitness::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn witness_as_htlcwitness(&self) -> Option<HTLCWitness<'a>> {
    if self.witness_type() == Witness::HTLCWitness {
      self.witness().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HTLCWitness::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Proof<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("secret", Self::VT_SECRET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c", Self::VT_C, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DLEQProof>>("dleq", Self::VT_DLEQ, false)?
     .visit_union::<Witness, _>("witness_type", Self::VT_WITNESS_TYPE, "witness", Self::VT_WITNESS, false, |key, v, pos| {
        match key {
          Witness::WitnessString => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WitnessString>>("Witness::WitnessString", pos),
          Witness::P2PKWitness => v.verify_union_variant::<flatbuffers::ForwardsUOffset<P2PKWitness>>("Witness::P2PKWitness", pos),
          Witness::HTLCWitness => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HTLCWitness>>("Witness::HTLCWitness", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<u8>("version", Self::VT_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct ProofArgs<'a> {
    pub amount: u64,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub secret: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dleq: Option<flatbuffers::WIPOffset<DLEQProof<'a>>>,
    pub witness_type: Witness,
    pub witness: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub version: u8,
}
impl<'a> Default for ProofArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProofArgs {
      amount: 0,
      id: None, // required field
      secret: None, // required field
      c: None, // required field
      dleq: None,
      witness_type: Witness::NONE,
      witness: None,
      version: 0,
    }
  }
}

pub struct ProofBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProofBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_amount(&mut self, amount: u64) {
    self.fbb_.push_slot::<u64>(Proof::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_ID, id);
  }
  #[inline]
  pub fn add_secret(&mut self, secret: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_SECRET, secret);
  }
  #[inline]
  pub fn add_c(&mut self, c: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_C, c);
  }
  #[inline]
  pub fn add_dleq(&mut self, dleq: flatbuffers::WIPOffset<DLEQProof<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DLEQProof>>(Proof::VT_DLEQ, dleq);
  }
  #[inline]
  pub fn add_witness_type(&mut self, witness_type: Witness) {
    self.fbb_.push_slot::<Witness>(Proof::VT_WITNESS_TYPE, witness_type, Witness::NONE);
  }
  #[inline]
  pub fn add_witness(&mut self, witness: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_WITNESS, witness);
  }
  #[inline]
  pub fn add_version(&mut self, version: u8) {
    self.fbb_.push_slot::<u8>(Proof::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProofBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProofBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Proof<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Proof::VT_ID,"id");
    self.fbb_.required(o, Proof::VT_SECRET,"secret");
    self.fbb_.required(o, Proof::VT_C,"c");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Proof<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Proof");
      ds.field("amount", &self.amount());
      ds.field("id", &self.id());
      ds.field("secret", &self.secret());
      ds.field("c", &self.c());
      ds.field("dleq", &self.dleq());
      ds.field("witness_type", &self.witness_type());
      match self.witness_type() {
        Witness::WitnessString => {
          if let Some(x) = self.witness_as_witness_string() {
            ds.field("witness", &x)
          } else {
            ds.field("witness", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Witness::P2PKWitness => {
          if let Some(x) = self.witness_as_p2_pkwitness() {
            ds.field("witness", &x)
          } else {
            ds.field("witness", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Witness::HTLCWitness => {
          if let Some(x) = self.witness_as_htlcwitness() {
            ds.field("witness", &x)
          } else {
            ds.field("witness", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("witness", &x)
        },
      };
      ds.field("version", &self.version());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ProofT {
  pub amount: u64,
  pub id: String,
  pub secret: String,
  pub c: String,
  pub dleq: Option<Box<DLEQProofT>>,
  pub witness: WitnessT,
  pub version: u8,
}
impl Default for ProofT {
  fn default() -> Self {
    Self {
      amount: 0,
      id: "".to_string(),
      secret: "".to_string(),
      c: "".to_string(),
      dleq: None,
      witness: WitnessT::NONE,
      version: 0,
    }
  }
}
impl ProofT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Proof<'b>> {
    let amount = self.amount;
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let secret = Some({
      let x = &self.secret;
      _fbb.create_string(x)
    });
    let c = Some({
      let x = &self.c;
      _fbb.create_string(x)
    });
    let dleq = self.dleq.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let witness_type = self.witness.witness_type();
    let witness = self.witness.pack(_fbb);
    let version = self.version;
    Proof::create(_fbb, &ProofArgs{
      amount,
      id,
      secret,
      c,
      dleq,
      witness_type,
      witness,
      version,
    })
  }
}
pub enum HistoryTagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HistoryTag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HistoryTag<'a> {
  type Inner = HistoryTag<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HistoryTag<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_RELAY: flatbuffers::VOffsetT = 8;
  pub const VT_MARKER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HistoryTag { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HistoryTagArgs<'args>
  ) -> flatbuffers::WIPOffset<HistoryTag<'bldr>> {
    let mut builder = HistoryTagBuilder::new(_fbb);
    if let Some(x) = args.marker { builder.add_marker(x); }
    if let Some(x) = args.relay { builder.add_relay(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> HistoryTagT {
    let name = {
      let x = self.name();
      x.to_string()
    };
    let value = {
      let x = self.value();
      x.to_string()
    };
    let relay = self.relay().map(|x| {
      x.to_string()
    });
    let marker = self.marker().map(|x| {
      x.to_string()
    });
    HistoryTagT {
      name,
      value,
      relay,
      marker,
    }
  }

  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_VALUE, None).unwrap()}
  }
  #[inline]
  pub fn relay(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_RELAY, None)}
  }
  #[inline]
  pub fn marker(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_MARKER, None)}
  }
}

impl flatbuffers::Verifiable for HistoryTag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relay", Self::VT_RELAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("marker", Self::VT_MARKER, false)?
     .finish();
    Ok(())
  }
}
pub struct HistoryTagArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relay: Option<flatbuffers::WIPOffset<&'a str>>,
    pub marker: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HistoryTagArgs<'a> {
  #[inline]
  fn default() -> Self {
    HistoryTagArgs {
      name: None, // required field
      value: None, // required field
      relay: None,
      marker: None,
    }
  }
}

pub struct HistoryTagBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HistoryTagBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_VALUE, value);
  }
  #[inline]
  pub fn add_relay(&mut self, relay: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_RELAY, relay);
  }
  #[inline]
  pub fn add_marker(&mut self, marker: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_MARKER, marker);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HistoryTagBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HistoryTagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HistoryTag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, HistoryTag::VT_NAME,"name");
    self.fbb_.required(o, HistoryTag::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HistoryTag<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HistoryTag");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.field("relay", &self.relay());
      ds.field("marker", &self.marker());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HistoryTagT {
  pub name: String,
  pub value: String,
  pub relay: Option<String>,
  pub marker: Option<String>,
}
impl Default for HistoryTagT {
  fn default() -> Self {
    Self {
      name: "".to_string(),
      value: "".to_string(),
      relay: None,
      marker: None,
    }
  }
}
impl HistoryTagT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<HistoryTag<'b>> {
    let name = Some({
      let x = &self.name;
      _fbb.create_string(x)
    });
    let value = Some({
      let x = &self.value;
      _fbb.create_string(x)
    });
    let relay = self.relay.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let marker = self.marker.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    HistoryTag::create(_fbb, &HistoryTagArgs{
      name,
      value,
      relay,
      marker,
    })
  }
}
pub enum ZapRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZapRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZapRequest<'a> {
  type Inner = ZapRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZapRequest<'a> {
  pub const VT_KIND: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;
  pub const VT_TAGS: flatbuffers::VOffsetT = 10;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZapRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ZapRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<ZapRequest<'bldr>> {
    let mut builder = ZapRequestBuilder::new(_fbb);
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.add_kind(args.kind);
    builder.finish()
  }

  pub fn unpack(&self) -> ZapRequestT {
    let kind = self.kind();
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let content = {
      let x = self.content();
      x.to_string()
    };
    let tags = {
      let x = self.tags();
      x.iter().map(|t| t.unpack()).collect()
    };
    let signature = self.signature().map(|x| {
      x.to_string()
    });
    ZapRequestT {
      kind,
      pubkey,
      content,
      tags,
      signature,
    }
  }

  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ZapRequest::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZapRequest::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZapRequest::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn tags(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(ZapRequest::VT_TAGS, None).unwrap()}
  }
  #[inline]
  pub fn signature(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZapRequest::VT_SIGNATURE, None)}
  }
}

impl flatbuffers::Verifiable for ZapRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("signature", Self::VT_SIGNATURE, false)?
     .finish();
    Ok(())
  }
}
pub struct ZapRequestArgs<'a> {
    pub kind: u16,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
    pub signature: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ZapRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZapRequestArgs {
      kind: 0,
      pubkey: None, // required field
      content: None, // required field
      tags: None, // required field
      signature: None,
    }
  }
}

pub struct ZapRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZapRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(ZapRequest::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ZapRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ZapRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZapRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ZapRequest::VT_PUBKEY,"pubkey");
    self.fbb_.required(o, ZapRequest::VT_CONTENT,"content");
    self.fbb_.required(o, ZapRequest::VT_TAGS,"tags");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZapRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZapRequest");
      ds.field("kind", &self.kind());
      ds.field("pubkey", &self.pubkey());
      ds.field("content", &self.content());
      ds.field("tags", &self.tags());
      ds.field("signature", &self.signature());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ZapRequestT {
  pub kind: u16,
  pub pubkey: String,
  pub content: String,
  pub tags: Vec<StringVecT>,
  pub signature: Option<String>,
}
impl Default for ZapRequestT {
  fn default() -> Self {
    Self {
      kind: 0,
      pubkey: "".to_string(),
      content: "".to_string(),
      tags: Default::default(),
      signature: None,
    }
  }
}
impl ZapRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ZapRequest<'b>> {
    let kind = self.kind;
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let content = Some({
      let x = &self.content;
      _fbb.create_string(x)
    });
    let tags = Some({
      let x = &self.tags;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let signature = self.signature.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ZapRequest::create(_fbb, &ZapRequestArgs{
      kind,
      pubkey,
      content,
      tags,
      signature,
    })
  }
}
pub enum RequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Request<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Request<'a> {
  type Inner = Request<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Request<'a> {
  pub const VT_IDS: flatbuffers::VOffsetT = 4;
  pub const VT_AUTHORS: flatbuffers::VOffsetT = 6;
  pub const VT_KINDS: flatbuffers::VOffsetT = 8;
  pub const VT_TAGS: flatbuffers::VOffsetT = 10;
  pub const VT_LIMIT: flatbuffers::VOffsetT = 12;
  pub const VT_SINCE: flatbuffers::VOffsetT = 14;
  pub const VT_UNTIL: flatbuffers::VOffsetT = 16;
  pub const VT_SEARCH: flatbuffers::VOffsetT = 18;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 20;
  pub const VT_CLOSE_ON_EOSE: flatbuffers::VOffsetT = 22;
  pub const VT_CACHE_FIRST: flatbuffers::VOffsetT = 24;
  pub const VT_NO_CACHE: flatbuffers::VOffsetT = 26;
  pub const VT_MAX_RELAYS: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Request { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestArgs<'args>
  ) -> flatbuffers::WIPOffset<Request<'bldr>> {
    let mut builder = RequestBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.search { builder.add_search(x); }
    builder.add_until(args.until);
    builder.add_since(args.since);
    builder.add_limit(args.limit);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.kinds { builder.add_kinds(x); }
    if let Some(x) = args.authors { builder.add_authors(x); }
    if let Some(x) = args.ids { builder.add_ids(x); }
    builder.add_max_relays(args.max_relays);
    builder.add_no_cache(args.no_cache);
    builder.add_cache_first(args.cache_first);
    builder.add_close_on_eose(args.close_on_eose);
    builder.finish()
  }

  pub fn unpack(&self) -> RequestT {
    let ids = self.ids().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let authors = self.authors().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let kinds = self.kinds().map(|x| {
      x.into_iter().collect()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let limit = self.limit();
    let since = self.since();
    let until = self.until();
    let search = self.search().map(|x| {
      x.to_string()
    });
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let close_on_eose = self.close_on_eose();
    let cache_first = self.cache_first();
    let no_cache = self.no_cache();
    let max_relays = self.max_relays();
    RequestT {
      ids,
      authors,
      kinds,
      tags,
      limit,
      since,
      until,
      search,
      relays,
      close_on_eose,
      cache_first,
      no_cache,
      max_relays,
    }
  }

  #[inline]
  pub fn ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Request::VT_IDS, None)}
  }
  #[inline]
  pub fn authors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Request::VT_AUTHORS, None)}
  }
  #[inline]
  pub fn kinds(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Request::VT_KINDS, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(Request::VT_TAGS, None)}
  }
  #[inline]
  pub fn limit(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Request::VT_LIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn since(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Request::VT_SINCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn until(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Request::VT_UNTIL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn search(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Request::VT_SEARCH, None)}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Request::VT_RELAYS, None)}
  }
  #[inline]
  pub fn close_on_eose(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Request::VT_CLOSE_ON_EOSE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn cache_first(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Request::VT_CACHE_FIRST, Some(false)).unwrap()}
  }
  #[inline]
  pub fn no_cache(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Request::VT_NO_CACHE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn max_relays(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Request::VT_MAX_RELAYS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Request<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ids", Self::VT_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("authors", Self::VT_AUTHORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("kinds", Self::VT_KINDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<i32>("limit", Self::VT_LIMIT, false)?
     .visit_field::<i32>("since", Self::VT_SINCE, false)?
     .visit_field::<i32>("until", Self::VT_UNTIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("search", Self::VT_SEARCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<bool>("close_on_eose", Self::VT_CLOSE_ON_EOSE, false)?
     .visit_field::<bool>("cache_first", Self::VT_CACHE_FIRST, false)?
     .visit_field::<bool>("no_cache", Self::VT_NO_CACHE, false)?
     .visit_field::<u16>("max_relays", Self::VT_MAX_RELAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct RequestArgs<'a> {
    pub ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub authors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub kinds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
    pub limit: i32,
    pub since: i32,
    pub until: i32,
    pub search: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub close_on_eose: bool,
    pub cache_first: bool,
    pub no_cache: bool,
    pub max_relays: u16,
}
impl<'a> Default for RequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    RequestArgs {
      ids: None,
      authors: None,
      kinds: None,
      tags: None,
      limit: 0,
      since: 0,
      until: 0,
      search: None,
      relays: None,
      close_on_eose: false,
      cache_first: false,
      no_cache: false,
      max_relays: 0,
    }
  }
}

pub struct RequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ids(&mut self, ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_IDS, ids);
  }
  #[inline]
  pub fn add_authors(&mut self, authors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_AUTHORS, authors);
  }
  #[inline]
  pub fn add_kinds(&mut self, kinds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_KINDS, kinds);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_limit(&mut self, limit: i32) {
    self.fbb_.push_slot::<i32>(Request::VT_LIMIT, limit, 0);
  }
  #[inline]
  pub fn add_since(&mut self, since: i32) {
    self.fbb_.push_slot::<i32>(Request::VT_SINCE, since, 0);
  }
  #[inline]
  pub fn add_until(&mut self, until: i32) {
    self.fbb_.push_slot::<i32>(Request::VT_UNTIL, until, 0);
  }
  #[inline]
  pub fn add_search(&mut self, search: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_SEARCH, search);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_close_on_eose(&mut self, close_on_eose: bool) {
    self.fbb_.push_slot::<bool>(Request::VT_CLOSE_ON_EOSE, close_on_eose, false);
  }
  #[inline]
  pub fn add_cache_first(&mut self, cache_first: bool) {
    self.fbb_.push_slot::<bool>(Request::VT_CACHE_FIRST, cache_first, false);
  }
  #[inline]
  pub fn add_no_cache(&mut self, no_cache: bool) {
    self.fbb_.push_slot::<bool>(Request::VT_NO_CACHE, no_cache, false);
  }
  #[inline]
  pub fn add_max_relays(&mut self, max_relays: u16) {
    self.fbb_.push_slot::<u16>(Request::VT_MAX_RELAYS, max_relays, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Request<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Request<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Request");
      ds.field("ids", &self.ids());
      ds.field("authors", &self.authors());
      ds.field("kinds", &self.kinds());
      ds.field("tags", &self.tags());
      ds.field("limit", &self.limit());
      ds.field("since", &self.since());
      ds.field("until", &self.until());
      ds.field("search", &self.search());
      ds.field("relays", &self.relays());
      ds.field("close_on_eose", &self.close_on_eose());
      ds.field("cache_first", &self.cache_first());
      ds.field("no_cache", &self.no_cache());
      ds.field("max_relays", &self.max_relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RequestT {
  pub ids: Option<Vec<String>>,
  pub authors: Option<Vec<String>>,
  pub kinds: Option<Vec<u16>>,
  pub tags: Option<Vec<StringVecT>>,
  pub limit: i32,
  pub since: i32,
  pub until: i32,
  pub search: Option<String>,
  pub relays: Option<Vec<String>>,
  pub close_on_eose: bool,
  pub cache_first: bool,
  pub no_cache: bool,
  pub max_relays: u16,
}
impl Default for RequestT {
  fn default() -> Self {
    Self {
      ids: None,
      authors: None,
      kinds: None,
      tags: None,
      limit: 0,
      since: 0,
      until: 0,
      search: None,
      relays: None,
      close_on_eose: false,
      cache_first: false,
      no_cache: false,
      max_relays: 0,
    }
  }
}
impl RequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Request<'b>> {
    let ids = self.ids.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let authors = self.authors.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let kinds = self.kinds.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let limit = self.limit;
    let since = self.since;
    let until = self.until;
    let search = self.search.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let close_on_eose = self.close_on_eose;
    let cache_first = self.cache_first;
    let no_cache = self.no_cache;
    let max_relays = self.max_relays;
    Request::create(_fbb, &RequestArgs{
      ids,
      authors,
      kinds,
      tags,
      limit,
      since,
      until,
      search,
      relays,
      close_on_eose,
      cache_first,
      no_cache,
      max_relays,
    })
  }
}
pub enum NostrEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NostrEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NostrEvent<'a> {
  type Inner = NostrEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NostrEvent<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_KIND: flatbuffers::VOffsetT = 8;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 10;
  pub const VT_TAGS: flatbuffers::VOffsetT = 12;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 14;
  pub const VT_SIG: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NostrEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NostrEventArgs<'args>
  ) -> flatbuffers::WIPOffset<NostrEvent<'bldr>> {
    let mut builder = NostrEventBuilder::new(_fbb);
    if let Some(x) = args.sig { builder.add_sig(x); }
    builder.add_created_at(args.created_at);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_kind(args.kind);
    builder.finish()
  }

  pub fn unpack(&self) -> NostrEventT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let kind = self.kind();
    let content = {
      let x = self.content();
      x.to_string()
    };
    let tags = {
      let x = self.tags();
      x.iter().map(|t| t.unpack()).collect()
    };
    let created_at = self.created_at();
    let sig = {
      let x = self.sig();
      x.to_string()
    };
    NostrEventT {
      id,
      pubkey,
      kind,
      content,
      tags,
      created_at,
      sig,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(NostrEvent::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn tags(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(NostrEvent::VT_TAGS, None).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(NostrEvent::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sig(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_SIG, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for NostrEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, true)?
     .visit_field::<i32>("created_at", Self::VT_CREATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sig", Self::VT_SIG, true)?
     .finish();
    Ok(())
  }
}
pub struct NostrEventArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u16,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
    pub created_at: i32,
    pub sig: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NostrEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    NostrEventArgs {
      id: None, // required field
      pubkey: None, // required field
      kind: 0,
      content: None, // required field
      tags: None, // required field
      created_at: 0,
      sig: None, // required field
    }
  }
}

pub struct NostrEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NostrEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_ID, id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(NostrEvent::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: i32) {
    self.fbb_.push_slot::<i32>(NostrEvent::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_sig(&mut self, sig: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_SIG, sig);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NostrEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NostrEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NostrEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, NostrEvent::VT_ID,"id");
    self.fbb_.required(o, NostrEvent::VT_PUBKEY,"pubkey");
    self.fbb_.required(o, NostrEvent::VT_CONTENT,"content");
    self.fbb_.required(o, NostrEvent::VT_TAGS,"tags");
    self.fbb_.required(o, NostrEvent::VT_SIG,"sig");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NostrEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NostrEvent");
      ds.field("id", &self.id());
      ds.field("pubkey", &self.pubkey());
      ds.field("kind", &self.kind());
      ds.field("content", &self.content());
      ds.field("tags", &self.tags());
      ds.field("created_at", &self.created_at());
      ds.field("sig", &self.sig());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NostrEventT {
  pub id: String,
  pub pubkey: String,
  pub kind: u16,
  pub content: String,
  pub tags: Vec<StringVecT>,
  pub created_at: i32,
  pub sig: String,
}
impl Default for NostrEventT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      pubkey: "".to_string(),
      kind: 0,
      content: "".to_string(),
      tags: Default::default(),
      created_at: 0,
      sig: "".to_string(),
    }
  }
}
impl NostrEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<NostrEvent<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let kind = self.kind;
    let content = Some({
      let x = &self.content;
      _fbb.create_string(x)
    });
    let tags = Some({
      let x = &self.tags;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let created_at = self.created_at;
    let sig = Some({
      let x = &self.sig;
      _fbb.create_string(x)
    });
    NostrEvent::create(_fbb, &NostrEventArgs{
      id,
      pubkey,
      kind,
      content,
      tags,
      created_at,
      sig,
    })
  }
}
pub enum PrivateKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrivateKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrivateKey<'a> {
  type Inner = PrivateKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrivateKey<'a> {
  pub const VT_PRIVATE_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrivateKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrivateKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<PrivateKey<'bldr>> {
    let mut builder = PrivateKeyBuilder::new(_fbb);
    if let Some(x) = args.private_key { builder.add_private_key(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PrivateKeyT {
    let private_key = {
      let x = self.private_key();
      x.to_string()
    };
    PrivateKeyT {
      private_key,
    }
  }

  #[inline]
  pub fn private_key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PrivateKey::VT_PRIVATE_KEY, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for PrivateKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("private_key", Self::VT_PRIVATE_KEY, true)?
     .finish();
    Ok(())
  }
}
pub struct PrivateKeyArgs<'a> {
    pub private_key: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PrivateKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrivateKeyArgs {
      private_key: None, // required field
    }
  }
}

pub struct PrivateKeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrivateKeyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_private_key(&mut self, private_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrivateKey::VT_PRIVATE_KEY, private_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrivateKeyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrivateKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrivateKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PrivateKey::VT_PRIVATE_KEY,"private_key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrivateKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrivateKey");
      ds.field("private_key", &self.private_key());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PrivateKeyT {
  pub private_key: String,
}
impl Default for PrivateKeyT {
  fn default() -> Self {
    Self {
      private_key: "".to_string(),
    }
  }
}
impl PrivateKeyT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PrivateKey<'b>> {
    let private_key = Some({
      let x = &self.private_key;
      _fbb.create_string(x)
    });
    PrivateKey::create(_fbb, &PrivateKeyArgs{
      private_key,
    })
  }
}
pub enum ParsePipeConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ParsePipeConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParsePipeConfig<'a> {
  type Inner = ParsePipeConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParsePipeConfig<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParsePipeConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args ParsePipeConfigArgs
  ) -> flatbuffers::WIPOffset<ParsePipeConfig<'bldr>> {
    let mut builder = ParsePipeConfigBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> ParsePipeConfigT {
    ParsePipeConfigT {
    }
  }
}

impl flatbuffers::Verifiable for ParsePipeConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ParsePipeConfigArgs {
}
impl<'a> Default for ParsePipeConfigArgs {
  #[inline]
  fn default() -> Self {
    ParsePipeConfigArgs {
    }
  }
}

pub struct ParsePipeConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParsePipeConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParsePipeConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParsePipeConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParsePipeConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParsePipeConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParsePipeConfig");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParsePipeConfigT {
}
impl Default for ParsePipeConfigT {
  fn default() -> Self {
    Self {
    }
  }
}
impl ParsePipeConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParsePipeConfig<'b>> {
    ParsePipeConfig::create(_fbb, &ParsePipeConfigArgs{
    })
  }
}
pub enum KindFilterPipeConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KindFilterPipeConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KindFilterPipeConfig<'a> {
  type Inner = KindFilterPipeConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KindFilterPipeConfig<'a> {
  pub const VT_KINDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KindFilterPipeConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KindFilterPipeConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<KindFilterPipeConfig<'bldr>> {
    let mut builder = KindFilterPipeConfigBuilder::new(_fbb);
    if let Some(x) = args.kinds { builder.add_kinds(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KindFilterPipeConfigT {
    let kinds = {
      let x = self.kinds();
      x.into_iter().collect()
    };
    KindFilterPipeConfigT {
      kinds,
    }
  }

  #[inline]
  pub fn kinds(&self) -> flatbuffers::Vector<'a, u16> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(KindFilterPipeConfig::VT_KINDS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for KindFilterPipeConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("kinds", Self::VT_KINDS, true)?
     .finish();
    Ok(())
  }
}
pub struct KindFilterPipeConfigArgs<'a> {
    pub kinds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for KindFilterPipeConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    KindFilterPipeConfigArgs {
      kinds: None, // required field
    }
  }
}

pub struct KindFilterPipeConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KindFilterPipeConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kinds(&mut self, kinds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KindFilterPipeConfig::VT_KINDS, kinds);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KindFilterPipeConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KindFilterPipeConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KindFilterPipeConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KindFilterPipeConfig::VT_KINDS,"kinds");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KindFilterPipeConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KindFilterPipeConfig");
      ds.field("kinds", &self.kinds());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KindFilterPipeConfigT {
  pub kinds: Vec<u16>,
}
impl Default for KindFilterPipeConfigT {
  fn default() -> Self {
    Self {
      kinds: Default::default(),
    }
  }
}
impl KindFilterPipeConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KindFilterPipeConfig<'b>> {
    let kinds = Some({
      let x = &self.kinds;
      _fbb.create_vector(x)
    });
    KindFilterPipeConfig::create(_fbb, &KindFilterPipeConfigArgs{
      kinds,
    })
  }
}
pub enum CounterPipeConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CounterPipeConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CounterPipeConfig<'a> {
  type Inner = CounterPipeConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CounterPipeConfig<'a> {
  pub const VT_KINDS: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CounterPipeConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CounterPipeConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<CounterPipeConfig<'bldr>> {
    let mut builder = CounterPipeConfigBuilder::new(_fbb);
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.kinds { builder.add_kinds(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CounterPipeConfigT {
    let kinds = {
      let x = self.kinds();
      x.into_iter().collect()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    CounterPipeConfigT {
      kinds,
      pubkey,
    }
  }

  #[inline]
  pub fn kinds(&self) -> flatbuffers::Vector<'a, u16> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(CounterPipeConfig::VT_KINDS, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CounterPipeConfig::VT_PUBKEY, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for CounterPipeConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("kinds", Self::VT_KINDS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .finish();
    Ok(())
  }
}
pub struct CounterPipeConfigArgs<'a> {
    pub kinds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CounterPipeConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    CounterPipeConfigArgs {
      kinds: None, // required field
      pubkey: None, // required field
    }
  }
}

pub struct CounterPipeConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CounterPipeConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kinds(&mut self, kinds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CounterPipeConfig::VT_KINDS, kinds);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CounterPipeConfig::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CounterPipeConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CounterPipeConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CounterPipeConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CounterPipeConfig::VT_KINDS,"kinds");
    self.fbb_.required(o, CounterPipeConfig::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CounterPipeConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CounterPipeConfig");
      ds.field("kinds", &self.kinds());
      ds.field("pubkey", &self.pubkey());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CounterPipeConfigT {
  pub kinds: Vec<u16>,
  pub pubkey: String,
}
impl Default for CounterPipeConfigT {
  fn default() -> Self {
    Self {
      kinds: Default::default(),
      pubkey: "".to_string(),
    }
  }
}
impl CounterPipeConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CounterPipeConfig<'b>> {
    let kinds = Some({
      let x = &self.kinds;
      _fbb.create_vector(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    CounterPipeConfig::create(_fbb, &CounterPipeConfigArgs{
      kinds,
      pubkey,
    })
  }
}
pub enum NpubLimiterPipeConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NpubLimiterPipeConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NpubLimiterPipeConfig<'a> {
  type Inner = NpubLimiterPipeConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NpubLimiterPipeConfig<'a> {
  pub const VT_KIND: flatbuffers::VOffsetT = 4;
  pub const VT_LIMIT_PER_NPUB: flatbuffers::VOffsetT = 6;
  pub const VT_MAX_TOTAL_NPUBS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NpubLimiterPipeConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NpubLimiterPipeConfigArgs
  ) -> flatbuffers::WIPOffset<NpubLimiterPipeConfig<'bldr>> {
    let mut builder = NpubLimiterPipeConfigBuilder::new(_fbb);
    builder.add_max_total_npubs(args.max_total_npubs);
    builder.add_limit_per_npub(args.limit_per_npub);
    builder.add_kind(args.kind);
    builder.finish()
  }

  pub fn unpack(&self) -> NpubLimiterPipeConfigT {
    let kind = self.kind();
    let limit_per_npub = self.limit_per_npub();
    let max_total_npubs = self.max_total_npubs();
    NpubLimiterPipeConfigT {
      kind,
      limit_per_npub,
      max_total_npubs,
    }
  }

  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(NpubLimiterPipeConfig::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn limit_per_npub(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(NpubLimiterPipeConfig::VT_LIMIT_PER_NPUB, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_total_npubs(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(NpubLimiterPipeConfig::VT_MAX_TOTAL_NPUBS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for NpubLimiterPipeConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<u32>("limit_per_npub", Self::VT_LIMIT_PER_NPUB, false)?
     .visit_field::<u32>("max_total_npubs", Self::VT_MAX_TOTAL_NPUBS, false)?
     .finish();
    Ok(())
  }
}
pub struct NpubLimiterPipeConfigArgs {
    pub kind: u16,
    pub limit_per_npub: u32,
    pub max_total_npubs: u32,
}
impl<'a> Default for NpubLimiterPipeConfigArgs {
  #[inline]
  fn default() -> Self {
    NpubLimiterPipeConfigArgs {
      kind: 0,
      limit_per_npub: 0,
      max_total_npubs: 0,
    }
  }
}

pub struct NpubLimiterPipeConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NpubLimiterPipeConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(NpubLimiterPipeConfig::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_limit_per_npub(&mut self, limit_per_npub: u32) {
    self.fbb_.push_slot::<u32>(NpubLimiterPipeConfig::VT_LIMIT_PER_NPUB, limit_per_npub, 0);
  }
  #[inline]
  pub fn add_max_total_npubs(&mut self, max_total_npubs: u32) {
    self.fbb_.push_slot::<u32>(NpubLimiterPipeConfig::VT_MAX_TOTAL_NPUBS, max_total_npubs, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NpubLimiterPipeConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NpubLimiterPipeConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NpubLimiterPipeConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NpubLimiterPipeConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NpubLimiterPipeConfig");
      ds.field("kind", &self.kind());
      ds.field("limit_per_npub", &self.limit_per_npub());
      ds.field("max_total_npubs", &self.max_total_npubs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NpubLimiterPipeConfigT {
  pub kind: u16,
  pub limit_per_npub: u32,
  pub max_total_npubs: u32,
}
impl Default for NpubLimiterPipeConfigT {
  fn default() -> Self {
    Self {
      kind: 0,
      limit_per_npub: 0,
      max_total_npubs: 0,
    }
  }
}
impl NpubLimiterPipeConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<NpubLimiterPipeConfig<'b>> {
    let kind = self.kind;
    let limit_per_npub = self.limit_per_npub;
    let max_total_npubs = self.max_total_npubs;
    NpubLimiterPipeConfig::create(_fbb, &NpubLimiterPipeConfigArgs{
      kind,
      limit_per_npub,
      max_total_npubs,
    })
  }
}
pub enum SaveToDbPipeConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SaveToDbPipeConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SaveToDbPipeConfig<'a> {
  type Inner = SaveToDbPipeConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SaveToDbPipeConfig<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SaveToDbPipeConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args SaveToDbPipeConfigArgs
  ) -> flatbuffers::WIPOffset<SaveToDbPipeConfig<'bldr>> {
    let mut builder = SaveToDbPipeConfigBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> SaveToDbPipeConfigT {
    SaveToDbPipeConfigT {
    }
  }
}

impl flatbuffers::Verifiable for SaveToDbPipeConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SaveToDbPipeConfigArgs {
}
impl<'a> Default for SaveToDbPipeConfigArgs {
  #[inline]
  fn default() -> Self {
    SaveToDbPipeConfigArgs {
    }
  }
}

pub struct SaveToDbPipeConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SaveToDbPipeConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SaveToDbPipeConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SaveToDbPipeConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SaveToDbPipeConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SaveToDbPipeConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SaveToDbPipeConfig");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SaveToDbPipeConfigT {
}
impl Default for SaveToDbPipeConfigT {
  fn default() -> Self {
    Self {
    }
  }
}
impl SaveToDbPipeConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SaveToDbPipeConfig<'b>> {
    SaveToDbPipeConfig::create(_fbb, &SaveToDbPipeConfigArgs{
    })
  }
}
pub enum SerializeEventsPipeConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SerializeEventsPipeConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SerializeEventsPipeConfig<'a> {
  type Inner = SerializeEventsPipeConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SerializeEventsPipeConfig<'a> {
  pub const VT_SUBSCRIPTION_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SerializeEventsPipeConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SerializeEventsPipeConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<SerializeEventsPipeConfig<'bldr>> {
    let mut builder = SerializeEventsPipeConfigBuilder::new(_fbb);
    if let Some(x) = args.subscription_id { builder.add_subscription_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SerializeEventsPipeConfigT {
    let subscription_id = {
      let x = self.subscription_id();
      x.to_string()
    };
    SerializeEventsPipeConfigT {
      subscription_id,
    }
  }

  #[inline]
  pub fn subscription_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SerializeEventsPipeConfig::VT_SUBSCRIPTION_ID, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SerializeEventsPipeConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscription_id", Self::VT_SUBSCRIPTION_ID, true)?
     .finish();
    Ok(())
  }
}
pub struct SerializeEventsPipeConfigArgs<'a> {
    pub subscription_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SerializeEventsPipeConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    SerializeEventsPipeConfigArgs {
      subscription_id: None, // required field
    }
  }
}

pub struct SerializeEventsPipeConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SerializeEventsPipeConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_subscription_id(&mut self, subscription_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SerializeEventsPipeConfig::VT_SUBSCRIPTION_ID, subscription_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SerializeEventsPipeConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SerializeEventsPipeConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SerializeEventsPipeConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SerializeEventsPipeConfig::VT_SUBSCRIPTION_ID,"subscription_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SerializeEventsPipeConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SerializeEventsPipeConfig");
      ds.field("subscription_id", &self.subscription_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SerializeEventsPipeConfigT {
  pub subscription_id: String,
}
impl Default for SerializeEventsPipeConfigT {
  fn default() -> Self {
    Self {
      subscription_id: "".to_string(),
    }
  }
}
impl SerializeEventsPipeConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SerializeEventsPipeConfig<'b>> {
    let subscription_id = Some({
      let x = &self.subscription_id;
      _fbb.create_string(x)
    });
    SerializeEventsPipeConfig::create(_fbb, &SerializeEventsPipeConfigArgs{
      subscription_id,
    })
  }
}
pub enum ProofVerificationPipeConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProofVerificationPipeConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProofVerificationPipeConfig<'a> {
  type Inner = ProofVerificationPipeConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProofVerificationPipeConfig<'a> {
  pub const VT_MAX_PROOFS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProofVerificationPipeConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProofVerificationPipeConfigArgs
  ) -> flatbuffers::WIPOffset<ProofVerificationPipeConfig<'bldr>> {
    let mut builder = ProofVerificationPipeConfigBuilder::new(_fbb);
    builder.add_max_proofs(args.max_proofs);
    builder.finish()
  }

  pub fn unpack(&self) -> ProofVerificationPipeConfigT {
    let max_proofs = self.max_proofs();
    ProofVerificationPipeConfigT {
      max_proofs,
    }
  }

  #[inline]
  pub fn max_proofs(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ProofVerificationPipeConfig::VT_MAX_PROOFS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ProofVerificationPipeConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("max_proofs", Self::VT_MAX_PROOFS, false)?
     .finish();
    Ok(())
  }
}
pub struct ProofVerificationPipeConfigArgs {
    pub max_proofs: u32,
}
impl<'a> Default for ProofVerificationPipeConfigArgs {
  #[inline]
  fn default() -> Self {
    ProofVerificationPipeConfigArgs {
      max_proofs: 0,
    }
  }
}

pub struct ProofVerificationPipeConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProofVerificationPipeConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_max_proofs(&mut self, max_proofs: u32) {
    self.fbb_.push_slot::<u32>(ProofVerificationPipeConfig::VT_MAX_PROOFS, max_proofs, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProofVerificationPipeConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProofVerificationPipeConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProofVerificationPipeConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProofVerificationPipeConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProofVerificationPipeConfig");
      ds.field("max_proofs", &self.max_proofs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ProofVerificationPipeConfigT {
  pub max_proofs: u32,
}
impl Default for ProofVerificationPipeConfigT {
  fn default() -> Self {
    Self {
      max_proofs: 0,
    }
  }
}
impl ProofVerificationPipeConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ProofVerificationPipeConfig<'b>> {
    let max_proofs = self.max_proofs;
    ProofVerificationPipeConfig::create(_fbb, &ProofVerificationPipeConfigArgs{
      max_proofs,
    })
  }
}
pub enum PipeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Pipe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pipe<'a> {
  type Inner = Pipe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Pipe<'a> {
  pub const VT_CONFIG_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CONFIG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Pipe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PipeArgs
  ) -> flatbuffers::WIPOffset<Pipe<'bldr>> {
    let mut builder = PipeBuilder::new(_fbb);
    if let Some(x) = args.config { builder.add_config(x); }
    builder.add_config_type(args.config_type);
    builder.finish()
  }

  pub fn unpack(&self) -> PipeT {
    let config = match self.config_type() {
      PipeConfig::NONE => PipeConfigT::NONE,
      PipeConfig::ParsePipeConfig => PipeConfigT::ParsePipeConfig(Box::new(
        self.config_as_parse_pipe_config()
            .expect("Invalid union table, expected `PipeConfig::ParsePipeConfig`.")
            .unpack()
      )),
      PipeConfig::KindFilterPipeConfig => PipeConfigT::KindFilterPipeConfig(Box::new(
        self.config_as_kind_filter_pipe_config()
            .expect("Invalid union table, expected `PipeConfig::KindFilterPipeConfig`.")
            .unpack()
      )),
      PipeConfig::CounterPipeConfig => PipeConfigT::CounterPipeConfig(Box::new(
        self.config_as_counter_pipe_config()
            .expect("Invalid union table, expected `PipeConfig::CounterPipeConfig`.")
            .unpack()
      )),
      PipeConfig::NpubLimiterPipeConfig => PipeConfigT::NpubLimiterPipeConfig(Box::new(
        self.config_as_npub_limiter_pipe_config()
            .expect("Invalid union table, expected `PipeConfig::NpubLimiterPipeConfig`.")
            .unpack()
      )),
      PipeConfig::SaveToDbPipeConfig => PipeConfigT::SaveToDbPipeConfig(Box::new(
        self.config_as_save_to_db_pipe_config()
            .expect("Invalid union table, expected `PipeConfig::SaveToDbPipeConfig`.")
            .unpack()
      )),
      PipeConfig::SerializeEventsPipeConfig => PipeConfigT::SerializeEventsPipeConfig(Box::new(
        self.config_as_serialize_events_pipe_config()
            .expect("Invalid union table, expected `PipeConfig::SerializeEventsPipeConfig`.")
            .unpack()
      )),
      PipeConfig::ProofVerificationPipeConfig => PipeConfigT::ProofVerificationPipeConfig(Box::new(
        self.config_as_proof_verification_pipe_config()
            .expect("Invalid union table, expected `PipeConfig::ProofVerificationPipeConfig`.")
            .unpack()
      )),
      _ => PipeConfigT::NONE,
    };
    PipeT {
      config,
    }
  }

  #[inline]
  pub fn config_type(&self) -> PipeConfig {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PipeConfig>(Pipe::VT_CONFIG_TYPE, Some(PipeConfig::NONE)).unwrap()}
  }
  #[inline]
  pub fn config(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Pipe::VT_CONFIG, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn config_as_parse_pipe_config(&self) -> Option<ParsePipeConfig<'a>> {
    if self.config_type() == PipeConfig::ParsePipeConfig {
      let u = self.config();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ParsePipeConfig::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn config_as_kind_filter_pipe_config(&self) -> Option<KindFilterPipeConfig<'a>> {
    if self.config_type() == PipeConfig::KindFilterPipeConfig {
      let u = self.config();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { KindFilterPipeConfig::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn config_as_counter_pipe_config(&self) -> Option<CounterPipeConfig<'a>> {
    if self.config_type() == PipeConfig::CounterPipeConfig {
      let u = self.config();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CounterPipeConfig::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn config_as_npub_limiter_pipe_config(&self) -> Option<NpubLimiterPipeConfig<'a>> {
    if self.config_type() == PipeConfig::NpubLimiterPipeConfig {
      let u = self.config();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { NpubLimiterPipeConfig::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn config_as_save_to_db_pipe_config(&self) -> Option<SaveToDbPipeConfig<'a>> {
    if self.config_type() == PipeConfig::SaveToDbPipeConfig {
      let u = self.config();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { SaveToDbPipeConfig::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn config_as_serialize_events_pipe_config(&self) -> Option<SerializeEventsPipeConfig<'a>> {
    if self.config_type() == PipeConfig::SerializeEventsPipeConfig {
      let u = self.config();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { SerializeEventsPipeConfig::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn config_as_proof_verification_pipe_config(&self) -> Option<ProofVerificationPipeConfig<'a>> {
    if self.config_type() == PipeConfig::ProofVerificationPipeConfig {
      let u = self.config();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ProofVerificationPipeConfig::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Pipe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<PipeConfig, _>("config_type", Self::VT_CONFIG_TYPE, "config", Self::VT_CONFIG, true, |key, v, pos| {
        match key {
          PipeConfig::ParsePipeConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParsePipeConfig>>("PipeConfig::ParsePipeConfig", pos),
          PipeConfig::KindFilterPipeConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<KindFilterPipeConfig>>("PipeConfig::KindFilterPipeConfig", pos),
          PipeConfig::CounterPipeConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CounterPipeConfig>>("PipeConfig::CounterPipeConfig", pos),
          PipeConfig::NpubLimiterPipeConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NpubLimiterPipeConfig>>("PipeConfig::NpubLimiterPipeConfig", pos),
          PipeConfig::SaveToDbPipeConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SaveToDbPipeConfig>>("PipeConfig::SaveToDbPipeConfig", pos),
          PipeConfig::SerializeEventsPipeConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SerializeEventsPipeConfig>>("PipeConfig::SerializeEventsPipeConfig", pos),
          PipeConfig::ProofVerificationPipeConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ProofVerificationPipeConfig>>("PipeConfig::ProofVerificationPipeConfig", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PipeArgs {
    pub config_type: PipeConfig,
    pub config: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PipeArgs {
  #[inline]
  fn default() -> Self {
    PipeArgs {
      config_type: PipeConfig::NONE,
      config: None, // required field
    }
  }
}

pub struct PipeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PipeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_config_type(&mut self, config_type: PipeConfig) {
    self.fbb_.push_slot::<PipeConfig>(Pipe::VT_CONFIG_TYPE, config_type, PipeConfig::NONE);
  }
  #[inline]
  pub fn add_config(&mut self, config: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Pipe::VT_CONFIG, config);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PipeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PipeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pipe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Pipe::VT_CONFIG,"config");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Pipe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Pipe");
      ds.field("config_type", &self.config_type());
      match self.config_type() {
        PipeConfig::ParsePipeConfig => {
          if let Some(x) = self.config_as_parse_pipe_config() {
            ds.field("config", &x)
          } else {
            ds.field("config", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PipeConfig::KindFilterPipeConfig => {
          if let Some(x) = self.config_as_kind_filter_pipe_config() {
            ds.field("config", &x)
          } else {
            ds.field("config", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PipeConfig::CounterPipeConfig => {
          if let Some(x) = self.config_as_counter_pipe_config() {
            ds.field("config", &x)
          } else {
            ds.field("config", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PipeConfig::NpubLimiterPipeConfig => {
          if let Some(x) = self.config_as_npub_limiter_pipe_config() {
            ds.field("config", &x)
          } else {
            ds.field("config", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PipeConfig::SaveToDbPipeConfig => {
          if let Some(x) = self.config_as_save_to_db_pipe_config() {
            ds.field("config", &x)
          } else {
            ds.field("config", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PipeConfig::SerializeEventsPipeConfig => {
          if let Some(x) = self.config_as_serialize_events_pipe_config() {
            ds.field("config", &x)
          } else {
            ds.field("config", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PipeConfig::ProofVerificationPipeConfig => {
          if let Some(x) = self.config_as_proof_verification_pipe_config() {
            ds.field("config", &x)
          } else {
            ds.field("config", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("config", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PipeT {
  pub config: PipeConfigT,
}
impl Default for PipeT {
  fn default() -> Self {
    Self {
      config: PipeConfigT::NONE,
    }
  }
}
impl PipeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Pipe<'b>> {
    let config_type = self.config.pipe_config_type();
    let config = self.config.pack(_fbb);
    Pipe::create(_fbb, &PipeArgs{
      config_type,
      config,
    })
  }
}
pub enum PipelineConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PipelineConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PipelineConfig<'a> {
  type Inner = PipelineConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PipelineConfig<'a> {
  pub const VT_PIPES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PipelineConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PipelineConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<PipelineConfig<'bldr>> {
    let mut builder = PipelineConfigBuilder::new(_fbb);
    if let Some(x) = args.pipes { builder.add_pipes(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PipelineConfigT {
    let pipes = {
      let x = self.pipes();
      x.iter().map(|t| t.unpack()).collect()
    };
    PipelineConfigT {
      pipes,
    }
  }

  #[inline]
  pub fn pipes(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pipe<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pipe>>>>(PipelineConfig::VT_PIPES, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for PipelineConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Pipe>>>>("pipes", Self::VT_PIPES, true)?
     .finish();
    Ok(())
  }
}
pub struct PipelineConfigArgs<'a> {
    pub pipes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Pipe<'a>>>>>,
}
impl<'a> Default for PipelineConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    PipelineConfigArgs {
      pipes: None, // required field
    }
  }
}

pub struct PipelineConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PipelineConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pipes(&mut self, pipes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Pipe<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PipelineConfig::VT_PIPES, pipes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PipelineConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PipelineConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PipelineConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PipelineConfig::VT_PIPES,"pipes");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PipelineConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PipelineConfig");
      ds.field("pipes", &self.pipes());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PipelineConfigT {
  pub pipes: Vec<PipeT>,
}
impl Default for PipelineConfigT {
  fn default() -> Self {
    Self {
      pipes: Default::default(),
    }
  }
}
impl PipelineConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PipelineConfig<'b>> {
    let pipes = Some({
      let x = &self.pipes;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    PipelineConfig::create(_fbb, &PipelineConfigArgs{
      pipes,
    })
  }
}
pub enum TemplateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Template<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Template<'a> {
  type Inner = Template<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Template<'a> {
  pub const VT_KIND: flatbuffers::VOffsetT = 4;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;
  pub const VT_TAGS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Template { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TemplateArgs<'args>
  ) -> flatbuffers::WIPOffset<Template<'bldr>> {
    let mut builder = TemplateBuilder::new(_fbb);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_created_at(args.created_at);
    builder.add_kind(args.kind);
    builder.finish()
  }

  pub fn unpack(&self) -> TemplateT {
    let kind = self.kind();
    let created_at = self.created_at();
    let content = {
      let x = self.content();
      x.to_string()
    };
    let tags = {
      let x = self.tags();
      x.iter().map(|t| t.unpack()).collect()
    };
    TemplateT {
      kind,
      created_at,
      content,
      tags,
    }
  }

  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Template::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Template::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Template::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn tags(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(Template::VT_TAGS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Template<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<i32>("created_at", Self::VT_CREATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, true)?
     .finish();
    Ok(())
  }
}
pub struct TemplateArgs<'a> {
    pub kind: u16,
    pub created_at: i32,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
}
impl<'a> Default for TemplateArgs<'a> {
  #[inline]
  fn default() -> Self {
    TemplateArgs {
      kind: 0,
      created_at: 0,
      content: None, // required field
      tags: None, // required field
    }
  }
}

pub struct TemplateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TemplateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(Template::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: i32) {
    self.fbb_.push_slot::<i32>(Template::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Template::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Template::VT_TAGS, tags);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TemplateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TemplateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Template<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Template::VT_CONTENT,"content");
    self.fbb_.required(o, Template::VT_TAGS,"tags");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Template<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Template");
      ds.field("kind", &self.kind());
      ds.field("created_at", &self.created_at());
      ds.field("content", &self.content());
      ds.field("tags", &self.tags());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TemplateT {
  pub kind: u16,
  pub created_at: i32,
  pub content: String,
  pub tags: Vec<StringVecT>,
}
impl Default for TemplateT {
  fn default() -> Self {
    Self {
      kind: 0,
      created_at: 0,
      content: "".to_string(),
      tags: Default::default(),
    }
  }
}
impl TemplateT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Template<'b>> {
    let kind = self.kind;
    let created_at = self.created_at;
    let content = Some({
      let x = &self.content;
      _fbb.create_string(x)
    });
    let tags = Some({
      let x = &self.tags;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Template::create(_fbb, &TemplateArgs{
      kind,
      created_at,
      content,
      tags,
    })
  }
}
pub enum SubscriptionConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubscriptionConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubscriptionConfig<'a> {
  type Inner = SubscriptionConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SubscriptionConfig<'a> {
  pub const VT_PIPELINE: flatbuffers::VOffsetT = 4;
  pub const VT_CLOSE_ON_EOSE: flatbuffers::VOffsetT = 6;
  pub const VT_CACHE_FIRST: flatbuffers::VOffsetT = 8;
  pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 10;
  pub const VT_MAX_EVENTS: flatbuffers::VOffsetT = 12;
  pub const VT_SKIP_CACHE: flatbuffers::VOffsetT = 14;
  pub const VT_FORCE: flatbuffers::VOffsetT = 16;
  pub const VT_BYTES_PER_EVENT: flatbuffers::VOffsetT = 18;
  pub const VT_IS_SLOW: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubscriptionConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscriptionConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<SubscriptionConfig<'bldr>> {
    let mut builder = SubscriptionConfigBuilder::new(_fbb);
    builder.add_timeout_ms(args.timeout_ms);
    builder.add_bytes_per_event(args.bytes_per_event);
    builder.add_max_events(args.max_events);
    if let Some(x) = args.pipeline { builder.add_pipeline(x); }
    builder.add_is_slow(args.is_slow);
    builder.add_force(args.force);
    builder.add_skip_cache(args.skip_cache);
    builder.add_cache_first(args.cache_first);
    builder.add_close_on_eose(args.close_on_eose);
    builder.finish()
  }

  pub fn unpack(&self) -> SubscriptionConfigT {
    let pipeline = self.pipeline().map(|x| {
      Box::new(x.unpack())
    });
    let close_on_eose = self.close_on_eose();
    let cache_first = self.cache_first();
    let timeout_ms = self.timeout_ms();
    let max_events = self.max_events();
    let skip_cache = self.skip_cache();
    let force = self.force();
    let bytes_per_event = self.bytes_per_event();
    let is_slow = self.is_slow();
    SubscriptionConfigT {
      pipeline,
      close_on_eose,
      cache_first,
      timeout_ms,
      max_events,
      skip_cache,
      force,
      bytes_per_event,
      is_slow,
    }
  }

  #[inline]
  pub fn pipeline(&self) -> Option<PipelineConfig<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PipelineConfig>>(SubscriptionConfig::VT_PIPELINE, None)}
  }
  #[inline]
  pub fn close_on_eose(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubscriptionConfig::VT_CLOSE_ON_EOSE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn cache_first(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubscriptionConfig::VT_CACHE_FIRST, Some(true)).unwrap()}
  }
  #[inline]
  pub fn timeout_ms(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SubscriptionConfig::VT_TIMEOUT_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_events(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SubscriptionConfig::VT_MAX_EVENTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn skip_cache(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubscriptionConfig::VT_SKIP_CACHE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn force(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubscriptionConfig::VT_FORCE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bytes_per_event(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SubscriptionConfig::VT_BYTES_PER_EVENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn is_slow(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SubscriptionConfig::VT_IS_SLOW, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SubscriptionConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<PipelineConfig>>("pipeline", Self::VT_PIPELINE, false)?
     .visit_field::<bool>("close_on_eose", Self::VT_CLOSE_ON_EOSE, false)?
     .visit_field::<bool>("cache_first", Self::VT_CACHE_FIRST, false)?
     .visit_field::<u64>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
     .visit_field::<u32>("max_events", Self::VT_MAX_EVENTS, false)?
     .visit_field::<bool>("skip_cache", Self::VT_SKIP_CACHE, false)?
     .visit_field::<bool>("force", Self::VT_FORCE, false)?
     .visit_field::<u32>("bytes_per_event", Self::VT_BYTES_PER_EVENT, false)?
     .visit_field::<bool>("is_slow", Self::VT_IS_SLOW, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscriptionConfigArgs<'a> {
    pub pipeline: Option<flatbuffers::WIPOffset<PipelineConfig<'a>>>,
    pub close_on_eose: bool,
    pub cache_first: bool,
    pub timeout_ms: u64,
    pub max_events: u32,
    pub skip_cache: bool,
    pub force: bool,
    pub bytes_per_event: u32,
    pub is_slow: bool,
}
impl<'a> Default for SubscriptionConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscriptionConfigArgs {
      pipeline: None,
      close_on_eose: false,
      cache_first: true,
      timeout_ms: 0,
      max_events: 0,
      skip_cache: false,
      force: false,
      bytes_per_event: 0,
      is_slow: false,
    }
  }
}

pub struct SubscriptionConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscriptionConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pipeline(&mut self, pipeline: flatbuffers::WIPOffset<PipelineConfig<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PipelineConfig>>(SubscriptionConfig::VT_PIPELINE, pipeline);
  }
  #[inline]
  pub fn add_close_on_eose(&mut self, close_on_eose: bool) {
    self.fbb_.push_slot::<bool>(SubscriptionConfig::VT_CLOSE_ON_EOSE, close_on_eose, false);
  }
  #[inline]
  pub fn add_cache_first(&mut self, cache_first: bool) {
    self.fbb_.push_slot::<bool>(SubscriptionConfig::VT_CACHE_FIRST, cache_first, true);
  }
  #[inline]
  pub fn add_timeout_ms(&mut self, timeout_ms: u64) {
    self.fbb_.push_slot::<u64>(SubscriptionConfig::VT_TIMEOUT_MS, timeout_ms, 0);
  }
  #[inline]
  pub fn add_max_events(&mut self, max_events: u32) {
    self.fbb_.push_slot::<u32>(SubscriptionConfig::VT_MAX_EVENTS, max_events, 0);
  }
  #[inline]
  pub fn add_skip_cache(&mut self, skip_cache: bool) {
    self.fbb_.push_slot::<bool>(SubscriptionConfig::VT_SKIP_CACHE, skip_cache, false);
  }
  #[inline]
  pub fn add_force(&mut self, force: bool) {
    self.fbb_.push_slot::<bool>(SubscriptionConfig::VT_FORCE, force, false);
  }
  #[inline]
  pub fn add_bytes_per_event(&mut self, bytes_per_event: u32) {
    self.fbb_.push_slot::<u32>(SubscriptionConfig::VT_BYTES_PER_EVENT, bytes_per_event, 0);
  }
  #[inline]
  pub fn add_is_slow(&mut self, is_slow: bool) {
    self.fbb_.push_slot::<bool>(SubscriptionConfig::VT_IS_SLOW, is_slow, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SubscriptionConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscriptionConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubscriptionConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubscriptionConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubscriptionConfig");
      ds.field("pipeline", &self.pipeline());
      ds.field("close_on_eose", &self.close_on_eose());
      ds.field("cache_first", &self.cache_first());
      ds.field("timeout_ms", &self.timeout_ms());
      ds.field("max_events", &self.max_events());
      ds.field("skip_cache", &self.skip_cache());
      ds.field("force", &self.force());
      ds.field("bytes_per_event", &self.bytes_per_event());
      ds.field("is_slow", &self.is_slow());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SubscriptionConfigT {
  pub pipeline: Option<Box<PipelineConfigT>>,
  pub close_on_eose: bool,
  pub cache_first: bool,
  pub timeout_ms: u64,
  pub max_events: u32,
  pub skip_cache: bool,
  pub force: bool,
  pub bytes_per_event: u32,
  pub is_slow: bool,
}
impl Default for SubscriptionConfigT {
  fn default() -> Self {
    Self {
      pipeline: None,
      close_on_eose: false,
      cache_first: true,
      timeout_ms: 0,
      max_events: 0,
      skip_cache: false,
      force: false,
      bytes_per_event: 0,
      is_slow: false,
    }
  }
}
impl SubscriptionConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SubscriptionConfig<'b>> {
    let pipeline = self.pipeline.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let close_on_eose = self.close_on_eose;
    let cache_first = self.cache_first;
    let timeout_ms = self.timeout_ms;
    let max_events = self.max_events;
    let skip_cache = self.skip_cache;
    let force = self.force;
    let bytes_per_event = self.bytes_per_event;
    let is_slow = self.is_slow;
    SubscriptionConfig::create(_fbb, &SubscriptionConfigArgs{
      pipeline,
      close_on_eose,
      cache_first,
      timeout_ms,
      max_events,
      skip_cache,
      force,
      bytes_per_event,
      is_slow,
    })
  }
}
pub enum SubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Subscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subscribe<'a> {
  type Inner = Subscribe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Subscribe<'a> {
  pub const VT_SUBSCRIPTION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_REQUESTS: flatbuffers::VOffsetT = 6;
  pub const VT_CONFIG: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Subscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscribeArgs<'args>
  ) -> flatbuffers::WIPOffset<Subscribe<'bldr>> {
    let mut builder = SubscribeBuilder::new(_fbb);
    if let Some(x) = args.config { builder.add_config(x); }
    if let Some(x) = args.requests { builder.add_requests(x); }
    if let Some(x) = args.subscription_id { builder.add_subscription_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SubscribeT {
    let subscription_id = {
      let x = self.subscription_id();
      x.to_string()
    };
    let requests = {
      let x = self.requests();
      x.iter().map(|t| t.unpack()).collect()
    };
    let config = {
      let x = self.config();
      Box::new(x.unpack())
    };
    SubscribeT {
      subscription_id,
      requests,
      config,
    }
  }

  #[inline]
  pub fn subscription_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Subscribe::VT_SUBSCRIPTION_ID, None).unwrap()}
  }
  #[inline]
  pub fn requests(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request>>>>(Subscribe::VT_REQUESTS, None).unwrap()}
  }
  #[inline]
  pub fn config(&self) -> SubscriptionConfig<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SubscriptionConfig>>(Subscribe::VT_CONFIG, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Subscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscription_id", Self::VT_SUBSCRIPTION_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Request>>>>("requests", Self::VT_REQUESTS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<SubscriptionConfig>>("config", Self::VT_CONFIG, true)?
     .finish();
    Ok(())
  }
}
pub struct SubscribeArgs<'a> {
    pub subscription_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requests: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>>>,
    pub config: Option<flatbuffers::WIPOffset<SubscriptionConfig<'a>>>,
}
impl<'a> Default for SubscribeArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribeArgs {
      subscription_id: None, // required field
      requests: None, // required field
      config: None, // required field
    }
  }
}

pub struct SubscribeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscribeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_subscription_id(&mut self, subscription_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscribe::VT_SUBSCRIPTION_ID, subscription_id);
  }
  #[inline]
  pub fn add_requests(&mut self, requests: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Request<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscribe::VT_REQUESTS, requests);
  }
  #[inline]
  pub fn add_config(&mut self, config: flatbuffers::WIPOffset<SubscriptionConfig<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SubscriptionConfig>>(Subscribe::VT_CONFIG, config);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SubscribeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Subscribe::VT_SUBSCRIPTION_ID,"subscription_id");
    self.fbb_.required(o, Subscribe::VT_REQUESTS,"requests");
    self.fbb_.required(o, Subscribe::VT_CONFIG,"config");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Subscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Subscribe");
      ds.field("subscription_id", &self.subscription_id());
      ds.field("requests", &self.requests());
      ds.field("config", &self.config());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SubscribeT {
  pub subscription_id: String,
  pub requests: Vec<RequestT>,
  pub config: Box<SubscriptionConfigT>,
}
impl Default for SubscribeT {
  fn default() -> Self {
    Self {
      subscription_id: "".to_string(),
      requests: Default::default(),
      config: Default::default(),
    }
  }
}
impl SubscribeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Subscribe<'b>> {
    let subscription_id = Some({
      let x = &self.subscription_id;
      _fbb.create_string(x)
    });
    let requests = Some({
      let x = &self.requests;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let config = Some({
      let x = &self.config;
      x.pack(_fbb)
    });
    Subscribe::create(_fbb, &SubscribeArgs{
      subscription_id,
      requests,
      config,
    })
  }
}
pub enum UnsubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unsubscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unsubscribe<'a> {
  type Inner = Unsubscribe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Unsubscribe<'a> {
  pub const VT_SUBSCRIPTION_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unsubscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnsubscribeArgs<'args>
  ) -> flatbuffers::WIPOffset<Unsubscribe<'bldr>> {
    let mut builder = UnsubscribeBuilder::new(_fbb);
    if let Some(x) = args.subscription_id { builder.add_subscription_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> UnsubscribeT {
    let subscription_id = {
      let x = self.subscription_id();
      x.to_string()
    };
    UnsubscribeT {
      subscription_id,
    }
  }

  #[inline]
  pub fn subscription_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Unsubscribe::VT_SUBSCRIPTION_ID, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Unsubscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscription_id", Self::VT_SUBSCRIPTION_ID, true)?
     .finish();
    Ok(())
  }
}
pub struct UnsubscribeArgs<'a> {
    pub subscription_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UnsubscribeArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnsubscribeArgs {
      subscription_id: None, // required field
    }
  }
}

pub struct UnsubscribeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnsubscribeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_subscription_id(&mut self, subscription_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Unsubscribe::VT_SUBSCRIPTION_ID, subscription_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnsubscribeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnsubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unsubscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Unsubscribe::VT_SUBSCRIPTION_ID,"subscription_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unsubscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unsubscribe");
      ds.field("subscription_id", &self.subscription_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UnsubscribeT {
  pub subscription_id: String,
}
impl Default for UnsubscribeT {
  fn default() -> Self {
    Self {
      subscription_id: "".to_string(),
    }
  }
}
impl UnsubscribeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Unsubscribe<'b>> {
    let subscription_id = Some({
      let x = &self.subscription_id;
      _fbb.create_string(x)
    });
    Unsubscribe::create(_fbb, &UnsubscribeArgs{
      subscription_id,
    })
  }
}
pub enum PublishOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Publish<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Publish<'a> {
  type Inner = Publish<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Publish<'a> {
  pub const VT_PUBLISH_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TEMPLATE: flatbuffers::VOffsetT = 6;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Publish { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PublishArgs<'args>
  ) -> flatbuffers::WIPOffset<Publish<'bldr>> {
    let mut builder = PublishBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.template { builder.add_template(x); }
    if let Some(x) = args.publish_id { builder.add_publish_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PublishT {
    let publish_id = {
      let x = self.publish_id();
      x.to_string()
    };
    let template = {
      let x = self.template();
      Box::new(x.unpack())
    };
    let relays = {
      let x = self.relays();
      x.iter().map(|s| s.to_string()).collect()
    };
    PublishT {
      publish_id,
      template,
      relays,
    }
  }

  #[inline]
  pub fn publish_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Publish::VT_PUBLISH_ID, None).unwrap()}
  }
  #[inline]
  pub fn template(&self) -> Template<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Template>>(Publish::VT_TEMPLATE, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Publish::VT_RELAYS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Publish<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("publish_id", Self::VT_PUBLISH_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Template>>("template", Self::VT_TEMPLATE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, true)?
     .finish();
    Ok(())
  }
}
pub struct PublishArgs<'a> {
    pub publish_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub template: Option<flatbuffers::WIPOffset<Template<'a>>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for PublishArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublishArgs {
      publish_id: None, // required field
      template: None, // required field
      relays: None, // required field
    }
  }
}

pub struct PublishBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PublishBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_publish_id(&mut self, publish_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_PUBLISH_ID, publish_id);
  }
  #[inline]
  pub fn add_template(&mut self, template: flatbuffers::WIPOffset<Template<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Template>>(Publish::VT_TEMPLATE, template);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_RELAYS, relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PublishBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PublishBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Publish<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Publish::VT_PUBLISH_ID,"publish_id");
    self.fbb_.required(o, Publish::VT_TEMPLATE,"template");
    self.fbb_.required(o, Publish::VT_RELAYS,"relays");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Publish<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Publish");
      ds.field("publish_id", &self.publish_id());
      ds.field("template", &self.template());
      ds.field("relays", &self.relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PublishT {
  pub publish_id: String,
  pub template: Box<TemplateT>,
  pub relays: Vec<String>,
}
impl Default for PublishT {
  fn default() -> Self {
    Self {
      publish_id: "".to_string(),
      template: Default::default(),
      relays: Default::default(),
    }
  }
}
impl PublishT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Publish<'b>> {
    let publish_id = Some({
      let x = &self.publish_id;
      _fbb.create_string(x)
    });
    let template = Some({
      let x = &self.template;
      x.pack(_fbb)
    });
    let relays = Some({
      let x = &self.relays;
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    Publish::create(_fbb, &PublishArgs{
      publish_id,
      template,
      relays,
    })
  }
}
pub enum SignEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignEvent<'a> {
  type Inner = SignEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignEvent<'a> {
  pub const VT_TEMPLATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SignEventArgs<'args>
  ) -> flatbuffers::WIPOffset<SignEvent<'bldr>> {
    let mut builder = SignEventBuilder::new(_fbb);
    if let Some(x) = args.template { builder.add_template(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SignEventT {
    let template = {
      let x = self.template();
      Box::new(x.unpack())
    };
    SignEventT {
      template,
    }
  }

  #[inline]
  pub fn template(&self) -> Template<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Template>>(SignEvent::VT_TEMPLATE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SignEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Template>>("template", Self::VT_TEMPLATE, true)?
     .finish();
    Ok(())
  }
}
pub struct SignEventArgs<'a> {
    pub template: Option<flatbuffers::WIPOffset<Template<'a>>>,
}
impl<'a> Default for SignEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignEventArgs {
      template: None, // required field
    }
  }
}

pub struct SignEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_template(&mut self, template: flatbuffers::WIPOffset<Template<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Template>>(SignEvent::VT_TEMPLATE, template);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SignEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SignEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SignEvent::VT_TEMPLATE,"template");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignEvent");
      ds.field("template", &self.template());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SignEventT {
  pub template: Box<TemplateT>,
}
impl Default for SignEventT {
  fn default() -> Self {
    Self {
      template: Default::default(),
    }
  }
}
impl SignEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SignEvent<'b>> {
    let template = Some({
      let x = &self.template;
      x.pack(_fbb)
    });
    SignEvent::create(_fbb, &SignEventArgs{
      template,
    })
  }
}
pub enum SetSignerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetSigner<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetSigner<'a> {
  type Inner = SetSigner<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetSigner<'a> {
  pub const VT_SIGNER_TYPE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SIGNER_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetSigner { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetSignerArgs
  ) -> flatbuffers::WIPOffset<SetSigner<'bldr>> {
    let mut builder = SetSignerBuilder::new(_fbb);
    if let Some(x) = args.signer_type { builder.add_signer_type(x); }
    builder.add_signer_type_type(args.signer_type_type);
    builder.finish()
  }

  pub fn unpack(&self) -> SetSignerT {
    let signer_type = match self.signer_type_type() {
      SignerType::NONE => SignerTypeT::NONE,
      SignerType::PrivateKey => SignerTypeT::PrivateKey(Box::new(
        self.signer_type_as_private_key()
            .expect("Invalid union table, expected `SignerType::PrivateKey`.")
            .unpack()
      )),
      _ => SignerTypeT::NONE,
    };
    SetSignerT {
      signer_type,
    }
  }

  #[inline]
  pub fn signer_type_type(&self) -> SignerType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SignerType>(SetSigner::VT_SIGNER_TYPE_TYPE, Some(SignerType::NONE)).unwrap()}
  }
  #[inline]
  pub fn signer_type(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SetSigner::VT_SIGNER_TYPE, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn signer_type_as_private_key(&self) -> Option<PrivateKey<'a>> {
    if self.signer_type_type() == SignerType::PrivateKey {
      let u = self.signer_type();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { PrivateKey::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SetSigner<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<SignerType, _>("signer_type_type", Self::VT_SIGNER_TYPE_TYPE, "signer_type", Self::VT_SIGNER_TYPE, true, |key, v, pos| {
        match key {
          SignerType::PrivateKey => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PrivateKey>>("SignerType::PrivateKey", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SetSignerArgs {
    pub signer_type_type: SignerType,
    pub signer_type: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SetSignerArgs {
  #[inline]
  fn default() -> Self {
    SetSignerArgs {
      signer_type_type: SignerType::NONE,
      signer_type: None, // required field
    }
  }
}

pub struct SetSignerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetSignerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_signer_type_type(&mut self, signer_type_type: SignerType) {
    self.fbb_.push_slot::<SignerType>(SetSigner::VT_SIGNER_TYPE_TYPE, signer_type_type, SignerType::NONE);
  }
  #[inline]
  pub fn add_signer_type(&mut self, signer_type: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetSigner::VT_SIGNER_TYPE, signer_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetSignerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetSignerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetSigner<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SetSigner::VT_SIGNER_TYPE,"signer_type");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetSigner<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetSigner");
      ds.field("signer_type_type", &self.signer_type_type());
      match self.signer_type_type() {
        SignerType::PrivateKey => {
          if let Some(x) = self.signer_type_as_private_key() {
            ds.field("signer_type", &x)
          } else {
            ds.field("signer_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("signer_type", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SetSignerT {
  pub signer_type: SignerTypeT,
}
impl Default for SetSignerT {
  fn default() -> Self {
    Self {
      signer_type: SignerTypeT::NONE,
    }
  }
}
impl SetSignerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SetSigner<'b>> {
    let signer_type_type = self.signer_type.signer_type_type();
    let signer_type = self.signer_type.pack(_fbb);
    SetSigner::create(_fbb, &SetSignerArgs{
      signer_type_type,
      signer_type,
    })
  }
}
pub enum GetPublicKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetPublicKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPublicKey<'a> {
  type Inner = GetPublicKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetPublicKey<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetPublicKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args GetPublicKeyArgs
  ) -> flatbuffers::WIPOffset<GetPublicKey<'bldr>> {
    let mut builder = GetPublicKeyBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> GetPublicKeyT {
    GetPublicKeyT {
    }
  }
}

impl flatbuffers::Verifiable for GetPublicKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GetPublicKeyArgs {
}
impl<'a> Default for GetPublicKeyArgs {
  #[inline]
  fn default() -> Self {
    GetPublicKeyArgs {
    }
  }
}

pub struct GetPublicKeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetPublicKeyBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetPublicKeyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetPublicKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPublicKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetPublicKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetPublicKey");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GetPublicKeyT {
}
impl Default for GetPublicKeyT {
  fn default() -> Self {
    Self {
    }
  }
}
impl GetPublicKeyT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GetPublicKey<'b>> {
    GetPublicKey::create(_fbb, &GetPublicKeyArgs{
    })
  }
}
pub enum MainMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MainMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MainMessage<'a> {
  type Inner = MainMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MainMessage<'a> {
  pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MainMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MainMessageArgs
  ) -> flatbuffers::WIPOffset<MainMessage<'bldr>> {
    let mut builder = MainMessageBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_content_type(args.content_type);
    builder.finish()
  }

  pub fn unpack(&self) -> MainMessageT {
    let content = match self.content_type() {
      MainContent::NONE => MainContentT::NONE,
      MainContent::Subscribe => MainContentT::Subscribe(Box::new(
        self.content_as_subscribe()
            .expect("Invalid union table, expected `MainContent::Subscribe`.")
            .unpack()
      )),
      MainContent::Unsubscribe => MainContentT::Unsubscribe(Box::new(
        self.content_as_unsubscribe()
            .expect("Invalid union table, expected `MainContent::Unsubscribe`.")
            .unpack()
      )),
      MainContent::Publish => MainContentT::Publish(Box::new(
        self.content_as_publish()
            .expect("Invalid union table, expected `MainContent::Publish`.")
            .unpack()
      )),
      MainContent::SignEvent => MainContentT::SignEvent(Box::new(
        self.content_as_sign_event()
            .expect("Invalid union table, expected `MainContent::SignEvent`.")
            .unpack()
      )),
      MainContent::SetSigner => MainContentT::SetSigner(Box::new(
        self.content_as_set_signer()
            .expect("Invalid union table, expected `MainContent::SetSigner`.")
            .unpack()
      )),
      MainContent::GetPublicKey => MainContentT::GetPublicKey(Box::new(
        self.content_as_get_public_key()
            .expect("Invalid union table, expected `MainContent::GetPublicKey`.")
            .unpack()
      )),
      _ => MainContentT::NONE,
    };
    MainMessageT {
      content,
    }
  }

  #[inline]
  pub fn content_type(&self) -> MainContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MainContent>(MainMessage::VT_CONTENT_TYPE, Some(MainContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(MainMessage::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_subscribe(&self) -> Option<Subscribe<'a>> {
    if self.content_type() == MainContent::Subscribe {
      let u = self.content();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Subscribe::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_unsubscribe(&self) -> Option<Unsubscribe<'a>> {
    if self.content_type() == MainContent::Unsubscribe {
      let u = self.content();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Unsubscribe::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_publish(&self) -> Option<Publish<'a>> {
    if self.content_type() == MainContent::Publish {
      let u = self.content();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Publish::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_sign_event(&self) -> Option<SignEvent<'a>> {
    if self.content_type() == MainContent::SignEvent {
      let u = self.content();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { SignEvent::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_set_signer(&self) -> Option<SetSigner<'a>> {
    if self.content_type() == MainContent::SetSigner {
      let u = self.content();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { SetSigner::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_get_public_key(&self) -> Option<GetPublicKey<'a>> {
    if self.content_type() == MainContent::GetPublicKey {
      let u = self.content();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { GetPublicKey::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for MainMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<MainContent, _>("content_type", Self::VT_CONTENT_TYPE, "content", Self::VT_CONTENT, true, |key, v, pos| {
        match key {
          MainContent::Subscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Subscribe>>("MainContent::Subscribe", pos),
          MainContent::Unsubscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Unsubscribe>>("MainContent::Unsubscribe", pos),
          MainContent::Publish => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Publish>>("MainContent::Publish", pos),
          MainContent::SignEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SignEvent>>("MainContent::SignEvent", pos),
          MainContent::SetSigner => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SetSigner>>("MainContent::SetSigner", pos),
          MainContent::GetPublicKey => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetPublicKey>>("MainContent::GetPublicKey", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MainMessageArgs {
    pub content_type: MainContent,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MainMessageArgs {
  #[inline]
  fn default() -> Self {
    MainMessageArgs {
      content_type: MainContent::NONE,
      content: None, // required field
    }
  }
}

pub struct MainMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MainMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_content_type(&mut self, content_type: MainContent) {
    self.fbb_.push_slot::<MainContent>(MainMessage::VT_CONTENT_TYPE, content_type, MainContent::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MainMessage::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MainMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MainMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MainMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, MainMessage::VT_CONTENT,"content");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MainMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MainMessage");
      ds.field("content_type", &self.content_type());
      match self.content_type() {
        MainContent::Subscribe => {
          if let Some(x) = self.content_as_subscribe() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MainContent::Unsubscribe => {
          if let Some(x) = self.content_as_unsubscribe() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MainContent::Publish => {
          if let Some(x) = self.content_as_publish() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MainContent::SignEvent => {
          if let Some(x) = self.content_as_sign_event() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MainContent::SetSigner => {
          if let Some(x) = self.content_as_set_signer() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MainContent::GetPublicKey => {
          if let Some(x) = self.content_as_get_public_key() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("content", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MainMessageT {
  pub content: MainContentT,
}
impl Default for MainMessageT {
  fn default() -> Self {
    Self {
      content: MainContentT::NONE,
    }
  }
}
impl MainMessageT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MainMessage<'b>> {
    let content_type = self.content.main_content_type();
    let content = self.content.pack(_fbb);
    MainMessage::create(_fbb, &MainMessageArgs{
      content_type,
      content,
    })
  }
}
pub enum Kind0ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind0Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind0Parsed<'a> {
  type Inner = Kind0Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind0Parsed<'a> {
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_DISPLAY_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_PICTURE: flatbuffers::VOffsetT = 10;
  pub const VT_BANNER: flatbuffers::VOffsetT = 12;
  pub const VT_ABOUT: flatbuffers::VOffsetT = 14;
  pub const VT_WEBSITE: flatbuffers::VOffsetT = 16;
  pub const VT_NIP05: flatbuffers::VOffsetT = 18;
  pub const VT_LUD06: flatbuffers::VOffsetT = 20;
  pub const VT_LUD16: flatbuffers::VOffsetT = 22;
  pub const VT_GITHUB: flatbuffers::VOffsetT = 24;
  pub const VT_TWITTER: flatbuffers::VOffsetT = 26;
  pub const VT_MASTODON: flatbuffers::VOffsetT = 28;
  pub const VT_NOSTR: flatbuffers::VOffsetT = 30;
  pub const VT_DISPLAY_NAME_ALT: flatbuffers::VOffsetT = 32;
  pub const VT_USERNAME: flatbuffers::VOffsetT = 34;
  pub const VT_BIO: flatbuffers::VOffsetT = 36;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 38;
  pub const VT_AVATAR: flatbuffers::VOffsetT = 40;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind0Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind0ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind0Parsed<'bldr>> {
    let mut builder = Kind0ParsedBuilder::new(_fbb);
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.avatar { builder.add_avatar(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.bio { builder.add_bio(x); }
    if let Some(x) = args.username { builder.add_username(x); }
    if let Some(x) = args.display_name_alt { builder.add_display_name_alt(x); }
    if let Some(x) = args.nostr { builder.add_nostr(x); }
    if let Some(x) = args.mastodon { builder.add_mastodon(x); }
    if let Some(x) = args.twitter { builder.add_twitter(x); }
    if let Some(x) = args.github { builder.add_github(x); }
    if let Some(x) = args.lud16 { builder.add_lud16(x); }
    if let Some(x) = args.lud06 { builder.add_lud06(x); }
    if let Some(x) = args.nip05 { builder.add_nip05(x); }
    if let Some(x) = args.website { builder.add_website(x); }
    if let Some(x) = args.about { builder.add_about(x); }
    if let Some(x) = args.banner { builder.add_banner(x); }
    if let Some(x) = args.picture { builder.add_picture(x); }
    if let Some(x) = args.display_name { builder.add_display_name(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind0ParsedT {
    let pubkey = self.pubkey().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let display_name = self.display_name().map(|x| {
      x.to_string()
    });
    let picture = self.picture().map(|x| {
      x.to_string()
    });
    let banner = self.banner().map(|x| {
      x.to_string()
    });
    let about = self.about().map(|x| {
      x.to_string()
    });
    let website = self.website().map(|x| {
      x.to_string()
    });
    let nip05 = self.nip05().map(|x| {
      x.to_string()
    });
    let lud06 = self.lud06().map(|x| {
      x.to_string()
    });
    let lud16 = self.lud16().map(|x| {
      x.to_string()
    });
    let github = self.github().map(|x| {
      x.to_string()
    });
    let twitter = self.twitter().map(|x| {
      x.to_string()
    });
    let mastodon = self.mastodon().map(|x| {
      x.to_string()
    });
    let nostr = self.nostr().map(|x| {
      x.to_string()
    });
    let display_name_alt = self.display_name_alt().map(|x| {
      x.to_string()
    });
    let username = self.username().map(|x| {
      x.to_string()
    });
    let bio = self.bio().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    let avatar = self.avatar().map(|x| {
      x.to_string()
    });
    let background = self.background().map(|x| {
      x.to_string()
    });
    Kind0ParsedT {
      pubkey,
      name,
      display_name,
      picture,
      banner,
      about,
      website,
      nip05,
      lud06,
      lud16,
      github,
      twitter,
      mastodon,
      nostr,
      display_name_alt,
      username,
      bio,
      image,
      avatar,
      background,
    }
  }

  #[inline]
  pub fn pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_PUBKEY, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_NAME, None)}
  }
  #[inline]
  pub fn display_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_DISPLAY_NAME, None)}
  }
  #[inline]
  pub fn picture(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_PICTURE, None)}
  }
  #[inline]
  pub fn banner(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_BANNER, None)}
  }
  #[inline]
  pub fn about(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_ABOUT, None)}
  }
  #[inline]
  pub fn website(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_WEBSITE, None)}
  }
  #[inline]
  pub fn nip05(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_NIP05, None)}
  }
  #[inline]
  pub fn lud06(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_LUD06, None)}
  }
  #[inline]
  pub fn lud16(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_LUD16, None)}
  }
  #[inline]
  pub fn github(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_GITHUB, None)}
  }
  #[inline]
  pub fn twitter(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_TWITTER, None)}
  }
  #[inline]
  pub fn mastodon(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_MASTODON, None)}
  }
  #[inline]
  pub fn nostr(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_NOSTR, None)}
  }
  #[inline]
  pub fn display_name_alt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_DISPLAY_NAME_ALT, None)}
  }
  #[inline]
  pub fn username(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_USERNAME, None)}
  }
  #[inline]
  pub fn bio(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_BIO, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_IMAGE, None)}
  }
  #[inline]
  pub fn avatar(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_AVATAR, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_BACKGROUND, None)}
  }
}

impl flatbuffers::Verifiable for Kind0Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("display_name", Self::VT_DISPLAY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picture", Self::VT_PICTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("banner", Self::VT_BANNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("about", Self::VT_ABOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("website", Self::VT_WEBSITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nip05", Self::VT_NIP05, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lud06", Self::VT_LUD06, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lud16", Self::VT_LUD16, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("github", Self::VT_GITHUB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("twitter", Self::VT_TWITTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mastodon", Self::VT_MASTODON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nostr", Self::VT_NOSTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("display_name_alt", Self::VT_DISPLAY_NAME_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("username", Self::VT_USERNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bio", Self::VT_BIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avatar", Self::VT_AVATAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("background", Self::VT_BACKGROUND, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind0ParsedArgs<'a> {
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub display_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picture: Option<flatbuffers::WIPOffset<&'a str>>,
    pub banner: Option<flatbuffers::WIPOffset<&'a str>>,
    pub about: Option<flatbuffers::WIPOffset<&'a str>>,
    pub website: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nip05: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lud06: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lud16: Option<flatbuffers::WIPOffset<&'a str>>,
    pub github: Option<flatbuffers::WIPOffset<&'a str>>,
    pub twitter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mastodon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nostr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub display_name_alt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub username: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bio: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatar: Option<flatbuffers::WIPOffset<&'a str>>,
    pub background: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind0ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind0ParsedArgs {
      pubkey: None,
      name: None,
      display_name: None,
      picture: None,
      banner: None,
      about: None,
      website: None,
      nip05: None,
      lud06: None,
      lud16: None,
      github: None,
      twitter: None,
      mastodon: None,
      nostr: None,
      display_name_alt: None,
      username: None,
      bio: None,
      image: None,
      avatar: None,
      background: None,
    }
  }
}

pub struct Kind0ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind0ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_NAME, name);
  }
  #[inline]
  pub fn add_display_name(&mut self, display_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_DISPLAY_NAME, display_name);
  }
  #[inline]
  pub fn add_picture(&mut self, picture: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_PICTURE, picture);
  }
  #[inline]
  pub fn add_banner(&mut self, banner: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_BANNER, banner);
  }
  #[inline]
  pub fn add_about(&mut self, about: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_ABOUT, about);
  }
  #[inline]
  pub fn add_website(&mut self, website: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_WEBSITE, website);
  }
  #[inline]
  pub fn add_nip05(&mut self, nip05: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_NIP05, nip05);
  }
  #[inline]
  pub fn add_lud06(&mut self, lud06: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_LUD06, lud06);
  }
  #[inline]
  pub fn add_lud16(&mut self, lud16: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_LUD16, lud16);
  }
  #[inline]
  pub fn add_github(&mut self, github: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_GITHUB, github);
  }
  #[inline]
  pub fn add_twitter(&mut self, twitter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_TWITTER, twitter);
  }
  #[inline]
  pub fn add_mastodon(&mut self, mastodon: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_MASTODON, mastodon);
  }
  #[inline]
  pub fn add_nostr(&mut self, nostr: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_NOSTR, nostr);
  }
  #[inline]
  pub fn add_display_name_alt(&mut self, display_name_alt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_DISPLAY_NAME_ALT, display_name_alt);
  }
  #[inline]
  pub fn add_username(&mut self, username: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_USERNAME, username);
  }
  #[inline]
  pub fn add_bio(&mut self, bio: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_BIO, bio);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_avatar(&mut self, avatar: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_AVATAR, avatar);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind0ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind0ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind0Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind0Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind0Parsed");
      ds.field("pubkey", &self.pubkey());
      ds.field("name", &self.name());
      ds.field("display_name", &self.display_name());
      ds.field("picture", &self.picture());
      ds.field("banner", &self.banner());
      ds.field("about", &self.about());
      ds.field("website", &self.website());
      ds.field("nip05", &self.nip05());
      ds.field("lud06", &self.lud06());
      ds.field("lud16", &self.lud16());
      ds.field("github", &self.github());
      ds.field("twitter", &self.twitter());
      ds.field("mastodon", &self.mastodon());
      ds.field("nostr", &self.nostr());
      ds.field("display_name_alt", &self.display_name_alt());
      ds.field("username", &self.username());
      ds.field("bio", &self.bio());
      ds.field("image", &self.image());
      ds.field("avatar", &self.avatar());
      ds.field("background", &self.background());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind0ParsedT {
  pub pubkey: Option<String>,
  pub name: Option<String>,
  pub display_name: Option<String>,
  pub picture: Option<String>,
  pub banner: Option<String>,
  pub about: Option<String>,
  pub website: Option<String>,
  pub nip05: Option<String>,
  pub lud06: Option<String>,
  pub lud16: Option<String>,
  pub github: Option<String>,
  pub twitter: Option<String>,
  pub mastodon: Option<String>,
  pub nostr: Option<String>,
  pub display_name_alt: Option<String>,
  pub username: Option<String>,
  pub bio: Option<String>,
  pub image: Option<String>,
  pub avatar: Option<String>,
  pub background: Option<String>,
}
impl Default for Kind0ParsedT {
  fn default() -> Self {
    Self {
      pubkey: None,
      name: None,
      display_name: None,
      picture: None,
      banner: None,
      about: None,
      website: None,
      nip05: None,
      lud06: None,
      lud16: None,
      github: None,
      twitter: None,
      mastodon: None,
      nostr: None,
      display_name_alt: None,
      username: None,
      bio: None,
      image: None,
      avatar: None,
      background: None,
    }
  }
}
impl Kind0ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind0Parsed<'b>> {
    let pubkey = self.pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let display_name = self.display_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let picture = self.picture.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let banner = self.banner.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let about = self.about.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let website = self.website.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let nip05 = self.nip05.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lud06 = self.lud06.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lud16 = self.lud16.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let github = self.github.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let twitter = self.twitter.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mastodon = self.mastodon.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let nostr = self.nostr.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let display_name_alt = self.display_name_alt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let username = self.username.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let bio = self.bio.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let avatar = self.avatar.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let background = self.background.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind0Parsed::create(_fbb, &Kind0ParsedArgs{
      pubkey,
      name,
      display_name,
      picture,
      banner,
      about,
      website,
      nip05,
      lud06,
      lud16,
      github,
      twitter,
      mastodon,
      nostr,
      display_name_alt,
      username,
      bio,
      image,
      avatar,
      background,
    })
  }
}
pub enum Kind1ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind1Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind1Parsed<'a> {
  type Inner = Kind1Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind1Parsed<'a> {
  pub const VT_PARSED_CONTENT: flatbuffers::VOffsetT = 4;
  pub const VT_SHORTENED_CONTENT: flatbuffers::VOffsetT = 6;
  pub const VT_QUOTES: flatbuffers::VOffsetT = 8;
  pub const VT_MENTIONS: flatbuffers::VOffsetT = 10;
  pub const VT_REPLY: flatbuffers::VOffsetT = 12;
  pub const VT_ROOT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind1Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind1ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind1Parsed<'bldr>> {
    let mut builder = Kind1ParsedBuilder::new(_fbb);
    if let Some(x) = args.root { builder.add_root(x); }
    if let Some(x) = args.reply { builder.add_reply(x); }
    if let Some(x) = args.mentions { builder.add_mentions(x); }
    if let Some(x) = args.quotes { builder.add_quotes(x); }
    if let Some(x) = args.shortened_content { builder.add_shortened_content(x); }
    if let Some(x) = args.parsed_content { builder.add_parsed_content(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind1ParsedT {
    let parsed_content = {
      let x = self.parsed_content();
      x.iter().map(|t| t.unpack()).collect()
    };
    let shortened_content = self.shortened_content().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let quotes = self.quotes().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let mentions = self.mentions().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let reply = self.reply().map(|x| {
      Box::new(x.unpack())
    });
    let root = self.root().map(|x| {
      Box::new(x.unpack())
    });
    Kind1ParsedT {
      parsed_content,
      shortened_content,
      quotes,
      mentions,
      reply,
      root,
    }
  }

  #[inline]
  pub fn parsed_content(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock>>>>(Kind1Parsed::VT_PARSED_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn shortened_content(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock>>>>(Kind1Parsed::VT_SHORTENED_CONTENT, None)}
  }
  #[inline]
  pub fn quotes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilePointer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilePointer>>>>(Kind1Parsed::VT_QUOTES, None)}
  }
  #[inline]
  pub fn mentions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventPointer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventPointer>>>>(Kind1Parsed::VT_MENTIONS, None)}
  }
  #[inline]
  pub fn reply(&self) -> Option<EventPointer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EventPointer>>(Kind1Parsed::VT_REPLY, None)}
  }
  #[inline]
  pub fn root(&self) -> Option<EventPointer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EventPointer>>(Kind1Parsed::VT_ROOT, None)}
  }
}

impl flatbuffers::Verifiable for Kind1Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentBlock>>>>("parsed_content", Self::VT_PARSED_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentBlock>>>>("shortened_content", Self::VT_SHORTENED_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProfilePointer>>>>("quotes", Self::VT_QUOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EventPointer>>>>("mentions", Self::VT_MENTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EventPointer>>("reply", Self::VT_REPLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EventPointer>>("root", Self::VT_ROOT, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind1ParsedArgs<'a> {
    pub parsed_content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>>>,
    pub shortened_content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>>>,
    pub quotes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilePointer<'a>>>>>,
    pub mentions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventPointer<'a>>>>>,
    pub reply: Option<flatbuffers::WIPOffset<EventPointer<'a>>>,
    pub root: Option<flatbuffers::WIPOffset<EventPointer<'a>>>,
}
impl<'a> Default for Kind1ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind1ParsedArgs {
      parsed_content: None, // required field
      shortened_content: None,
      quotes: None,
      mentions: None,
      reply: None,
      root: None,
    }
  }
}

pub struct Kind1ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind1ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_parsed_content(&mut self, parsed_content: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_PARSED_CONTENT, parsed_content);
  }
  #[inline]
  pub fn add_shortened_content(&mut self, shortened_content: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_SHORTENED_CONTENT, shortened_content);
  }
  #[inline]
  pub fn add_quotes(&mut self, quotes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProfilePointer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_QUOTES, quotes);
  }
  #[inline]
  pub fn add_mentions(&mut self, mentions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EventPointer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_MENTIONS, mentions);
  }
  #[inline]
  pub fn add_reply(&mut self, reply: flatbuffers::WIPOffset<EventPointer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EventPointer>>(Kind1Parsed::VT_REPLY, reply);
  }
  #[inline]
  pub fn add_root(&mut self, root: flatbuffers::WIPOffset<EventPointer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EventPointer>>(Kind1Parsed::VT_ROOT, root);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind1ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind1ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind1Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind1Parsed::VT_PARSED_CONTENT,"parsed_content");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind1Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind1Parsed");
      ds.field("parsed_content", &self.parsed_content());
      ds.field("shortened_content", &self.shortened_content());
      ds.field("quotes", &self.quotes());
      ds.field("mentions", &self.mentions());
      ds.field("reply", &self.reply());
      ds.field("root", &self.root());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind1ParsedT {
  pub parsed_content: Vec<ContentBlockT>,
  pub shortened_content: Option<Vec<ContentBlockT>>,
  pub quotes: Option<Vec<ProfilePointerT>>,
  pub mentions: Option<Vec<EventPointerT>>,
  pub reply: Option<Box<EventPointerT>>,
  pub root: Option<Box<EventPointerT>>,
}
impl Default for Kind1ParsedT {
  fn default() -> Self {
    Self {
      parsed_content: Default::default(),
      shortened_content: None,
      quotes: None,
      mentions: None,
      reply: None,
      root: None,
    }
  }
}
impl Kind1ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind1Parsed<'b>> {
    let parsed_content = Some({
      let x = &self.parsed_content;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let shortened_content = self.shortened_content.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let quotes = self.quotes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let mentions = self.mentions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let reply = self.reply.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let root = self.root.as_ref().map(|x|{
      x.pack(_fbb)
    });
    Kind1Parsed::create(_fbb, &Kind1ParsedArgs{
      parsed_content,
      shortened_content,
      quotes,
      mentions,
      reply,
      root,
    })
  }
}
pub enum Kind3ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind3Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind3Parsed<'a> {
  type Inner = Kind3Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind3Parsed<'a> {
  pub const VT_CONTACTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind3Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind3ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind3Parsed<'bldr>> {
    let mut builder = Kind3ParsedBuilder::new(_fbb);
    if let Some(x) = args.contacts { builder.add_contacts(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind3ParsedT {
    let contacts = {
      let x = self.contacts();
      x.iter().map(|t| t.unpack()).collect()
    };
    Kind3ParsedT {
      contacts,
    }
  }

  #[inline]
  pub fn contacts(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact>>>>(Kind3Parsed::VT_CONTACTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind3Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Contact>>>>("contacts", Self::VT_CONTACTS, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind3ParsedArgs<'a> {
    pub contacts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>>>>,
}
impl<'a> Default for Kind3ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind3ParsedArgs {
      contacts: None, // required field
    }
  }
}

pub struct Kind3ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind3ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_contacts(&mut self, contacts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Contact<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind3Parsed::VT_CONTACTS, contacts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind3ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind3ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind3Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind3Parsed::VT_CONTACTS,"contacts");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind3Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind3Parsed");
      ds.field("contacts", &self.contacts());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind3ParsedT {
  pub contacts: Vec<ContactT>,
}
impl Default for Kind3ParsedT {
  fn default() -> Self {
    Self {
      contacts: Default::default(),
    }
  }
}
impl Kind3ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind3Parsed<'b>> {
    let contacts = Some({
      let x = &self.contacts;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Kind3Parsed::create(_fbb, &Kind3ParsedArgs{
      contacts,
    })
  }
}
pub enum Kind4ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind4Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind4Parsed<'a> {
  type Inner = Kind4Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind4Parsed<'a> {
  pub const VT_PARSED_CONTENT: flatbuffers::VOffsetT = 4;
  pub const VT_DECRYPTED_CONTENT: flatbuffers::VOffsetT = 6;
  pub const VT_CHAT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind4Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind4ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind4Parsed<'bldr>> {
    let mut builder = Kind4ParsedBuilder::new(_fbb);
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    if let Some(x) = args.chat_id { builder.add_chat_id(x); }
    if let Some(x) = args.decrypted_content { builder.add_decrypted_content(x); }
    if let Some(x) = args.parsed_content { builder.add_parsed_content(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind4ParsedT {
    let parsed_content = self.parsed_content().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let decrypted_content = self.decrypted_content().map(|x| {
      x.to_string()
    });
    let chat_id = {
      let x = self.chat_id();
      x.to_string()
    };
    let recipient = {
      let x = self.recipient();
      x.to_string()
    };
    Kind4ParsedT {
      parsed_content,
      decrypted_content,
      chat_id,
      recipient,
    }
  }

  #[inline]
  pub fn parsed_content(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock>>>>(Kind4Parsed::VT_PARSED_CONTENT, None)}
  }
  #[inline]
  pub fn decrypted_content(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind4Parsed::VT_DECRYPTED_CONTENT, None)}
  }
  #[inline]
  pub fn chat_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind4Parsed::VT_CHAT_ID, None).unwrap()}
  }
  #[inline]
  pub fn recipient(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind4Parsed::VT_RECIPIENT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind4Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentBlock>>>>("parsed_content", Self::VT_PARSED_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("decrypted_content", Self::VT_DECRYPTED_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chat_id", Self::VT_CHAT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind4ParsedArgs<'a> {
    pub parsed_content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>>>,
    pub decrypted_content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chat_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind4ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind4ParsedArgs {
      parsed_content: None,
      decrypted_content: None,
      chat_id: None, // required field
      recipient: None, // required field
    }
  }
}

pub struct Kind4ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind4ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_parsed_content(&mut self, parsed_content: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_PARSED_CONTENT, parsed_content);
  }
  #[inline]
  pub fn add_decrypted_content(&mut self, decrypted_content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_DECRYPTED_CONTENT, decrypted_content);
  }
  #[inline]
  pub fn add_chat_id(&mut self, chat_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_CHAT_ID, chat_id);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind4ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind4ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind4Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind4Parsed::VT_CHAT_ID,"chat_id");
    self.fbb_.required(o, Kind4Parsed::VT_RECIPIENT,"recipient");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind4Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind4Parsed");
      ds.field("parsed_content", &self.parsed_content());
      ds.field("decrypted_content", &self.decrypted_content());
      ds.field("chat_id", &self.chat_id());
      ds.field("recipient", &self.recipient());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind4ParsedT {
  pub parsed_content: Option<Vec<ContentBlockT>>,
  pub decrypted_content: Option<String>,
  pub chat_id: String,
  pub recipient: String,
}
impl Default for Kind4ParsedT {
  fn default() -> Self {
    Self {
      parsed_content: None,
      decrypted_content: None,
      chat_id: "".to_string(),
      recipient: "".to_string(),
    }
  }
}
impl Kind4ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind4Parsed<'b>> {
    let parsed_content = self.parsed_content.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let decrypted_content = self.decrypted_content.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let chat_id = Some({
      let x = &self.chat_id;
      _fbb.create_string(x)
    });
    let recipient = Some({
      let x = &self.recipient;
      _fbb.create_string(x)
    });
    Kind4Parsed::create(_fbb, &Kind4ParsedArgs{
      parsed_content,
      decrypted_content,
      chat_id,
      recipient,
    })
  }
}
pub enum Kind6ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind6Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind6Parsed<'a> {
  type Inner = Kind6Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind6Parsed<'a> {
  pub const VT_REPOSTED_EVENT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind6Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind6ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind6Parsed<'bldr>> {
    let mut builder = Kind6ParsedBuilder::new(_fbb);
    if let Some(x) = args.reposted_event { builder.add_reposted_event(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind6ParsedT {
    let reposted_event = self.reposted_event().map(|x| {
      Box::new(x.unpack())
    });
    Kind6ParsedT {
      reposted_event,
    }
  }

  #[inline]
  pub fn reposted_event(&self) -> Option<ParsedEvent<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParsedEvent>>(Kind6Parsed::VT_REPOSTED_EVENT, None)}
  }
}

impl flatbuffers::Verifiable for Kind6Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParsedEvent>>("reposted_event", Self::VT_REPOSTED_EVENT, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind6ParsedArgs<'a> {
    pub reposted_event: Option<flatbuffers::WIPOffset<ParsedEvent<'a>>>,
}
impl<'a> Default for Kind6ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind6ParsedArgs {
      reposted_event: None,
    }
  }
}

pub struct Kind6ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind6ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reposted_event(&mut self, reposted_event: flatbuffers::WIPOffset<ParsedEvent<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParsedEvent>>(Kind6Parsed::VT_REPOSTED_EVENT, reposted_event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind6ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind6ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind6Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind6Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind6Parsed");
      ds.field("reposted_event", &self.reposted_event());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind6ParsedT {
  pub reposted_event: Option<Box<ParsedEventT>>,
}
impl Default for Kind6ParsedT {
  fn default() -> Self {
    Self {
      reposted_event: None,
    }
  }
}
impl Kind6ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind6Parsed<'b>> {
    let reposted_event = self.reposted_event.as_ref().map(|x|{
      x.pack(_fbb)
    });
    Kind6Parsed::create(_fbb, &Kind6ParsedArgs{
      reposted_event,
    })
  }
}
pub enum Kind7ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7Parsed<'a> {
  type Inner = Kind7Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7Parsed<'a> {
  pub const VT_REACTION_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 8;
  pub const VT_EVENT_KIND: flatbuffers::VOffsetT = 10;
  pub const VT_EMOJI: flatbuffers::VOffsetT = 12;
  pub const VT_TARGET_COORDINATES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7Parsed<'bldr>> {
    let mut builder = Kind7ParsedBuilder::new(_fbb);
    builder.add_event_kind(args.event_kind);
    if let Some(x) = args.target_coordinates { builder.add_target_coordinates(x); }
    if let Some(x) = args.emoji { builder.add_emoji(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.event_id { builder.add_event_id(x); }
    builder.add_reaction_type(args.reaction_type);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7ParsedT {
    let reaction_type = self.reaction_type();
    let event_id = {
      let x = self.event_id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let event_kind = self.event_kind();
    let emoji = self.emoji().map(|x| {
      Box::new(x.unpack())
    });
    let target_coordinates = self.target_coordinates().map(|x| {
      x.to_string()
    });
    Kind7ParsedT {
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    }
  }

  #[inline]
  pub fn reaction_type(&self) -> ReactionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReactionType>(Kind7Parsed::VT_REACTION_TYPE, Some(ReactionType::Like)).unwrap()}
  }
  #[inline]
  pub fn event_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7Parsed::VT_EVENT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7Parsed::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn event_kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind7Parsed::VT_EVENT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn emoji(&self) -> Option<Emoji<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Emoji>>(Kind7Parsed::VT_EMOJI, None)}
  }
  #[inline]
  pub fn target_coordinates(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7Parsed::VT_TARGET_COORDINATES, None)}
  }
}

impl flatbuffers::Verifiable for Kind7Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ReactionType>("reaction_type", Self::VT_REACTION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_id", Self::VT_EVENT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u64>("event_kind", Self::VT_EVENT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Emoji>>("emoji", Self::VT_EMOJI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_coordinates", Self::VT_TARGET_COORDINATES, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7ParsedArgs<'a> {
    pub reaction_type: ReactionType,
    pub event_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_kind: u64,
    pub emoji: Option<flatbuffers::WIPOffset<Emoji<'a>>>,
    pub target_coordinates: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind7ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7ParsedArgs {
      reaction_type: ReactionType::Like,
      event_id: None, // required field
      pubkey: None, // required field
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}

pub struct Kind7ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reaction_type(&mut self, reaction_type: ReactionType) {
    self.fbb_.push_slot::<ReactionType>(Kind7Parsed::VT_REACTION_TYPE, reaction_type, ReactionType::Like);
  }
  #[inline]
  pub fn add_event_id(&mut self, event_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7Parsed::VT_EVENT_ID, event_id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7Parsed::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_event_kind(&mut self, event_kind: u64) {
    self.fbb_.push_slot::<u64>(Kind7Parsed::VT_EVENT_KIND, event_kind, 0);
  }
  #[inline]
  pub fn add_emoji(&mut self, emoji: flatbuffers::WIPOffset<Emoji<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Emoji>>(Kind7Parsed::VT_EMOJI, emoji);
  }
  #[inline]
  pub fn add_target_coordinates(&mut self, target_coordinates: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7Parsed::VT_TARGET_COORDINATES, target_coordinates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7Parsed::VT_EVENT_ID,"event_id");
    self.fbb_.required(o, Kind7Parsed::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7Parsed");
      ds.field("reaction_type", &self.reaction_type());
      ds.field("event_id", &self.event_id());
      ds.field("pubkey", &self.pubkey());
      ds.field("event_kind", &self.event_kind());
      ds.field("emoji", &self.emoji());
      ds.field("target_coordinates", &self.target_coordinates());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7ParsedT {
  pub reaction_type: ReactionType,
  pub event_id: String,
  pub pubkey: String,
  pub event_kind: u64,
  pub emoji: Option<Box<EmojiT>>,
  pub target_coordinates: Option<String>,
}
impl Default for Kind7ParsedT {
  fn default() -> Self {
    Self {
      reaction_type: ReactionType::Like,
      event_id: "".to_string(),
      pubkey: "".to_string(),
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}
impl Kind7ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7Parsed<'b>> {
    let reaction_type = self.reaction_type;
    let event_id = Some({
      let x = &self.event_id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let event_kind = self.event_kind;
    let emoji = self.emoji.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let target_coordinates = self.target_coordinates.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind7Parsed::create(_fbb, &Kind7ParsedArgs{
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    })
  }
}
pub enum Kind17ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind17Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind17Parsed<'a> {
  type Inner = Kind17Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind17Parsed<'a> {
  pub const VT_REACTION_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 8;
  pub const VT_EVENT_KIND: flatbuffers::VOffsetT = 10;
  pub const VT_EMOJI: flatbuffers::VOffsetT = 12;
  pub const VT_TARGET_COORDINATES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind17Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind17ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind17Parsed<'bldr>> {
    let mut builder = Kind17ParsedBuilder::new(_fbb);
    builder.add_event_kind(args.event_kind);
    if let Some(x) = args.target_coordinates { builder.add_target_coordinates(x); }
    if let Some(x) = args.emoji { builder.add_emoji(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.event_id { builder.add_event_id(x); }
    builder.add_reaction_type(args.reaction_type);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind17ParsedT {
    let reaction_type = self.reaction_type();
    let event_id = {
      let x = self.event_id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let event_kind = self.event_kind();
    let emoji = self.emoji().map(|x| {
      Box::new(x.unpack())
    });
    let target_coordinates = self.target_coordinates().map(|x| {
      x.to_string()
    });
    Kind17ParsedT {
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    }
  }

  #[inline]
  pub fn reaction_type(&self) -> ReactionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReactionType>(Kind17Parsed::VT_REACTION_TYPE, Some(ReactionType::Like)).unwrap()}
  }
  #[inline]
  pub fn event_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17Parsed::VT_EVENT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17Parsed::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn event_kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind17Parsed::VT_EVENT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn emoji(&self) -> Option<Emoji<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Emoji>>(Kind17Parsed::VT_EMOJI, None)}
  }
  #[inline]
  pub fn target_coordinates(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17Parsed::VT_TARGET_COORDINATES, None)}
  }
}

impl flatbuffers::Verifiable for Kind17Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ReactionType>("reaction_type", Self::VT_REACTION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_id", Self::VT_EVENT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u64>("event_kind", Self::VT_EVENT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Emoji>>("emoji", Self::VT_EMOJI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_coordinates", Self::VT_TARGET_COORDINATES, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind17ParsedArgs<'a> {
    pub reaction_type: ReactionType,
    pub event_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_kind: u64,
    pub emoji: Option<flatbuffers::WIPOffset<Emoji<'a>>>,
    pub target_coordinates: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind17ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind17ParsedArgs {
      reaction_type: ReactionType::Like,
      event_id: None, // required field
      pubkey: None, // required field
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}

pub struct Kind17ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind17ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reaction_type(&mut self, reaction_type: ReactionType) {
    self.fbb_.push_slot::<ReactionType>(Kind17Parsed::VT_REACTION_TYPE, reaction_type, ReactionType::Like);
  }
  #[inline]
  pub fn add_event_id(&mut self, event_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17Parsed::VT_EVENT_ID, event_id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17Parsed::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_event_kind(&mut self, event_kind: u64) {
    self.fbb_.push_slot::<u64>(Kind17Parsed::VT_EVENT_KIND, event_kind, 0);
  }
  #[inline]
  pub fn add_emoji(&mut self, emoji: flatbuffers::WIPOffset<Emoji<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Emoji>>(Kind17Parsed::VT_EMOJI, emoji);
  }
  #[inline]
  pub fn add_target_coordinates(&mut self, target_coordinates: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17Parsed::VT_TARGET_COORDINATES, target_coordinates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind17ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind17ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind17Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind17Parsed::VT_EVENT_ID,"event_id");
    self.fbb_.required(o, Kind17Parsed::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind17Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind17Parsed");
      ds.field("reaction_type", &self.reaction_type());
      ds.field("event_id", &self.event_id());
      ds.field("pubkey", &self.pubkey());
      ds.field("event_kind", &self.event_kind());
      ds.field("emoji", &self.emoji());
      ds.field("target_coordinates", &self.target_coordinates());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind17ParsedT {
  pub reaction_type: ReactionType,
  pub event_id: String,
  pub pubkey: String,
  pub event_kind: u64,
  pub emoji: Option<Box<EmojiT>>,
  pub target_coordinates: Option<String>,
}
impl Default for Kind17ParsedT {
  fn default() -> Self {
    Self {
      reaction_type: ReactionType::Like,
      event_id: "".to_string(),
      pubkey: "".to_string(),
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}
impl Kind17ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind17Parsed<'b>> {
    let reaction_type = self.reaction_type;
    let event_id = Some({
      let x = &self.event_id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let event_kind = self.event_kind;
    let emoji = self.emoji.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let target_coordinates = self.target_coordinates.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind17Parsed::create(_fbb, &Kind17ParsedArgs{
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    })
  }
}
pub enum Kind10002ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind10002Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind10002Parsed<'a> {
  type Inner = Kind10002Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind10002Parsed<'a> {
  pub const VT_RELAYS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind10002Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind10002ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind10002Parsed<'bldr>> {
    let mut builder = Kind10002ParsedBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind10002ParsedT {
    let relays = {
      let x = self.relays();
      x.iter().map(|t| t.unpack()).collect()
    };
    Kind10002ParsedT {
      relays,
    }
  }

  #[inline]
  pub fn relays(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelayInfo<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelayInfo>>>>(Kind10002Parsed::VT_RELAYS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind10002Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RelayInfo>>>>("relays", Self::VT_RELAYS, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind10002ParsedArgs<'a> {
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelayInfo<'a>>>>>,
}
impl<'a> Default for Kind10002ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind10002ParsedArgs {
      relays: None, // required field
    }
  }
}

pub struct Kind10002ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind10002ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RelayInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10002Parsed::VT_RELAYS, relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind10002ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind10002ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind10002Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind10002Parsed::VT_RELAYS,"relays");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind10002Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind10002Parsed");
      ds.field("relays", &self.relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind10002ParsedT {
  pub relays: Vec<RelayInfoT>,
}
impl Default for Kind10002ParsedT {
  fn default() -> Self {
    Self {
      relays: Default::default(),
    }
  }
}
impl Kind10002ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind10002Parsed<'b>> {
    let relays = Some({
      let x = &self.relays;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Kind10002Parsed::create(_fbb, &Kind10002ParsedArgs{
      relays,
    })
  }
}
pub enum Kind10019ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind10019Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind10019Parsed<'a> {
  type Inner = Kind10019Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind10019Parsed<'a> {
  pub const VT_TRUSTED_MINTS: flatbuffers::VOffsetT = 4;
  pub const VT_P2PK_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_READ_RELAYS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind10019Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind10019ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind10019Parsed<'bldr>> {
    let mut builder = Kind10019ParsedBuilder::new(_fbb);
    if let Some(x) = args.read_relays { builder.add_read_relays(x); }
    if let Some(x) = args.p2pk_pubkey { builder.add_p2pk_pubkey(x); }
    if let Some(x) = args.trusted_mints { builder.add_trusted_mints(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind10019ParsedT {
    let trusted_mints = self.trusted_mints().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let p2pk_pubkey = self.p2pk_pubkey().map(|x| {
      x.to_string()
    });
    let read_relays = self.read_relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    Kind10019ParsedT {
      trusted_mints,
      p2pk_pubkey,
      read_relays,
    }
  }

  #[inline]
  pub fn trusted_mints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintInfo>>>>(Kind10019Parsed::VT_TRUSTED_MINTS, None)}
  }
  #[inline]
  pub fn p2pk_pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind10019Parsed::VT_P2PK_PUBKEY, None)}
  }
  #[inline]
  pub fn read_relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind10019Parsed::VT_READ_RELAYS, None)}
  }
}

impl flatbuffers::Verifiable for Kind10019Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MintInfo>>>>("trusted_mints", Self::VT_TRUSTED_MINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_pubkey", Self::VT_P2PK_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("read_relays", Self::VT_READ_RELAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind10019ParsedArgs<'a> {
    pub trusted_mints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintInfo<'a>>>>>,
    pub p2pk_pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub read_relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for Kind10019ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind10019ParsedArgs {
      trusted_mints: None,
      p2pk_pubkey: None,
      read_relays: None,
    }
  }
}

pub struct Kind10019ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind10019ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_trusted_mints(&mut self, trusted_mints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MintInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10019Parsed::VT_TRUSTED_MINTS, trusted_mints);
  }
  #[inline]
  pub fn add_p2pk_pubkey(&mut self, p2pk_pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10019Parsed::VT_P2PK_PUBKEY, p2pk_pubkey);
  }
  #[inline]
  pub fn add_read_relays(&mut self, read_relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10019Parsed::VT_READ_RELAYS, read_relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind10019ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind10019ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind10019Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind10019Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind10019Parsed");
      ds.field("trusted_mints", &self.trusted_mints());
      ds.field("p2pk_pubkey", &self.p2pk_pubkey());
      ds.field("read_relays", &self.read_relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind10019ParsedT {
  pub trusted_mints: Option<Vec<MintInfoT>>,
  pub p2pk_pubkey: Option<String>,
  pub read_relays: Option<Vec<String>>,
}
impl Default for Kind10019ParsedT {
  fn default() -> Self {
    Self {
      trusted_mints: None,
      p2pk_pubkey: None,
      read_relays: None,
    }
  }
}
impl Kind10019ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind10019Parsed<'b>> {
    let trusted_mints = self.trusted_mints.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let p2pk_pubkey = self.p2pk_pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let read_relays = self.read_relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    Kind10019Parsed::create(_fbb, &Kind10019ParsedArgs{
      trusted_mints,
      p2pk_pubkey,
      read_relays,
    })
  }
}
pub enum Kind17375ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind17375Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind17375Parsed<'a> {
  type Inner = Kind17375Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind17375Parsed<'a> {
  pub const VT_MINTS: flatbuffers::VOffsetT = 4;
  pub const VT_P2PK_PRIV_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_P2PK_PUB_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_DECRYPTED: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind17375Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind17375ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind17375Parsed<'bldr>> {
    let mut builder = Kind17375ParsedBuilder::new(_fbb);
    if let Some(x) = args.p2pk_pub_key { builder.add_p2pk_pub_key(x); }
    if let Some(x) = args.p2pk_priv_key { builder.add_p2pk_priv_key(x); }
    if let Some(x) = args.mints { builder.add_mints(x); }
    builder.add_decrypted(args.decrypted);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind17375ParsedT {
    let mints = {
      let x = self.mints();
      x.iter().map(|s| s.to_string()).collect()
    };
    let p2pk_priv_key = self.p2pk_priv_key().map(|x| {
      x.to_string()
    });
    let p2pk_pub_key = self.p2pk_pub_key().map(|x| {
      x.to_string()
    });
    let decrypted = self.decrypted();
    Kind17375ParsedT {
      mints,
      p2pk_priv_key,
      p2pk_pub_key,
      decrypted,
    }
  }

  #[inline]
  pub fn mints(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind17375Parsed::VT_MINTS, None).unwrap()}
  }
  #[inline]
  pub fn p2pk_priv_key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17375Parsed::VT_P2PK_PRIV_KEY, None)}
  }
  #[inline]
  pub fn p2pk_pub_key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17375Parsed::VT_P2PK_PUB_KEY, None)}
  }
  #[inline]
  pub fn decrypted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind17375Parsed::VT_DECRYPTED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind17375Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mints", Self::VT_MINTS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_priv_key", Self::VT_P2PK_PRIV_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_pub_key", Self::VT_P2PK_PUB_KEY, false)?
     .visit_field::<bool>("decrypted", Self::VT_DECRYPTED, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind17375ParsedArgs<'a> {
    pub mints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub p2pk_priv_key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub p2pk_pub_key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub decrypted: bool,
}
impl<'a> Default for Kind17375ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind17375ParsedArgs {
      mints: None, // required field
      p2pk_priv_key: None,
      p2pk_pub_key: None,
      decrypted: false,
    }
  }
}

pub struct Kind17375ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind17375ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mints(&mut self, mints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17375Parsed::VT_MINTS, mints);
  }
  #[inline]
  pub fn add_p2pk_priv_key(&mut self, p2pk_priv_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17375Parsed::VT_P2PK_PRIV_KEY, p2pk_priv_key);
  }
  #[inline]
  pub fn add_p2pk_pub_key(&mut self, p2pk_pub_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17375Parsed::VT_P2PK_PUB_KEY, p2pk_pub_key);
  }
  #[inline]
  pub fn add_decrypted(&mut self, decrypted: bool) {
    self.fbb_.push_slot::<bool>(Kind17375Parsed::VT_DECRYPTED, decrypted, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind17375ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind17375ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind17375Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind17375Parsed::VT_MINTS,"mints");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind17375Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind17375Parsed");
      ds.field("mints", &self.mints());
      ds.field("p2pk_priv_key", &self.p2pk_priv_key());
      ds.field("p2pk_pub_key", &self.p2pk_pub_key());
      ds.field("decrypted", &self.decrypted());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind17375ParsedT {
  pub mints: Vec<String>,
  pub p2pk_priv_key: Option<String>,
  pub p2pk_pub_key: Option<String>,
  pub decrypted: bool,
}
impl Default for Kind17375ParsedT {
  fn default() -> Self {
    Self {
      mints: Default::default(),
      p2pk_priv_key: None,
      p2pk_pub_key: None,
      decrypted: false,
    }
  }
}
impl Kind17375ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind17375Parsed<'b>> {
    let mints = Some({
      let x = &self.mints;
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let p2pk_priv_key = self.p2pk_priv_key.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let p2pk_pub_key = self.p2pk_pub_key.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let decrypted = self.decrypted;
    Kind17375Parsed::create(_fbb, &Kind17375ParsedArgs{
      mints,
      p2pk_priv_key,
      p2pk_pub_key,
      decrypted,
    })
  }
}
pub enum Kind7374ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7374Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7374Parsed<'a> {
  type Inner = Kind7374Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7374Parsed<'a> {
  pub const VT_QUOTE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MINT_URL: flatbuffers::VOffsetT = 6;
  pub const VT_EXPIRATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7374Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7374ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7374Parsed<'bldr>> {
    let mut builder = Kind7374ParsedBuilder::new(_fbb);
    builder.add_expiration(args.expiration);
    if let Some(x) = args.mint_url { builder.add_mint_url(x); }
    if let Some(x) = args.quote_id { builder.add_quote_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7374ParsedT {
    let quote_id = {
      let x = self.quote_id();
      x.to_string()
    };
    let mint_url = {
      let x = self.mint_url();
      x.to_string()
    };
    let expiration = self.expiration();
    Kind7374ParsedT {
      quote_id,
      mint_url,
      expiration,
    }
  }

  #[inline]
  pub fn quote_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7374Parsed::VT_QUOTE_ID, None).unwrap()}
  }
  #[inline]
  pub fn mint_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7374Parsed::VT_MINT_URL, None).unwrap()}
  }
  #[inline]
  pub fn expiration(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind7374Parsed::VT_EXPIRATION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind7374Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("quote_id", Self::VT_QUOTE_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint_url", Self::VT_MINT_URL, true)?
     .visit_field::<u64>("expiration", Self::VT_EXPIRATION, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7374ParsedArgs<'a> {
    pub quote_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mint_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expiration: u64,
}
impl<'a> Default for Kind7374ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7374ParsedArgs {
      quote_id: None, // required field
      mint_url: None, // required field
      expiration: 0,
    }
  }
}

pub struct Kind7374ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7374ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_quote_id(&mut self, quote_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7374Parsed::VT_QUOTE_ID, quote_id);
  }
  #[inline]
  pub fn add_mint_url(&mut self, mint_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7374Parsed::VT_MINT_URL, mint_url);
  }
  #[inline]
  pub fn add_expiration(&mut self, expiration: u64) {
    self.fbb_.push_slot::<u64>(Kind7374Parsed::VT_EXPIRATION, expiration, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7374ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7374ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7374Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7374Parsed::VT_QUOTE_ID,"quote_id");
    self.fbb_.required(o, Kind7374Parsed::VT_MINT_URL,"mint_url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7374Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7374Parsed");
      ds.field("quote_id", &self.quote_id());
      ds.field("mint_url", &self.mint_url());
      ds.field("expiration", &self.expiration());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7374ParsedT {
  pub quote_id: String,
  pub mint_url: String,
  pub expiration: u64,
}
impl Default for Kind7374ParsedT {
  fn default() -> Self {
    Self {
      quote_id: "".to_string(),
      mint_url: "".to_string(),
      expiration: 0,
    }
  }
}
impl Kind7374ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7374Parsed<'b>> {
    let quote_id = Some({
      let x = &self.quote_id;
      _fbb.create_string(x)
    });
    let mint_url = Some({
      let x = &self.mint_url;
      _fbb.create_string(x)
    });
    let expiration = self.expiration;
    Kind7374Parsed::create(_fbb, &Kind7374ParsedArgs{
      quote_id,
      mint_url,
      expiration,
    })
  }
}
pub enum Kind7375ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7375Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7375Parsed<'a> {
  type Inner = Kind7375Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7375Parsed<'a> {
  pub const VT_MINT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_PROOFS: flatbuffers::VOffsetT = 6;
  pub const VT_DELETED_IDS: flatbuffers::VOffsetT = 8;
  pub const VT_DECRYPTED: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7375Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7375ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7375Parsed<'bldr>> {
    let mut builder = Kind7375ParsedBuilder::new(_fbb);
    if let Some(x) = args.deleted_ids { builder.add_deleted_ids(x); }
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    if let Some(x) = args.mint_url { builder.add_mint_url(x); }
    builder.add_decrypted(args.decrypted);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7375ParsedT {
    let mint_url = {
      let x = self.mint_url();
      x.to_string()
    };
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    let deleted_ids = self.deleted_ids().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let decrypted = self.decrypted();
    Kind7375ParsedT {
      mint_url,
      proofs,
      deleted_ids,
      decrypted,
    }
  }

  #[inline]
  pub fn mint_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7375Parsed::VT_MINT_URL, None).unwrap()}
  }
  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof>>>>(Kind7375Parsed::VT_PROOFS, None).unwrap()}
  }
  #[inline]
  pub fn deleted_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7375Parsed::VT_DELETED_IDS, None)}
  }
  #[inline]
  pub fn decrypted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind7375Parsed::VT_DECRYPTED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind7375Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint_url", Self::VT_MINT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Proof>>>>("proofs", Self::VT_PROOFS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("deleted_ids", Self::VT_DELETED_IDS, false)?
     .visit_field::<bool>("decrypted", Self::VT_DECRYPTED, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7375ParsedArgs<'a> {
    pub mint_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>>>,
    pub deleted_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub decrypted: bool,
}
impl<'a> Default for Kind7375ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7375ParsedArgs {
      mint_url: None, // required field
      proofs: None, // required field
      deleted_ids: None,
      decrypted: false,
    }
  }
}

pub struct Kind7375ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7375ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mint_url(&mut self, mint_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7375Parsed::VT_MINT_URL, mint_url);
  }
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Proof<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7375Parsed::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn add_deleted_ids(&mut self, deleted_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7375Parsed::VT_DELETED_IDS, deleted_ids);
  }
  #[inline]
  pub fn add_decrypted(&mut self, decrypted: bool) {
    self.fbb_.push_slot::<bool>(Kind7375Parsed::VT_DECRYPTED, decrypted, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7375ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7375ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7375Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7375Parsed::VT_MINT_URL,"mint_url");
    self.fbb_.required(o, Kind7375Parsed::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7375Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7375Parsed");
      ds.field("mint_url", &self.mint_url());
      ds.field("proofs", &self.proofs());
      ds.field("deleted_ids", &self.deleted_ids());
      ds.field("decrypted", &self.decrypted());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7375ParsedT {
  pub mint_url: String,
  pub proofs: Vec<ProofT>,
  pub deleted_ids: Option<Vec<String>>,
  pub decrypted: bool,
}
impl Default for Kind7375ParsedT {
  fn default() -> Self {
    Self {
      mint_url: "".to_string(),
      proofs: Default::default(),
      deleted_ids: None,
      decrypted: false,
    }
  }
}
impl Kind7375ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7375Parsed<'b>> {
    let mint_url = Some({
      let x = &self.mint_url;
      _fbb.create_string(x)
    });
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let deleted_ids = self.deleted_ids.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let decrypted = self.decrypted;
    Kind7375Parsed::create(_fbb, &Kind7375ParsedArgs{
      mint_url,
      proofs,
      deleted_ids,
      decrypted,
    })
  }
}
pub enum Kind7376ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7376Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7376Parsed<'a> {
  type Inner = Kind7376Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7376Parsed<'a> {
  pub const VT_DIRECTION: flatbuffers::VOffsetT = 4;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_CREATED_EVENTS: flatbuffers::VOffsetT = 8;
  pub const VT_DESTROYED_EVENTS: flatbuffers::VOffsetT = 10;
  pub const VT_REDEEMED_EVENTS: flatbuffers::VOffsetT = 12;
  pub const VT_TAGS: flatbuffers::VOffsetT = 14;
  pub const VT_DECRYPTED: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7376Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7376ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7376Parsed<'bldr>> {
    let mut builder = Kind7376ParsedBuilder::new(_fbb);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.redeemed_events { builder.add_redeemed_events(x); }
    if let Some(x) = args.destroyed_events { builder.add_destroyed_events(x); }
    if let Some(x) = args.created_events { builder.add_created_events(x); }
    builder.add_amount(args.amount);
    if let Some(x) = args.direction { builder.add_direction(x); }
    builder.add_decrypted(args.decrypted);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7376ParsedT {
    let direction = {
      let x = self.direction();
      x.to_string()
    };
    let amount = self.amount();
    let created_events = self.created_events().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let destroyed_events = self.destroyed_events().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let redeemed_events = self.redeemed_events().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let decrypted = self.decrypted();
    Kind7376ParsedT {
      direction,
      amount,
      created_events,
      destroyed_events,
      redeemed_events,
      tags,
      decrypted,
    }
  }

  #[inline]
  pub fn direction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7376Parsed::VT_DIRECTION, None).unwrap()}
  }
  #[inline]
  pub fn amount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Kind7376Parsed::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn created_events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7376Parsed::VT_CREATED_EVENTS, None)}
  }
  #[inline]
  pub fn destroyed_events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7376Parsed::VT_DESTROYED_EVENTS, None)}
  }
  #[inline]
  pub fn redeemed_events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7376Parsed::VT_REDEEMED_EVENTS, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HistoryTag<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HistoryTag>>>>(Kind7376Parsed::VT_TAGS, None)}
  }
  #[inline]
  pub fn decrypted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind7376Parsed::VT_DECRYPTED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind7376Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("direction", Self::VT_DIRECTION, true)?
     .visit_field::<i32>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("created_events", Self::VT_CREATED_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("destroyed_events", Self::VT_DESTROYED_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("redeemed_events", Self::VT_REDEEMED_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HistoryTag>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<bool>("decrypted", Self::VT_DECRYPTED, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7376ParsedArgs<'a> {
    pub direction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amount: i32,
    pub created_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub destroyed_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub redeemed_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HistoryTag<'a>>>>>,
    pub decrypted: bool,
}
impl<'a> Default for Kind7376ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7376ParsedArgs {
      direction: None, // required field
      amount: 0,
      created_events: None,
      destroyed_events: None,
      redeemed_events: None,
      tags: None,
      decrypted: false,
    }
  }
}

pub struct Kind7376ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7376ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_direction(&mut self, direction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_DIRECTION, direction);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: i32) {
    self.fbb_.push_slot::<i32>(Kind7376Parsed::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_created_events(&mut self, created_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_CREATED_EVENTS, created_events);
  }
  #[inline]
  pub fn add_destroyed_events(&mut self, destroyed_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_DESTROYED_EVENTS, destroyed_events);
  }
  #[inline]
  pub fn add_redeemed_events(&mut self, redeemed_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_REDEEMED_EVENTS, redeemed_events);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<HistoryTag<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_decrypted(&mut self, decrypted: bool) {
    self.fbb_.push_slot::<bool>(Kind7376Parsed::VT_DECRYPTED, decrypted, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7376ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7376ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7376Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7376Parsed::VT_DIRECTION,"direction");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7376Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7376Parsed");
      ds.field("direction", &self.direction());
      ds.field("amount", &self.amount());
      ds.field("created_events", &self.created_events());
      ds.field("destroyed_events", &self.destroyed_events());
      ds.field("redeemed_events", &self.redeemed_events());
      ds.field("tags", &self.tags());
      ds.field("decrypted", &self.decrypted());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7376ParsedT {
  pub direction: String,
  pub amount: i32,
  pub created_events: Option<Vec<String>>,
  pub destroyed_events: Option<Vec<String>>,
  pub redeemed_events: Option<Vec<String>>,
  pub tags: Option<Vec<HistoryTagT>>,
  pub decrypted: bool,
}
impl Default for Kind7376ParsedT {
  fn default() -> Self {
    Self {
      direction: "".to_string(),
      amount: 0,
      created_events: None,
      destroyed_events: None,
      redeemed_events: None,
      tags: None,
      decrypted: false,
    }
  }
}
impl Kind7376ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7376Parsed<'b>> {
    let direction = Some({
      let x = &self.direction;
      _fbb.create_string(x)
    });
    let amount = self.amount;
    let created_events = self.created_events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let destroyed_events = self.destroyed_events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let redeemed_events = self.redeemed_events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let decrypted = self.decrypted;
    Kind7376Parsed::create(_fbb, &Kind7376ParsedArgs{
      direction,
      amount,
      created_events,
      destroyed_events,
      redeemed_events,
      tags,
      decrypted,
    })
  }
}
pub enum Kind9321ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind9321Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind9321Parsed<'a> {
  type Inner = Kind9321Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind9321Parsed<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 8;
  pub const VT_SENDER: flatbuffers::VOffsetT = 10;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 12;
  pub const VT_MINT_URL: flatbuffers::VOffsetT = 14;
  pub const VT_REDEEMED: flatbuffers::VOffsetT = 16;
  pub const VT_PROOFS: flatbuffers::VOffsetT = 18;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 20;
  pub const VT_IS_P2PK_LOCKED: flatbuffers::VOffsetT = 22;
  pub const VT_P2PK_PUBKEY: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind9321Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind9321ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind9321Parsed<'bldr>> {
    let mut builder = Kind9321ParsedBuilder::new(_fbb);
    if let Some(x) = args.p2pk_pubkey { builder.add_p2pk_pubkey(x); }
    if let Some(x) = args.comment { builder.add_comment(x); }
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    if let Some(x) = args.mint_url { builder.add_mint_url(x); }
    if let Some(x) = args.event_id { builder.add_event_id(x); }
    if let Some(x) = args.sender { builder.add_sender(x); }
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    builder.add_amount(args.amount);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_is_p2pk_locked(args.is_p2pk_locked);
    builder.add_redeemed(args.redeemed);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind9321ParsedT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let amount = self.amount();
    let recipient = {
      let x = self.recipient();
      x.to_string()
    };
    let sender = {
      let x = self.sender();
      x.to_string()
    };
    let event_id = self.event_id().map(|x| {
      x.to_string()
    });
    let mint_url = {
      let x = self.mint_url();
      x.to_string()
    };
    let redeemed = self.redeemed();
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    let comment = self.comment().map(|x| {
      x.to_string()
    });
    let is_p2pk_locked = self.is_p2pk_locked();
    let p2pk_pubkey = self.p2pk_pubkey().map(|x| {
      x.to_string()
    });
    Kind9321ParsedT {
      id,
      amount,
      recipient,
      sender,
      event_id,
      mint_url,
      redeemed,
      proofs,
      comment,
      is_p2pk_locked,
      p2pk_pubkey,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn amount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Kind9321Parsed::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn recipient(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_RECIPIENT, None).unwrap()}
  }
  #[inline]
  pub fn sender(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_SENDER, None).unwrap()}
  }
  #[inline]
  pub fn event_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_EVENT_ID, None)}
  }
  #[inline]
  pub fn mint_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_MINT_URL, None).unwrap()}
  }
  #[inline]
  pub fn redeemed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind9321Parsed::VT_REDEEMED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof>>>>(Kind9321Parsed::VT_PROOFS, None).unwrap()}
  }
  #[inline]
  pub fn comment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_COMMENT, None)}
  }
  #[inline]
  pub fn is_p2pk_locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind9321Parsed::VT_IS_P2PK_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn p2pk_pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_P2PK_PUBKEY, None)}
  }
}

impl flatbuffers::Verifiable for Kind9321Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<i32>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender", Self::VT_SENDER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_id", Self::VT_EVENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint_url", Self::VT_MINT_URL, true)?
     .visit_field::<bool>("redeemed", Self::VT_REDEEMED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Proof>>>>("proofs", Self::VT_PROOFS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comment", Self::VT_COMMENT, false)?
     .visit_field::<bool>("is_p2pk_locked", Self::VT_IS_P2PK_LOCKED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_pubkey", Self::VT_P2PK_PUBKEY, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind9321ParsedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amount: i32,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mint_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub redeemed: bool,
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>>>,
    pub comment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_p2pk_locked: bool,
    pub p2pk_pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind9321ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind9321ParsedArgs {
      id: None, // required field
      amount: 0,
      recipient: None, // required field
      sender: None, // required field
      event_id: None,
      mint_url: None, // required field
      redeemed: false,
      proofs: None, // required field
      comment: None,
      is_p2pk_locked: false,
      p2pk_pubkey: None,
    }
  }
}

pub struct Kind9321ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind9321ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_ID, id);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: i32) {
    self.fbb_.push_slot::<i32>(Kind9321Parsed::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_SENDER, sender);
  }
  #[inline]
  pub fn add_event_id(&mut self, event_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_EVENT_ID, event_id);
  }
  #[inline]
  pub fn add_mint_url(&mut self, mint_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_MINT_URL, mint_url);
  }
  #[inline]
  pub fn add_redeemed(&mut self, redeemed: bool) {
    self.fbb_.push_slot::<bool>(Kind9321Parsed::VT_REDEEMED, redeemed, false);
  }
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Proof<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_COMMENT, comment);
  }
  #[inline]
  pub fn add_is_p2pk_locked(&mut self, is_p2pk_locked: bool) {
    self.fbb_.push_slot::<bool>(Kind9321Parsed::VT_IS_P2PK_LOCKED, is_p2pk_locked, false);
  }
  #[inline]
  pub fn add_p2pk_pubkey(&mut self, p2pk_pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_P2PK_PUBKEY, p2pk_pubkey);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind9321ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind9321ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind9321Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind9321Parsed::VT_ID,"id");
    self.fbb_.required(o, Kind9321Parsed::VT_RECIPIENT,"recipient");
    self.fbb_.required(o, Kind9321Parsed::VT_SENDER,"sender");
    self.fbb_.required(o, Kind9321Parsed::VT_MINT_URL,"mint_url");
    self.fbb_.required(o, Kind9321Parsed::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind9321Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind9321Parsed");
      ds.field("id", &self.id());
      ds.field("amount", &self.amount());
      ds.field("recipient", &self.recipient());
      ds.field("sender", &self.sender());
      ds.field("event_id", &self.event_id());
      ds.field("mint_url", &self.mint_url());
      ds.field("redeemed", &self.redeemed());
      ds.field("proofs", &self.proofs());
      ds.field("comment", &self.comment());
      ds.field("is_p2pk_locked", &self.is_p2pk_locked());
      ds.field("p2pk_pubkey", &self.p2pk_pubkey());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind9321ParsedT {
  pub id: String,
  pub amount: i32,
  pub recipient: String,
  pub sender: String,
  pub event_id: Option<String>,
  pub mint_url: String,
  pub redeemed: bool,
  pub proofs: Vec<ProofT>,
  pub comment: Option<String>,
  pub is_p2pk_locked: bool,
  pub p2pk_pubkey: Option<String>,
}
impl Default for Kind9321ParsedT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      amount: 0,
      recipient: "".to_string(),
      sender: "".to_string(),
      event_id: None,
      mint_url: "".to_string(),
      redeemed: false,
      proofs: Default::default(),
      comment: None,
      is_p2pk_locked: false,
      p2pk_pubkey: None,
    }
  }
}
impl Kind9321ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind9321Parsed<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let amount = self.amount;
    let recipient = Some({
      let x = &self.recipient;
      _fbb.create_string(x)
    });
    let sender = Some({
      let x = &self.sender;
      _fbb.create_string(x)
    });
    let event_id = self.event_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mint_url = Some({
      let x = &self.mint_url;
      _fbb.create_string(x)
    });
    let redeemed = self.redeemed;
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let comment = self.comment.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let is_p2pk_locked = self.is_p2pk_locked;
    let p2pk_pubkey = self.p2pk_pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind9321Parsed::create(_fbb, &Kind9321ParsedArgs{
      id,
      amount,
      recipient,
      sender,
      event_id,
      mint_url,
      redeemed,
      proofs,
      comment,
      is_p2pk_locked,
      p2pk_pubkey,
    })
  }
}
pub enum Kind9735ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind9735Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind9735Parsed<'a> {
  type Inner = Kind9735Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind9735Parsed<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;
  pub const VT_BOLT11: flatbuffers::VOffsetT = 10;
  pub const VT_PREIMAGE: flatbuffers::VOffsetT = 12;
  pub const VT_SENDER: flatbuffers::VOffsetT = 14;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 16;
  pub const VT_EVENT: flatbuffers::VOffsetT = 18;
  pub const VT_EVENT_COORDINATE: flatbuffers::VOffsetT = 20;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 22;
  pub const VT_VALID: flatbuffers::VOffsetT = 24;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind9735Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind9735ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind9735Parsed<'bldr>> {
    let mut builder = Kind9735ParsedBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.event_coordinate { builder.add_event_coordinate(x); }
    if let Some(x) = args.event { builder.add_event(x); }
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    if let Some(x) = args.sender { builder.add_sender(x); }
    if let Some(x) = args.preimage { builder.add_preimage(x); }
    if let Some(x) = args.bolt11 { builder.add_bolt11(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_amount(args.amount);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_valid(args.valid);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind9735ParsedT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let amount = self.amount();
    let content = {
      let x = self.content();
      x.to_string()
    };
    let bolt11 = {
      let x = self.bolt11();
      x.to_string()
    };
    let preimage = self.preimage().map(|x| {
      x.to_string()
    });
    let sender = {
      let x = self.sender();
      x.to_string()
    };
    let recipient = {
      let x = self.recipient();
      x.to_string()
    };
    let event = self.event().map(|x| {
      x.to_string()
    });
    let event_coordinate = self.event_coordinate().map(|x| {
      x.to_string()
    });
    let timestamp = self.timestamp();
    let valid = self.valid();
    let description = {
      let x = self.description();
      Box::new(x.unpack())
    };
    Kind9735ParsedT {
      id,
      amount,
      content,
      bolt11,
      preimage,
      sender,
      recipient,
      event,
      event_coordinate,
      timestamp,
      valid,
      description,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn amount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Kind9735Parsed::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn bolt11(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_BOLT11, None).unwrap()}
  }
  #[inline]
  pub fn preimage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_PREIMAGE, None)}
  }
  #[inline]
  pub fn sender(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_SENDER, None).unwrap()}
  }
  #[inline]
  pub fn recipient(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_RECIPIENT, None).unwrap()}
  }
  #[inline]
  pub fn event(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_EVENT, None)}
  }
  #[inline]
  pub fn event_coordinate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_EVENT_COORDINATE, None)}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind9735Parsed::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn valid(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind9735Parsed::VT_VALID, Some(false)).unwrap()}
  }
  #[inline]
  pub fn description(&self) -> ZapRequest<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ZapRequest>>(Kind9735Parsed::VT_DESCRIPTION, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind9735Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<i32>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bolt11", Self::VT_BOLT11, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preimage", Self::VT_PREIMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender", Self::VT_SENDER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event", Self::VT_EVENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_coordinate", Self::VT_EVENT_COORDINATE, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<bool>("valid", Self::VT_VALID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ZapRequest>>("description", Self::VT_DESCRIPTION, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind9735ParsedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amount: i32,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bolt11: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preimage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_coordinate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
    pub valid: bool,
    pub description: Option<flatbuffers::WIPOffset<ZapRequest<'a>>>,
}
impl<'a> Default for Kind9735ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind9735ParsedArgs {
      id: None, // required field
      amount: 0,
      content: None, // required field
      bolt11: None, // required field
      preimage: None,
      sender: None, // required field
      recipient: None, // required field
      event: None,
      event_coordinate: None,
      timestamp: 0,
      valid: false,
      description: None, // required field
    }
  }
}

pub struct Kind9735ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind9735ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_ID, id);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: i32) {
    self.fbb_.push_slot::<i32>(Kind9735Parsed::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_bolt11(&mut self, bolt11: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_BOLT11, bolt11);
  }
  #[inline]
  pub fn add_preimage(&mut self, preimage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_PREIMAGE, preimage);
  }
  #[inline]
  pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_SENDER, sender);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_EVENT, event);
  }
  #[inline]
  pub fn add_event_coordinate(&mut self, event_coordinate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_EVENT_COORDINATE, event_coordinate);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(Kind9735Parsed::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_valid(&mut self, valid: bool) {
    self.fbb_.push_slot::<bool>(Kind9735Parsed::VT_VALID, valid, false);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<ZapRequest<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ZapRequest>>(Kind9735Parsed::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind9735ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind9735ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind9735Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind9735Parsed::VT_ID,"id");
    self.fbb_.required(o, Kind9735Parsed::VT_CONTENT,"content");
    self.fbb_.required(o, Kind9735Parsed::VT_BOLT11,"bolt11");
    self.fbb_.required(o, Kind9735Parsed::VT_SENDER,"sender");
    self.fbb_.required(o, Kind9735Parsed::VT_RECIPIENT,"recipient");
    self.fbb_.required(o, Kind9735Parsed::VT_DESCRIPTION,"description");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind9735Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind9735Parsed");
      ds.field("id", &self.id());
      ds.field("amount", &self.amount());
      ds.field("content", &self.content());
      ds.field("bolt11", &self.bolt11());
      ds.field("preimage", &self.preimage());
      ds.field("sender", &self.sender());
      ds.field("recipient", &self.recipient());
      ds.field("event", &self.event());
      ds.field("event_coordinate", &self.event_coordinate());
      ds.field("timestamp", &self.timestamp());
      ds.field("valid", &self.valid());
      ds.field("description", &self.description());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind9735ParsedT {
  pub id: String,
  pub amount: i32,
  pub content: String,
  pub bolt11: String,
  pub preimage: Option<String>,
  pub sender: String,
  pub recipient: String,
  pub event: Option<String>,
  pub event_coordinate: Option<String>,
  pub timestamp: u64,
  pub valid: bool,
  pub description: Box<ZapRequestT>,
}
impl Default for Kind9735ParsedT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      amount: 0,
      content: "".to_string(),
      bolt11: "".to_string(),
      preimage: None,
      sender: "".to_string(),
      recipient: "".to_string(),
      event: None,
      event_coordinate: None,
      timestamp: 0,
      valid: false,
      description: Default::default(),
    }
  }
}
impl Kind9735ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind9735Parsed<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let amount = self.amount;
    let content = Some({
      let x = &self.content;
      _fbb.create_string(x)
    });
    let bolt11 = Some({
      let x = &self.bolt11;
      _fbb.create_string(x)
    });
    let preimage = self.preimage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sender = Some({
      let x = &self.sender;
      _fbb.create_string(x)
    });
    let recipient = Some({
      let x = &self.recipient;
      _fbb.create_string(x)
    });
    let event = self.event.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let event_coordinate = self.event_coordinate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let timestamp = self.timestamp;
    let valid = self.valid;
    let description = Some({
      let x = &self.description;
      x.pack(_fbb)
    });
    Kind9735Parsed::create(_fbb, &Kind9735ParsedArgs{
      id,
      amount,
      content,
      bolt11,
      preimage,
      sender,
      recipient,
      event,
      event_coordinate,
      timestamp,
      valid,
      description,
    })
  }
}
pub enum Kind30023ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind30023Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind30023Parsed<'a> {
  type Inner = Kind30023Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind30023Parsed<'a> {
  pub const VT_SLUG: flatbuffers::VOffsetT = 4;
  pub const VT_TITLE: flatbuffers::VOffsetT = 6;
  pub const VT_SUMMARY: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;
  pub const VT_CANONICAL: flatbuffers::VOffsetT = 12;
  pub const VT_TOPICS: flatbuffers::VOffsetT = 14;
  pub const VT_PUBLISHED_AT: flatbuffers::VOffsetT = 16;
  pub const VT_NADDR: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind30023Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind30023ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind30023Parsed<'bldr>> {
    let mut builder = Kind30023ParsedBuilder::new(_fbb);
    builder.add_published_at(args.published_at);
    if let Some(x) = args.naddr { builder.add_naddr(x); }
    if let Some(x) = args.topics { builder.add_topics(x); }
    if let Some(x) = args.canonical { builder.add_canonical(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.summary { builder.add_summary(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.slug { builder.add_slug(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind30023ParsedT {
    let slug = self.slug().map(|x| {
      x.to_string()
    });
    let title = self.title().map(|x| {
      x.to_string()
    });
    let summary = self.summary().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    let canonical = self.canonical().map(|x| {
      x.to_string()
    });
    let topics = self.topics().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let published_at = self.published_at();
    let naddr = self.naddr().map(|x| {
      x.to_string()
    });
    Kind30023ParsedT {
      slug,
      title,
      summary,
      image,
      canonical,
      topics,
      published_at,
      naddr,
    }
  }

  #[inline]
  pub fn slug(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind30023Parsed::VT_SLUG, None)}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind30023Parsed::VT_TITLE, None)}
  }
  #[inline]
  pub fn summary(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind30023Parsed::VT_SUMMARY, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind30023Parsed::VT_IMAGE, None)}
  }
  #[inline]
  pub fn canonical(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind30023Parsed::VT_CANONICAL, None)}
  }
  #[inline]
  pub fn topics(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind30023Parsed::VT_TOPICS, None)}
  }
  #[inline]
  pub fn published_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind30023Parsed::VT_PUBLISHED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn naddr(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind30023Parsed::VT_NADDR, None)}
  }
}

impl flatbuffers::Verifiable for Kind30023Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("slug", Self::VT_SLUG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("summary", Self::VT_SUMMARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("canonical", Self::VT_CANONICAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("topics", Self::VT_TOPICS, false)?
     .visit_field::<u64>("published_at", Self::VT_PUBLISHED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("naddr", Self::VT_NADDR, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind30023ParsedArgs<'a> {
    pub slug: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summary: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canonical: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub published_at: u64,
    pub naddr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind30023ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind30023ParsedArgs {
      slug: None,
      title: None,
      summary: None,
      image: None,
      canonical: None,
      topics: None,
      published_at: 0,
      naddr: None,
    }
  }
}

pub struct Kind30023ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind30023ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_slug(&mut self, slug: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind30023Parsed::VT_SLUG, slug);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind30023Parsed::VT_TITLE, title);
  }
  #[inline]
  pub fn add_summary(&mut self, summary: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind30023Parsed::VT_SUMMARY, summary);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind30023Parsed::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_canonical(&mut self, canonical: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind30023Parsed::VT_CANONICAL, canonical);
  }
  #[inline]
  pub fn add_topics(&mut self, topics: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind30023Parsed::VT_TOPICS, topics);
  }
  #[inline]
  pub fn add_published_at(&mut self, published_at: u64) {
    self.fbb_.push_slot::<u64>(Kind30023Parsed::VT_PUBLISHED_AT, published_at, 0);
  }
  #[inline]
  pub fn add_naddr(&mut self, naddr: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind30023Parsed::VT_NADDR, naddr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind30023ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind30023ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind30023Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind30023Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind30023Parsed");
      ds.field("slug", &self.slug());
      ds.field("title", &self.title());
      ds.field("summary", &self.summary());
      ds.field("image", &self.image());
      ds.field("canonical", &self.canonical());
      ds.field("topics", &self.topics());
      ds.field("published_at", &self.published_at());
      ds.field("naddr", &self.naddr());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind30023ParsedT {
  pub slug: Option<String>,
  pub title: Option<String>,
  pub summary: Option<String>,
  pub image: Option<String>,
  pub canonical: Option<String>,
  pub topics: Option<Vec<String>>,
  pub published_at: u64,
  pub naddr: Option<String>,
}
impl Default for Kind30023ParsedT {
  fn default() -> Self {
    Self {
      slug: None,
      title: None,
      summary: None,
      image: None,
      canonical: None,
      topics: None,
      published_at: 0,
      naddr: None,
    }
  }
}
impl Kind30023ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind30023Parsed<'b>> {
    let slug = self.slug.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let title = self.title.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let summary = self.summary.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let canonical = self.canonical.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let topics = self.topics.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let published_at = self.published_at;
    let naddr = self.naddr.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind30023Parsed::create(_fbb, &Kind30023ParsedArgs{
      slug,
      title,
      summary,
      image,
      canonical,
      topics,
      published_at,
      naddr,
    })
  }
}
pub enum CoordinateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Coordinate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Coordinate<'a> {
  type Inner = Coordinate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Coordinate<'a> {
  pub const VT_KIND: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_D: flatbuffers::VOffsetT = 8;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Coordinate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CoordinateArgs<'args>
  ) -> flatbuffers::WIPOffset<Coordinate<'bldr>> {
    let mut builder = CoordinateBuilder::new(_fbb);
    builder.add_kind(args.kind);
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.d { builder.add_d(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CoordinateT {
    let kind = self.kind();
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let d = {
      let x = self.d();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    CoordinateT {
      kind,
      pubkey,
      d,
      relays,
    }
  }

  #[inline]
  pub fn kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Coordinate::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Coordinate::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn d(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Coordinate::VT_D, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Coordinate::VT_RELAYS, None)}
  }
}

impl flatbuffers::Verifiable for Coordinate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("kind", Self::VT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("d", Self::VT_D, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct CoordinateArgs<'a> {
    pub kind: u64,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub d: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CoordinateArgs<'a> {
  #[inline]
  fn default() -> Self {
    CoordinateArgs {
      kind: 0,
      pubkey: None, // required field
      d: None, // required field
      relays: None,
    }
  }
}

pub struct CoordinateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CoordinateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind(&mut self, kind: u64) {
    self.fbb_.push_slot::<u64>(Coordinate::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Coordinate::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_d(&mut self, d: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Coordinate::VT_D, d);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Coordinate::VT_RELAYS, relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CoordinateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CoordinateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Coordinate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Coordinate::VT_PUBKEY,"pubkey");
    self.fbb_.required(o, Coordinate::VT_D,"d");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Coordinate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Coordinate");
      ds.field("kind", &self.kind());
      ds.field("pubkey", &self.pubkey());
      ds.field("d", &self.d());
      ds.field("relays", &self.relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CoordinateT {
  pub kind: u64,
  pub pubkey: String,
  pub d: String,
  pub relays: Option<Vec<String>>,
}
impl Default for CoordinateT {
  fn default() -> Self {
    Self {
      kind: 0,
      pubkey: "".to_string(),
      d: "".to_string(),
      relays: None,
    }
  }
}
impl CoordinateT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Coordinate<'b>> {
    let kind = self.kind;
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let d = Some({
      let x = &self.d;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    Coordinate::create(_fbb, &CoordinateArgs{
      kind,
      pubkey,
      d,
      relays,
    })
  }
}
pub enum ListParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ListParsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ListParsed<'a> {
  type Inner = ListParsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ListParsed<'a> {
  pub const VT_LIST_KIND: flatbuffers::VOffsetT = 4;
  pub const VT_D: flatbuffers::VOffsetT = 6;
  pub const VT_TITLE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 12;
  pub const VT_TOPICS: flatbuffers::VOffsetT = 14;
  pub const VT_PEOPLE: flatbuffers::VOffsetT = 16;
  pub const VT_EVENTS: flatbuffers::VOffsetT = 18;
  pub const VT_ADDRESSES: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ListParsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ListParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<ListParsed<'bldr>> {
    let mut builder = ListParsedBuilder::new(_fbb);
    if let Some(x) = args.addresses { builder.add_addresses(x); }
    if let Some(x) = args.events { builder.add_events(x); }
    if let Some(x) = args.people { builder.add_people(x); }
    if let Some(x) = args.topics { builder.add_topics(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.d { builder.add_d(x); }
    builder.add_list_kind(args.list_kind);
    builder.finish()
  }

  pub fn unpack(&self) -> ListParsedT {
    let list_kind = self.list_kind();
    let d = self.d().map(|x| {
      x.to_string()
    });
    let title = self.title().map(|x| {
      x.to_string()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    let topics = self.topics().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let people = self.people().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let events = self.events().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let addresses = self.addresses().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ListParsedT {
      list_kind,
      d,
      title,
      description,
      image,
      topics,
      people,
      events,
      addresses,
    }
  }

  #[inline]
  pub fn list_kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ListParsed::VT_LIST_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn d(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ListParsed::VT_D, None)}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ListParsed::VT_TITLE, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ListParsed::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ListParsed::VT_IMAGE, None)}
  }
  #[inline]
  pub fn topics(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ListParsed::VT_TOPICS, None)}
  }
  #[inline]
  pub fn people(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ListParsed::VT_PEOPLE, None)}
  }
  #[inline]
  pub fn events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ListParsed::VT_EVENTS, None)}
  }
  #[inline]
  pub fn addresses(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coordinate<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coordinate>>>>(ListParsed::VT_ADDRESSES, None)}
  }
}

impl flatbuffers::Verifiable for ListParsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("list_kind", Self::VT_LIST_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("d", Self::VT_D, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("topics", Self::VT_TOPICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("people", Self::VT_PEOPLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("events", Self::VT_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Coordinate>>>>("addresses", Self::VT_ADDRESSES, false)?
     .finish();
    Ok(())
  }
}
pub struct ListParsedArgs<'a> {
    pub list_kind: u16,
    pub d: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub people: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub addresses: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coordinate<'a>>>>>,
}
impl<'a> Default for ListParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    ListParsedArgs {
      list_kind: 0,
      d: None,
      title: None,
      description: None,
      image: None,
      topics: None,
      people: None,
      events: None,
      addresses: None,
    }
  }
}

pub struct ListParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ListParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_list_kind(&mut self, list_kind: u16) {
    self.fbb_.push_slot::<u16>(ListParsed::VT_LIST_KIND, list_kind, 0);
  }
  #[inline]
  pub fn add_d(&mut self, d: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_D, d);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_TITLE, title);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_topics(&mut self, topics: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_TOPICS, topics);
  }
  #[inline]
  pub fn add_people(&mut self, people: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_PEOPLE, people);
  }
  #[inline]
  pub fn add_events(&mut self, events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_EVENTS, events);
  }
  #[inline]
  pub fn add_addresses(&mut self, addresses: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Coordinate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ListParsed::VT_ADDRESSES, addresses);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ListParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ListParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ListParsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ListParsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ListParsed");
      ds.field("list_kind", &self.list_kind());
      ds.field("d", &self.d());
      ds.field("title", &self.title());
      ds.field("description", &self.description());
      ds.field("image", &self.image());
      ds.field("topics", &self.topics());
      ds.field("people", &self.people());
      ds.field("events", &self.events());
      ds.field("addresses", &self.addresses());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ListParsedT {
  pub list_kind: u16,
  pub d: Option<String>,
  pub title: Option<String>,
  pub description: Option<String>,
  pub image: Option<String>,
  pub topics: Option<Vec<String>>,
  pub people: Option<Vec<String>>,
  pub events: Option<Vec<String>>,
  pub addresses: Option<Vec<CoordinateT>>,
}
impl Default for ListParsedT {
  fn default() -> Self {
    Self {
      list_kind: 0,
      d: None,
      title: None,
      description: None,
      image: None,
      topics: None,
      people: None,
      events: None,
      addresses: None,
    }
  }
}
impl ListParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ListParsed<'b>> {
    let list_kind = self.list_kind;
    let d = self.d.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let title = self.title.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let topics = self.topics.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let people = self.people.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let events = self.events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let addresses = self.addresses.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ListParsed::create(_fbb, &ListParsedArgs{
      list_kind,
      d,
      title,
      description,
      image,
      topics,
      people,
      events,
      addresses,
    })
  }
}
pub enum PreParticipantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PreParticipant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PreParticipant<'a> {
  type Inner = PreParticipant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PreParticipant<'a> {
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
  pub const VT_RELAY: flatbuffers::VOffsetT = 6;
  pub const VT_ROLE: flatbuffers::VOffsetT = 8;
  pub const VT_PROOF: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PreParticipant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PreParticipantArgs<'args>
  ) -> flatbuffers::WIPOffset<PreParticipant<'bldr>> {
    let mut builder = PreParticipantBuilder::new(_fbb);
    if let Some(x) = args.proof { builder.add_proof(x); }
    if let Some(x) = args.role { builder.add_role(x); }
    if let Some(x) = args.relay { builder.add_relay(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PreParticipantT {
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let relay = self.relay().map(|x| {
      x.to_string()
    });
    let role = self.role().map(|x| {
      x.to_string()
    });
    let proof = self.proof().map(|x| {
      x.to_string()
    });
    PreParticipantT {
      pubkey,
      relay,
      role,
      proof,
    }
  }

  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreParticipant::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn relay(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreParticipant::VT_RELAY, None)}
  }
  #[inline]
  pub fn role(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreParticipant::VT_ROLE, None)}
  }
  #[inline]
  pub fn proof(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreParticipant::VT_PROOF, None)}
  }
}

impl flatbuffers::Verifiable for PreParticipant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relay", Self::VT_RELAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("role", Self::VT_ROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("proof", Self::VT_PROOF, false)?
     .finish();
    Ok(())
  }
}
pub struct PreParticipantArgs<'a> {
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relay: Option<flatbuffers::WIPOffset<&'a str>>,
    pub role: Option<flatbuffers::WIPOffset<&'a str>>,
    pub proof: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PreParticipantArgs<'a> {
  #[inline]
  fn default() -> Self {
    PreParticipantArgs {
      pubkey: None, // required field
      relay: None,
      role: None,
      proof: None,
    }
  }
}

pub struct PreParticipantBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PreParticipantBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreParticipant::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_relay(&mut self, relay: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreParticipant::VT_RELAY, relay);
  }
  #[inline]
  pub fn add_role(&mut self, role: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreParticipant::VT_ROLE, role);
  }
  #[inline]
  pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreParticipant::VT_PROOF, proof);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PreParticipantBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PreParticipantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PreParticipant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PreParticipant::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PreParticipant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PreParticipant");
      ds.field("pubkey", &self.pubkey());
      ds.field("relay", &self.relay());
      ds.field("role", &self.role());
      ds.field("proof", &self.proof());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PreParticipantT {
  pub pubkey: String,
  pub relay: Option<String>,
  pub role: Option<String>,
  pub proof: Option<String>,
}
impl Default for PreParticipantT {
  fn default() -> Self {
    Self {
      pubkey: "".to_string(),
      relay: None,
      role: None,
      proof: None,
    }
  }
}
impl PreParticipantT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PreParticipant<'b>> {
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let relay = self.relay.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let role = self.role.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let proof = self.proof.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    PreParticipant::create(_fbb, &PreParticipantArgs{
      pubkey,
      relay,
      role,
      proof,
    })
  }
}
pub enum PreRefEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PreRefEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PreRefEvent<'a> {
  type Inner = PreRefEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PreRefEvent<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_RELAY: flatbuffers::VOffsetT = 6;
  pub const VT_MARKER: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PreRefEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PreRefEventArgs<'args>
  ) -> flatbuffers::WIPOffset<PreRefEvent<'bldr>> {
    let mut builder = PreRefEventBuilder::new(_fbb);
    if let Some(x) = args.marker { builder.add_marker(x); }
    if let Some(x) = args.relay { builder.add_relay(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PreRefEventT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let relay = self.relay().map(|x| {
      x.to_string()
    });
    let marker = self.marker().map(|x| {
      x.to_string()
    });
    PreRefEventT {
      id,
      relay,
      marker,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreRefEvent::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn relay(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreRefEvent::VT_RELAY, None)}
  }
  #[inline]
  pub fn marker(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreRefEvent::VT_MARKER, None)}
  }
}

impl flatbuffers::Verifiable for PreRefEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relay", Self::VT_RELAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("marker", Self::VT_MARKER, false)?
     .finish();
    Ok(())
  }
}
pub struct PreRefEventArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relay: Option<flatbuffers::WIPOffset<&'a str>>,
    pub marker: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PreRefEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    PreRefEventArgs {
      id: None, // required field
      relay: None,
      marker: None,
    }
  }
}

pub struct PreRefEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PreRefEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreRefEvent::VT_ID, id);
  }
  #[inline]
  pub fn add_relay(&mut self, relay: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreRefEvent::VT_RELAY, relay);
  }
  #[inline]
  pub fn add_marker(&mut self, marker: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreRefEvent::VT_MARKER, marker);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PreRefEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PreRefEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PreRefEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PreRefEvent::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PreRefEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PreRefEvent");
      ds.field("id", &self.id());
      ds.field("relay", &self.relay());
      ds.field("marker", &self.marker());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PreRefEventT {
  pub id: String,
  pub relay: Option<String>,
  pub marker: Option<String>,
}
impl Default for PreRefEventT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      relay: None,
      marker: None,
    }
  }
}
impl PreRefEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PreRefEvent<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let relay = self.relay.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let marker = self.marker.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    PreRefEvent::create(_fbb, &PreRefEventArgs{
      id,
      relay,
      marker,
    })
  }
}
pub enum PreGenericParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PreGenericParsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PreGenericParsed<'a> {
  type Inner = PreGenericParsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PreGenericParsed<'a> {
  pub const VT_KIND: flatbuffers::VOffsetT = 4;
  pub const VT_D: flatbuffers::VOffsetT = 6;
  pub const VT_TITLE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 12;
  pub const VT_STREAMING: flatbuffers::VOffsetT = 14;
  pub const VT_RECORDING: flatbuffers::VOffsetT = 16;
  pub const VT_SERVICE: flatbuffers::VOffsetT = 18;
  pub const VT_ENDPOINT: flatbuffers::VOffsetT = 20;
  pub const VT_ROOM: flatbuffers::VOffsetT = 22;
  pub const VT_STATUS: flatbuffers::VOffsetT = 24;
  pub const VT_STARTS: flatbuffers::VOffsetT = 26;
  pub const VT_ENDS: flatbuffers::VOffsetT = 28;
  pub const VT_CURRENT_PARTICIPANTS: flatbuffers::VOffsetT = 30;
  pub const VT_TOTAL_PARTICIPANTS: flatbuffers::VOffsetT = 32;
  pub const VT_PINNED: flatbuffers::VOffsetT = 34;
  pub const VT_TOPICS: flatbuffers::VOffsetT = 36;
  pub const VT_LINKS: flatbuffers::VOffsetT = 38;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 40;
  pub const VT_PARTICIPANTS: flatbuffers::VOffsetT = 42;
  pub const VT_EVENTS: flatbuffers::VOffsetT = 44;
  pub const VT_ADDRESSES: flatbuffers::VOffsetT = 46;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PreGenericParsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PreGenericParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<PreGenericParsed<'bldr>> {
    let mut builder = PreGenericParsedBuilder::new(_fbb);
    builder.add_total_participants(args.total_participants);
    builder.add_current_participants(args.current_participants);
    builder.add_ends(args.ends);
    builder.add_starts(args.starts);
    if let Some(x) = args.addresses { builder.add_addresses(x); }
    if let Some(x) = args.events { builder.add_events(x); }
    if let Some(x) = args.participants { builder.add_participants(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.links { builder.add_links(x); }
    if let Some(x) = args.topics { builder.add_topics(x); }
    if let Some(x) = args.pinned { builder.add_pinned(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.room { builder.add_room(x); }
    if let Some(x) = args.endpoint { builder.add_endpoint(x); }
    if let Some(x) = args.service { builder.add_service(x); }
    if let Some(x) = args.recording { builder.add_recording(x); }
    if let Some(x) = args.streaming { builder.add_streaming(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.d { builder.add_d(x); }
    builder.add_kind(args.kind);
    builder.finish()
  }

  pub fn unpack(&self) -> PreGenericParsedT {
    let kind = self.kind();
    let d = self.d().map(|x| {
      x.to_string()
    });
    let title = self.title().map(|x| {
      x.to_string()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    let streaming = self.streaming().map(|x| {
      x.to_string()
    });
    let recording = self.recording().map(|x| {
      x.to_string()
    });
    let service = self.service().map(|x| {
      x.to_string()
    });
    let endpoint = self.endpoint().map(|x| {
      x.to_string()
    });
    let room = self.room().map(|x| {
      x.to_string()
    });
    let status = self.status().map(|x| {
      x.to_string()
    });
    let starts = self.starts();
    let ends = self.ends();
    let current_participants = self.current_participants();
    let total_participants = self.total_participants();
    let pinned = self.pinned().map(|x| {
      x.to_string()
    });
    let topics = self.topics().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let links = self.links().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let participants = self.participants().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let events = self.events().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let addresses = self.addresses().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    PreGenericParsedT {
      kind,
      d,
      title,
      description,
      image,
      streaming,
      recording,
      service,
      endpoint,
      room,
      status,
      starts,
      ends,
      current_participants,
      total_participants,
      pinned,
      topics,
      links,
      relays,
      participants,
      events,
      addresses,
    }
  }

  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PreGenericParsed::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn d(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_D, None)}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_TITLE, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_IMAGE, None)}
  }
  #[inline]
  pub fn streaming(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_STREAMING, None)}
  }
  #[inline]
  pub fn recording(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_RECORDING, None)}
  }
  #[inline]
  pub fn service(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_SERVICE, None)}
  }
  #[inline]
  pub fn endpoint(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_ENDPOINT, None)}
  }
  #[inline]
  pub fn room(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_ROOM, None)}
  }
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_STATUS, None)}
  }
  #[inline]
  pub fn starts(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PreGenericParsed::VT_STARTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ends(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PreGenericParsed::VT_ENDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn current_participants(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PreGenericParsed::VT_CURRENT_PARTICIPANTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total_participants(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PreGenericParsed::VT_TOTAL_PARTICIPANTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pinned(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreGenericParsed::VT_PINNED, None)}
  }
  #[inline]
  pub fn topics(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PreGenericParsed::VT_TOPICS, None)}
  }
  #[inline]
  pub fn links(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PreGenericParsed::VT_LINKS, None)}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PreGenericParsed::VT_RELAYS, None)}
  }
  #[inline]
  pub fn participants(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreParticipant<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreParticipant>>>>(PreGenericParsed::VT_PARTICIPANTS, None)}
  }
  #[inline]
  pub fn events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreRefEvent<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreRefEvent>>>>(PreGenericParsed::VT_EVENTS, None)}
  }
  #[inline]
  pub fn addresses(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coordinate<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coordinate>>>>(PreGenericParsed::VT_ADDRESSES, None)}
  }
}

impl flatbuffers::Verifiable for PreGenericParsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("d", Self::VT_D, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("streaming", Self::VT_STREAMING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recording", Self::VT_RECORDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("service", Self::VT_SERVICE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endpoint", Self::VT_ENDPOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("room", Self::VT_ROOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<u64>("starts", Self::VT_STARTS, false)?
     .visit_field::<u64>("ends", Self::VT_ENDS, false)?
     .visit_field::<u64>("current_participants", Self::VT_CURRENT_PARTICIPANTS, false)?
     .visit_field::<u64>("total_participants", Self::VT_TOTAL_PARTICIPANTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pinned", Self::VT_PINNED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("topics", Self::VT_TOPICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("links", Self::VT_LINKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PreParticipant>>>>("participants", Self::VT_PARTICIPANTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PreRefEvent>>>>("events", Self::VT_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Coordinate>>>>("addresses", Self::VT_ADDRESSES, false)?
     .finish();
    Ok(())
  }
}
pub struct PreGenericParsedArgs<'a> {
    pub kind: u16,
    pub d: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub streaming: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recording: Option<flatbuffers::WIPOffset<&'a str>>,
    pub service: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endpoint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub room: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub starts: u64,
    pub ends: u64,
    pub current_participants: u64,
    pub total_participants: u64,
    pub pinned: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub links: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub participants: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreParticipant<'a>>>>>,
    pub events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreRefEvent<'a>>>>>,
    pub addresses: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coordinate<'a>>>>>,
}
impl<'a> Default for PreGenericParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    PreGenericParsedArgs {
      kind: 0,
      d: None,
      title: None,
      description: None,
      image: None,
      streaming: None,
      recording: None,
      service: None,
      endpoint: None,
      room: None,
      status: None,
      starts: 0,
      ends: 0,
      current_participants: 0,
      total_participants: 0,
      pinned: None,
      topics: None,
      links: None,
      relays: None,
      participants: None,
      events: None,
      addresses: None,
    }
  }
}

pub struct PreGenericParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PreGenericParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(PreGenericParsed::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_d(&mut self, d: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_D, d);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_TITLE, title);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_streaming(&mut self, streaming: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_STREAMING, streaming);
  }
  #[inline]
  pub fn add_recording(&mut self, recording: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_RECORDING, recording);
  }
  #[inline]
  pub fn add_service(&mut self, service: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_SERVICE, service);
  }
  #[inline]
  pub fn add_endpoint(&mut self, endpoint: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_ENDPOINT, endpoint);
  }
  #[inline]
  pub fn add_room(&mut self, room: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_ROOM, room);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_STATUS, status);
  }
  #[inline]
  pub fn add_starts(&mut self, starts: u64) {
    self.fbb_.push_slot::<u64>(PreGenericParsed::VT_STARTS, starts, 0);
  }
  #[inline]
  pub fn add_ends(&mut self, ends: u64) {
    self.fbb_.push_slot::<u64>(PreGenericParsed::VT_ENDS, ends, 0);
  }
  #[inline]
  pub fn add_current_participants(&mut self, current_participants: u64) {
    self.fbb_.push_slot::<u64>(PreGenericParsed::VT_CURRENT_PARTICIPANTS, current_participants, 0);
  }
  #[inline]
  pub fn add_total_participants(&mut self, total_participants: u64) {
    self.fbb_.push_slot::<u64>(PreGenericParsed::VT_TOTAL_PARTICIPANTS, total_participants, 0);
  }
  #[inline]
  pub fn add_pinned(&mut self, pinned: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_PINNED, pinned);
  }
  #[inline]
  pub fn add_topics(&mut self, topics: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_TOPICS, topics);
  }
  #[inline]
  pub fn add_links(&mut self, links: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_LINKS, links);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_participants(&mut self, participants: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PreParticipant<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_PARTICIPANTS, participants);
  }
  #[inline]
  pub fn add_events(&mut self, events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PreRefEvent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_EVENTS, events);
  }
  #[inline]
  pub fn add_addresses(&mut self, addresses: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Coordinate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreGenericParsed::VT_ADDRESSES, addresses);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PreGenericParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PreGenericParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PreGenericParsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PreGenericParsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PreGenericParsed");
      ds.field("kind", &self.kind());
      ds.field("d", &self.d());
      ds.field("title", &self.title());
      ds.field("description", &self.description());
      ds.field("image", &self.image());
      ds.field("streaming", &self.streaming());
      ds.field("recording", &self.recording());
      ds.field("service", &self.service());
      ds.field("endpoint", &self.endpoint());
      ds.field("room", &self.room());
      ds.field("status", &self.status());
      ds.field("starts", &self.starts());
      ds.field("ends", &self.ends());
      ds.field("current_participants", &self.current_participants());
      ds.field("total_participants", &self.total_participants());
      ds.field("pinned", &self.pinned());
      ds.field("topics", &self.topics());
      ds.field("links", &self.links());
      ds.field("relays", &self.relays());
      ds.field("participants", &self.participants());
      ds.field("events", &self.events());
      ds.field("addresses", &self.addresses());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PreGenericParsedT {
  pub kind: u16,
  pub d: Option<String>,
  pub title: Option<String>,
  pub description: Option<String>,
  pub image: Option<String>,
  pub streaming: Option<String>,
  pub recording: Option<String>,
  pub service: Option<String>,
  pub endpoint: Option<String>,
  pub room: Option<String>,
  pub status: Option<String>,
  pub starts: u64,
  pub ends: u64,
  pub current_participants: u64,
  pub total_participants: u64,
  pub pinned: Option<String>,
  pub topics: Option<Vec<String>>,
  pub links: Option<Vec<String>>,
  pub relays: Option<Vec<String>>,
  pub participants: Option<Vec<PreParticipantT>>,
  pub events: Option<Vec<PreRefEventT>>,
  pub addresses: Option<Vec<CoordinateT>>,
}
impl Default for PreGenericParsedT {
  fn default() -> Self {
    Self {
      kind: 0,
      d: None,
      title: None,
      description: None,
      image: None,
      streaming: None,
      recording: None,
      service: None,
      endpoint: None,
      room: None,
      status: None,
      starts: 0,
      ends: 0,
      current_participants: 0,
      total_participants: 0,
      pinned: None,
      topics: None,
      links: None,
      relays: None,
      participants: None,
      events: None,
      addresses: None,
    }
  }
}
impl PreGenericParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PreGenericParsed<'b>> {
    let kind = self.kind;
    let d = self.d.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let title = self.title.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let streaming = self.streaming.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let recording = self.recording.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let service = self.service.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let endpoint = self.endpoint.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let room = self.room.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let status = self.status.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let starts = self.starts;
    let ends = self.ends;
    let current_participants = self.current_participants;
    let total_participants = self.total_participants;
    let pinned = self.pinned.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let topics = self.topics.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let links = self.links.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let participants = self.participants.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let events = self.events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let addresses = self.addresses.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    PreGenericParsed::create(_fbb, &PreGenericParsedArgs{
      kind,
      d,
      title,
      description,
      image,
      streaming,
      recording,
      service,
      endpoint,
      room,
      status,
      starts,
      ends,
      current_participants,
      total_participants,
      pinned,
      topics,
      links,
      relays,
      participants,
      events,
      addresses,
    })
  }
}
pub enum ParsedEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ParsedEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParsedEvent<'a> {
  type Inner = ParsedEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParsedEvent<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_KIND: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 10;
  pub const VT_PARSED_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_PARSED: flatbuffers::VOffsetT = 14;
  pub const VT_REQUESTS: flatbuffers::VOffsetT = 16;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 18;
  pub const VT_TAGS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParsedEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParsedEventArgs<'args>
  ) -> flatbuffers::WIPOffset<ParsedEvent<'bldr>> {
    let mut builder = ParsedEventBuilder::new(_fbb);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.requests { builder.add_requests(x); }
    if let Some(x) = args.parsed { builder.add_parsed(x); }
    builder.add_created_at(args.created_at);
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_kind(args.kind);
    builder.add_parsed_type(args.parsed_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ParsedEventT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let kind = self.kind();
    let created_at = self.created_at();
    let parsed = match self.parsed_type() {
      ParsedData::NONE => ParsedDataT::NONE,
      ParsedData::Kind0Parsed => ParsedDataT::Kind0Parsed(Box::new(
        self.parsed_as_kind_0_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind0Parsed`.")
            .unpack()
      )),
      ParsedData::Kind1Parsed => ParsedDataT::Kind1Parsed(Box::new(
        self.parsed_as_kind_1_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind1Parsed`.")
            .unpack()
      )),
      ParsedData::Kind3Parsed => ParsedDataT::Kind3Parsed(Box::new(
        self.parsed_as_kind_3_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind3Parsed`.")
            .unpack()
      )),
      ParsedData::Kind4Parsed => ParsedDataT::Kind4Parsed(Box::new(
        self.parsed_as_kind_4_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind4Parsed`.")
            .unpack()
      )),
      ParsedData::Kind6Parsed => ParsedDataT::Kind6Parsed(Box::new(
        self.parsed_as_kind_6_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind6Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7Parsed => ParsedDataT::Kind7Parsed(Box::new(
        self.parsed_as_kind_7_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7Parsed`.")
            .unpack()
      )),
      ParsedData::Kind17Parsed => ParsedDataT::Kind17Parsed(Box::new(
        self.parsed_as_kind_17_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind17Parsed`.")
            .unpack()
      )),
      ParsedData::Kind10002Parsed => ParsedDataT::Kind10002Parsed(Box::new(
        self.parsed_as_kind_10002_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind10002Parsed`.")
            .unpack()
      )),
      ParsedData::Kind10019Parsed => ParsedDataT::Kind10019Parsed(Box::new(
        self.parsed_as_kind_10019_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind10019Parsed`.")
            .unpack()
      )),
      ParsedData::Kind17375Parsed => ParsedDataT::Kind17375Parsed(Box::new(
        self.parsed_as_kind_17375_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind17375Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7374Parsed => ParsedDataT::Kind7374Parsed(Box::new(
        self.parsed_as_kind_7374_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7374Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7375Parsed => ParsedDataT::Kind7375Parsed(Box::new(
        self.parsed_as_kind_7375_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7375Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7376Parsed => ParsedDataT::Kind7376Parsed(Box::new(
        self.parsed_as_kind_7376_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7376Parsed`.")
            .unpack()
      )),
      ParsedData::Kind9321Parsed => ParsedDataT::Kind9321Parsed(Box::new(
        self.parsed_as_kind_9321_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind9321Parsed`.")
            .unpack()
      )),
      ParsedData::Kind9735Parsed => ParsedDataT::Kind9735Parsed(Box::new(
        self.parsed_as_kind_9735_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind9735Parsed`.")
            .unpack()
      )),
      ParsedData::Kind30023Parsed => ParsedDataT::Kind30023Parsed(Box::new(
        self.parsed_as_kind_30023_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind30023Parsed`.")
            .unpack()
      )),
      ParsedData::ListParsed => ParsedDataT::ListParsed(Box::new(
        self.parsed_as_list_parsed()
            .expect("Invalid union table, expected `ParsedData::ListParsed`.")
            .unpack()
      )),
      ParsedData::PreGenericParsed => ParsedDataT::PreGenericParsed(Box::new(
        self.parsed_as_pre_generic_parsed()
            .expect("Invalid union table, expected `ParsedData::PreGenericParsed`.")
            .unpack()
      )),
      _ => ParsedDataT::NONE,
    };
    let requests = self.requests().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tags = {
      let x = self.tags();
      x.iter().map(|t| t.unpack()).collect()
    };
    ParsedEventT {
      id,
      pubkey,
      kind,
      created_at,
      parsed,
      requests,
      relays,
      tags,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParsedEvent::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParsedEvent::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ParsedEvent::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ParsedEvent::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn parsed_type(&self) -> ParsedData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParsedData>(ParsedEvent::VT_PARSED_TYPE, Some(ParsedData::NONE)).unwrap()}
  }
  #[inline]
  pub fn parsed(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ParsedEvent::VT_PARSED, None)}
  }
  #[inline]
  pub fn requests(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request>>>>(ParsedEvent::VT_REQUESTS, None)}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ParsedEvent::VT_RELAYS, None)}
  }
  #[inline]
  pub fn tags(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(ParsedEvent::VT_TAGS, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_0_parsed(&self) -> Option<Kind0Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind0Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind0Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_1_parsed(&self) -> Option<Kind1Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind1Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind1Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_3_parsed(&self) -> Option<Kind3Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind3Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind3Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_4_parsed(&self) -> Option<Kind4Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind4Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind4Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_6_parsed(&self) -> Option<Kind6Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind6Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind6Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7_parsed(&self) -> Option<Kind7Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_17_parsed(&self) -> Option<Kind17Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind17Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind17Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_10002_parsed(&self) -> Option<Kind10002Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind10002Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind10002Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_10019_parsed(&self) -> Option<Kind10019Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind10019Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind10019Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_17375_parsed(&self) -> Option<Kind17375Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind17375Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind17375Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7374_parsed(&self) -> Option<Kind7374Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7374Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7374Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7375_parsed(&self) -> Option<Kind7375Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7375Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7375Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7376_parsed(&self) -> Option<Kind7376Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7376Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7376Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_9321_parsed(&self) -> Option<Kind9321Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind9321Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind9321Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_9735_parsed(&self) -> Option<Kind9735Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind9735Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind9735Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_30023_parsed(&self) -> Option<Kind30023Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind30023Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind30023Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_list_parsed(&self) -> Option<ListParsed<'a>> {
    if self.parsed_type() == ParsedData::ListParsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ListParsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_pre_generic_parsed(&self) -> Option<PreGenericParsed<'a>> {
    if self.parsed_type() == ParsedData::PreGenericParsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PreGenericParsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ParsedEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<u32>("created_at", Self::VT_CREATED_AT, false)?
     .visit_union::<ParsedData, _>("parsed_type", Self::VT_PARSED_TYPE, "parsed", Self::VT_PARSED, false, |key, v, pos| {
        match key {
          ParsedData::Kind0Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind0Parsed>>("ParsedData::Kind0Parsed", pos),
          ParsedData::Kind1Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind1Parsed>>("ParsedData::Kind1Parsed", pos),
          ParsedData::Kind3Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind3Parsed>>("ParsedData::Kind3Parsed", pos),
          ParsedData::Kind4Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind4Parsed>>("ParsedData::Kind4Parsed", pos),
          ParsedData::Kind6Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind6Parsed>>("ParsedData::Kind6Parsed", pos),
          ParsedData::Kind7Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7Parsed>>("ParsedData::Kind7Parsed", pos),
          ParsedData::Kind17Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind17Parsed>>("ParsedData::Kind17Parsed", pos),
          ParsedData::Kind10002Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind10002Parsed>>("ParsedData::Kind10002Parsed", pos),
          ParsedData::Kind10019Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind10019Parsed>>("ParsedData::Kind10019Parsed", pos),
          ParsedData::Kind17375Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind17375Parsed>>("ParsedData::Kind17375Parsed", pos),
          ParsedData::Kind7374Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7374Parsed>>("ParsedData::Kind7374Parsed", pos),
          ParsedData::Kind7375Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7375Parsed>>("ParsedData::Kind7375Parsed", pos),
          ParsedData::Kind7376Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7376Parsed>>("ParsedData::Kind7376Parsed", pos),
          ParsedData::Kind9321Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind9321Parsed>>("ParsedData::Kind9321Parsed", pos),
          ParsedData::Kind9735Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind9735Parsed>>("ParsedData::Kind9735Parsed", pos),
          ParsedData::Kind30023Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind30023Parsed>>("ParsedData::Kind30023Parsed", pos),
          ParsedData::ListParsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ListParsed>>("ParsedData::ListParsed", pos),
          ParsedData::PreGenericParsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PreGenericParsed>>("ParsedData::PreGenericParsed", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Request>>>>("requests", Self::VT_REQUESTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, true)?
     .finish();
    Ok(())
  }
}
pub struct ParsedEventArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u16,
    pub created_at: u32,
    pub parsed_type: ParsedData,
    pub parsed: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub requests: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
}
impl<'a> Default for ParsedEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParsedEventArgs {
      id: None, // required field
      pubkey: None, // required field
      kind: 0,
      created_at: 0,
      parsed_type: ParsedData::NONE,
      parsed: None,
      requests: None,
      relays: None,
      tags: None, // required field
    }
  }
}

pub struct ParsedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParsedEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_ID, id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(ParsedEvent::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: u32) {
    self.fbb_.push_slot::<u32>(ParsedEvent::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_parsed_type(&mut self, parsed_type: ParsedData) {
    self.fbb_.push_slot::<ParsedData>(ParsedEvent::VT_PARSED_TYPE, parsed_type, ParsedData::NONE);
  }
  #[inline]
  pub fn add_parsed(&mut self, parsed: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_PARSED, parsed);
  }
  #[inline]
  pub fn add_requests(&mut self, requests: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Request<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_REQUESTS, requests);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_TAGS, tags);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParsedEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParsedEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParsedEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ParsedEvent::VT_ID,"id");
    self.fbb_.required(o, ParsedEvent::VT_PUBKEY,"pubkey");
    self.fbb_.required(o, ParsedEvent::VT_TAGS,"tags");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParsedEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParsedEvent");
      ds.field("id", &self.id());
      ds.field("pubkey", &self.pubkey());
      ds.field("kind", &self.kind());
      ds.field("created_at", &self.created_at());
      ds.field("parsed_type", &self.parsed_type());
      match self.parsed_type() {
        ParsedData::Kind0Parsed => {
          if let Some(x) = self.parsed_as_kind_0_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind1Parsed => {
          if let Some(x) = self.parsed_as_kind_1_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind3Parsed => {
          if let Some(x) = self.parsed_as_kind_3_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind4Parsed => {
          if let Some(x) = self.parsed_as_kind_4_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind6Parsed => {
          if let Some(x) = self.parsed_as_kind_6_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7Parsed => {
          if let Some(x) = self.parsed_as_kind_7_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind17Parsed => {
          if let Some(x) = self.parsed_as_kind_17_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind10002Parsed => {
          if let Some(x) = self.parsed_as_kind_10002_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind10019Parsed => {
          if let Some(x) = self.parsed_as_kind_10019_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind17375Parsed => {
          if let Some(x) = self.parsed_as_kind_17375_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7374Parsed => {
          if let Some(x) = self.parsed_as_kind_7374_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7375Parsed => {
          if let Some(x) = self.parsed_as_kind_7375_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7376Parsed => {
          if let Some(x) = self.parsed_as_kind_7376_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind9321Parsed => {
          if let Some(x) = self.parsed_as_kind_9321_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind9735Parsed => {
          if let Some(x) = self.parsed_as_kind_9735_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind30023Parsed => {
          if let Some(x) = self.parsed_as_kind_30023_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::ListParsed => {
          if let Some(x) = self.parsed_as_list_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::PreGenericParsed => {
          if let Some(x) = self.parsed_as_pre_generic_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("parsed", &x)
        },
      };
      ds.field("requests", &self.requests());
      ds.field("relays", &self.relays());
      ds.field("tags", &self.tags());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParsedEventT {
  pub id: String,
  pub pubkey: String,
  pub kind: u16,
  pub created_at: u32,
  pub parsed: ParsedDataT,
  pub requests: Option<Vec<RequestT>>,
  pub relays: Option<Vec<String>>,
  pub tags: Vec<StringVecT>,
}
impl Default for ParsedEventT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      pubkey: "".to_string(),
      kind: 0,
      created_at: 0,
      parsed: ParsedDataT::NONE,
      requests: None,
      relays: None,
      tags: Default::default(),
    }
  }
}
impl ParsedEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParsedEvent<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let kind = self.kind;
    let created_at = self.created_at;
    let parsed_type = self.parsed.parsed_data_type();
    let parsed = self.parsed.pack(_fbb);
    let requests = self.requests.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tags = Some({
      let x = &self.tags;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ParsedEvent::create(_fbb, &ParsedEventArgs{
      id,
      pubkey,
      kind,
      created_at,
      parsed_type,
      parsed,
      requests,
      relays,
      tags,
    })
  }
}
pub enum ConnectionStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConnectionStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConnectionStatus<'a> {
  type Inner = ConnectionStatus<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConnectionStatus<'a> {
  pub const VT_RELAY_URL: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConnectionStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConnectionStatusArgs<'args>
  ) -> flatbuffers::WIPOffset<ConnectionStatus<'bldr>> {
    let mut builder = ConnectionStatusBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.relay_url { builder.add_relay_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ConnectionStatusT {
    let relay_url = {
      let x = self.relay_url();
      x.to_string()
    };
    let status = {
      let x = self.status();
      x.to_string()
    };
    let message = self.message().map(|x| {
      x.to_string()
    });
    ConnectionStatusT {
      relay_url,
      status,
      message,
    }
  }

  #[inline]
  pub fn relay_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionStatus::VT_RELAY_URL, None).unwrap()}
  }
  #[inline]
  pub fn status(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionStatus::VT_STATUS, None).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionStatus::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for ConnectionStatus<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relay_url", Self::VT_RELAY_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct ConnectionStatusArgs<'a> {
    pub relay_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ConnectionStatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConnectionStatusArgs {
      relay_url: None, // required field
      status: None, // required field
      message: None,
    }
  }
}

pub struct ConnectionStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConnectionStatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_relay_url(&mut self, relay_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionStatus::VT_RELAY_URL, relay_url);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionStatus::VT_STATUS, status);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionStatus::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConnectionStatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConnectionStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConnectionStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ConnectionStatus::VT_RELAY_URL,"relay_url");
    self.fbb_.required(o, ConnectionStatus::VT_STATUS,"status");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConnectionStatus<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConnectionStatus");
      ds.field("relay_url", &self.relay_url());
      ds.field("status", &self.status());
      ds.field("message", &self.message());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConnectionStatusT {
  pub relay_url: String,
  pub status: String,
  pub message: Option<String>,
}
impl Default for ConnectionStatusT {
  fn default() -> Self {
    Self {
      relay_url: "".to_string(),
      status: "".to_string(),
      message: None,
    }
  }
}
impl ConnectionStatusT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ConnectionStatus<'b>> {
    let relay_url = Some({
      let x = &self.relay_url;
      _fbb.create_string(x)
    });
    let status = Some({
      let x = &self.status;
      _fbb.create_string(x)
    });
    let message = self.message.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ConnectionStatus::create(_fbb, &ConnectionStatusArgs{
      relay_url,
      status,
      message,
    })
  }
}
pub enum CountResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CountResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CountResponse<'a> {
  type Inner = CountResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CountResponse<'a> {
  pub const VT_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_KIND: flatbuffers::VOffsetT = 6;
  pub const VT_YOU: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CountResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CountResponseArgs
  ) -> flatbuffers::WIPOffset<CountResponse<'bldr>> {
    let mut builder = CountResponseBuilder::new(_fbb);
    builder.add_count(args.count);
    builder.add_kind(args.kind);
    builder.add_you(args.you);
    builder.finish()
  }

  pub fn unpack(&self) -> CountResponseT {
    let count = self.count();
    let kind = self.kind();
    let you = self.you();
    CountResponseT {
      count,
      kind,
      you,
    }
  }

  #[inline]
  pub fn count(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CountResponse::VT_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(CountResponse::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn you(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CountResponse::VT_YOU, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CountResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("count", Self::VT_COUNT, false)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<bool>("you", Self::VT_YOU, false)?
     .finish();
    Ok(())
  }
}
pub struct CountResponseArgs {
    pub count: u32,
    pub kind: u16,
    pub you: bool,
}
impl<'a> Default for CountResponseArgs {
  #[inline]
  fn default() -> Self {
    CountResponseArgs {
      count: 0,
      kind: 0,
      you: false,
    }
  }
}

pub struct CountResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CountResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_count(&mut self, count: u32) {
    self.fbb_.push_slot::<u32>(CountResponse::VT_COUNT, count, 0);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(CountResponse::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_you(&mut self, you: bool) {
    self.fbb_.push_slot::<bool>(CountResponse::VT_YOU, you, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CountResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CountResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CountResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CountResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CountResponse");
      ds.field("count", &self.count());
      ds.field("kind", &self.kind());
      ds.field("you", &self.you());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CountResponseT {
  pub count: u32,
  pub kind: u16,
  pub you: bool,
}
impl Default for CountResponseT {
  fn default() -> Self {
    Self {
      count: 0,
      kind: 0,
      you: false,
    }
  }
}
impl CountResponseT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CountResponse<'b>> {
    let count = self.count;
    let kind = self.kind;
    let you = self.you;
    CountResponse::create(_fbb, &CountResponseArgs{
      count,
      kind,
      you,
    })
  }
}
pub enum EoceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Eoce<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Eoce<'a> {
  type Inner = Eoce<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Eoce<'a> {
  pub const VT_SUBSCRIPTION_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Eoce { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EoceArgs<'args>
  ) -> flatbuffers::WIPOffset<Eoce<'bldr>> {
    let mut builder = EoceBuilder::new(_fbb);
    if let Some(x) = args.subscription_id { builder.add_subscription_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EoceT {
    let subscription_id = {
      let x = self.subscription_id();
      x.to_string()
    };
    EoceT {
      subscription_id,
    }
  }

  #[inline]
  pub fn subscription_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Eoce::VT_SUBSCRIPTION_ID, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Eoce<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscription_id", Self::VT_SUBSCRIPTION_ID, true)?
     .finish();
    Ok(())
  }
}
pub struct EoceArgs<'a> {
    pub subscription_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EoceArgs<'a> {
  #[inline]
  fn default() -> Self {
    EoceArgs {
      subscription_id: None, // required field
    }
  }
}

pub struct EoceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EoceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_subscription_id(&mut self, subscription_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Eoce::VT_SUBSCRIPTION_ID, subscription_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EoceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EoceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Eoce<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Eoce::VT_SUBSCRIPTION_ID,"subscription_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Eoce<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Eoce");
      ds.field("subscription_id", &self.subscription_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EoceT {
  pub subscription_id: String,
}
impl Default for EoceT {
  fn default() -> Self {
    Self {
      subscription_id: "".to_string(),
    }
  }
}
impl EoceT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Eoce<'b>> {
    let subscription_id = Some({
      let x = &self.subscription_id;
      _fbb.create_string(x)
    });
    Eoce::create(_fbb, &EoceArgs{
      subscription_id,
    })
  }
}
pub enum BufferFullOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BufferFull<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BufferFull<'a> {
  type Inner = BufferFull<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BufferFull<'a> {
  pub const VT_DROPPED_EVENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BufferFull { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BufferFullArgs
  ) -> flatbuffers::WIPOffset<BufferFull<'bldr>> {
    let mut builder = BufferFullBuilder::new(_fbb);
    builder.add_dropped_events(args.dropped_events);
    builder.finish()
  }

  pub fn unpack(&self) -> BufferFullT {
    let dropped_events = self.dropped_events();
    BufferFullT {
      dropped_events,
    }
  }

  #[inline]
  pub fn dropped_events(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(BufferFull::VT_DROPPED_EVENTS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BufferFull<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("dropped_events", Self::VT_DROPPED_EVENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct BufferFullArgs {
    pub dropped_events: u16,
}
impl<'a> Default for BufferFullArgs {
  #[inline]
  fn default() -> Self {
    BufferFullArgs {
      dropped_events: 0,
    }
  }
}

pub struct BufferFullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BufferFullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dropped_events(&mut self, dropped_events: u16) {
    self.fbb_.push_slot::<u16>(BufferFull::VT_DROPPED_EVENTS, dropped_events, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BufferFullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BufferFullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BufferFull<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BufferFull<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BufferFull");
      ds.field("dropped_events", &self.dropped_events());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BufferFullT {
  pub dropped_events: u16,
}
impl Default for BufferFullT {
  fn default() -> Self {
    Self {
      dropped_events: 0,
    }
  }
}
impl BufferFullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BufferFull<'b>> {
    let dropped_events = self.dropped_events;
    BufferFull::create(_fbb, &BufferFullArgs{
      dropped_events,
    })
  }
}
pub enum ValidProofsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValidProofs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValidProofs<'a> {
  type Inner = ValidProofs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ValidProofs<'a> {
  pub const VT_PROOFS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ValidProofs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValidProofsArgs<'args>
  ) -> flatbuffers::WIPOffset<ValidProofs<'bldr>> {
    let mut builder = ValidProofsBuilder::new(_fbb);
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ValidProofsT {
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    ValidProofsT {
      proofs,
    }
  }

  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintProofs<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintProofs>>>>(ValidProofs::VT_PROOFS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ValidProofs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MintProofs>>>>("proofs", Self::VT_PROOFS, true)?
     .finish();
    Ok(())
  }
}
pub struct ValidProofsArgs<'a> {
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintProofs<'a>>>>>,
}
impl<'a> Default for ValidProofsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValidProofsArgs {
      proofs: None, // required field
    }
  }
}

pub struct ValidProofsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValidProofsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MintProofs<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValidProofs::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValidProofsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValidProofsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ValidProofs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ValidProofs::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ValidProofs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ValidProofs");
      ds.field("proofs", &self.proofs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ValidProofsT {
  pub proofs: Vec<MintProofsT>,
}
impl Default for ValidProofsT {
  fn default() -> Self {
    Self {
      proofs: Default::default(),
    }
  }
}
impl ValidProofsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ValidProofs<'b>> {
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ValidProofs::create(_fbb, &ValidProofsArgs{
      proofs,
    })
  }
}
pub enum MintProofsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MintProofs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MintProofs<'a> {
  type Inner = MintProofs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MintProofs<'a> {
  pub const VT_MINT: flatbuffers::VOffsetT = 4;
  pub const VT_PROOFS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MintProofs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MintProofsArgs<'args>
  ) -> flatbuffers::WIPOffset<MintProofs<'bldr>> {
    let mut builder = MintProofsBuilder::new(_fbb);
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    if let Some(x) = args.mint { builder.add_mint(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MintProofsT {
    let mint = {
      let x = self.mint();
      x.to_string()
    };
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    MintProofsT {
      mint,
      proofs,
    }
  }

  #[inline]
  pub fn mint(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MintProofs::VT_MINT, None).unwrap()}
  }
  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof>>>>(MintProofs::VT_PROOFS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for MintProofs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint", Self::VT_MINT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Proof>>>>("proofs", Self::VT_PROOFS, true)?
     .finish();
    Ok(())
  }
}
pub struct MintProofsArgs<'a> {
    pub mint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>>>,
}
impl<'a> Default for MintProofsArgs<'a> {
  #[inline]
  fn default() -> Self {
    MintProofsArgs {
      mint: None, // required field
      proofs: None, // required field
    }
  }
}

pub struct MintProofsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MintProofsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mint(&mut self, mint: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintProofs::VT_MINT, mint);
  }
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Proof<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintProofs::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MintProofsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MintProofsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MintProofs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, MintProofs::VT_MINT,"mint");
    self.fbb_.required(o, MintProofs::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MintProofs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MintProofs");
      ds.field("mint", &self.mint());
      ds.field("proofs", &self.proofs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MintProofsT {
  pub mint: String,
  pub proofs: Vec<ProofT>,
}
impl Default for MintProofsT {
  fn default() -> Self {
    Self {
      mint: "".to_string(),
      proofs: Default::default(),
    }
  }
}
impl MintProofsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MintProofs<'b>> {
    let mint = Some({
      let x = &self.mint;
      _fbb.create_string(x)
    });
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MintProofs::create(_fbb, &MintProofsArgs{
      mint,
      proofs,
    })
  }
}
pub enum PubkeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Pubkey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pubkey<'a> {
  type Inner = Pubkey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Pubkey<'a> {
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Pubkey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PubkeyArgs<'args>
  ) -> flatbuffers::WIPOffset<Pubkey<'bldr>> {
    let mut builder = PubkeyBuilder::new(_fbb);
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PubkeyT {
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    PubkeyT {
      pubkey,
    }
  }

  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Pubkey::VT_PUBKEY, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Pubkey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .finish();
    Ok(())
  }
}
pub struct PubkeyArgs<'a> {
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PubkeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PubkeyArgs {
      pubkey: None, // required field
    }
  }
}

pub struct PubkeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PubkeyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Pubkey::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PubkeyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PubkeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pubkey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Pubkey::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Pubkey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Pubkey");
      ds.field("pubkey", &self.pubkey());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PubkeyT {
  pub pubkey: String,
}
impl Default for PubkeyT {
  fn default() -> Self {
    Self {
      pubkey: "".to_string(),
    }
  }
}
impl PubkeyT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Pubkey<'b>> {
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    Pubkey::create(_fbb, &PubkeyArgs{
      pubkey,
    })
  }
}
pub enum SignedEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignedEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignedEvent<'a> {
  type Inner = SignedEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignedEvent<'a> {
  pub const VT_EVENT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignedEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SignedEventArgs<'args>
  ) -> flatbuffers::WIPOffset<SignedEvent<'bldr>> {
    let mut builder = SignedEventBuilder::new(_fbb);
    if let Some(x) = args.event { builder.add_event(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SignedEventT {
    let event = {
      let x = self.event();
      Box::new(x.unpack())
    };
    SignedEventT {
      event,
    }
  }

  #[inline]
  pub fn event(&self) -> NostrEvent<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<NostrEvent>>(SignedEvent::VT_EVENT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SignedEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<NostrEvent>>("event", Self::VT_EVENT, true)?
     .finish();
    Ok(())
  }
}
pub struct SignedEventArgs<'a> {
    pub event: Option<flatbuffers::WIPOffset<NostrEvent<'a>>>,
}
impl<'a> Default for SignedEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignedEventArgs {
      event: None, // required field
    }
  }
}

pub struct SignedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignedEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<NostrEvent<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NostrEvent>>(SignedEvent::VT_EVENT, event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SignedEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SignedEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignedEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SignedEvent::VT_EVENT,"event");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignedEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignedEvent");
      ds.field("event", &self.event());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SignedEventT {
  pub event: Box<NostrEventT>,
}
impl Default for SignedEventT {
  fn default() -> Self {
    Self {
      event: Default::default(),
    }
  }
}
impl SignedEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SignedEvent<'b>> {
    let event = Some({
      let x = &self.event;
      x.pack(_fbb)
    });
    SignedEvent::create(_fbb, &SignedEventArgs{
      event,
    })
  }
}
pub enum RawOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Raw<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Raw<'a> {
  type Inner = Raw<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Raw<'a> {
  pub const VT_RAW: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Raw { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RawArgs<'args>
  ) -> flatbuffers::WIPOffset<Raw<'bldr>> {
    let mut builder = RawBuilder::new(_fbb);
    if let Some(x) = args.raw { builder.add_raw(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> RawT {
    let raw = {
      let x = self.raw();
      x.to_string()
    };
    RawT {
      raw,
    }
  }

  #[inline]
  pub fn raw(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Raw::VT_RAW, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Raw<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("raw", Self::VT_RAW, true)?
     .finish();
    Ok(())
  }
}
pub struct RawArgs<'a> {
    pub raw: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RawArgs<'a> {
  #[inline]
  fn default() -> Self {
    RawArgs {
      raw: None, // required field
    }
  }
}

pub struct RawBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RawBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_raw(&mut self, raw: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Raw::VT_RAW, raw);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RawBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RawBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Raw<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Raw::VT_RAW,"raw");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Raw<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Raw");
      ds.field("raw", &self.raw());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RawT {
  pub raw: String,
}
impl Default for RawT {
  fn default() -> Self {
    Self {
      raw: "".to_string(),
    }
  }
}
impl RawT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Raw<'b>> {
    let raw = Some({
      let x = &self.raw;
      _fbb.create_string(x)
    });
    Raw::create(_fbb, &RawArgs{
      raw,
    })
  }
}
pub enum WorkerMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WorkerMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorkerMessage<'a> {
  type Inner = WorkerMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WorkerMessage<'a> {
  pub const VT_SUB_ID: flatbuffers::VOffsetT = 4;
  pub const VT_URL: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
  pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorkerMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WorkerMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<WorkerMessage<'bldr>> {
    let mut builder = WorkerMessageBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_type_(args.type_);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.sub_id { builder.add_sub_id(x); }
    builder.add_content_type(args.content_type);
    builder.finish()
  }

  pub fn unpack(&self) -> WorkerMessageT {
    let sub_id = self.sub_id().map(|x| {
      x.to_string()
    });
    let url = self.url().map(|x| {
      x.to_string()
    });
    let type_ = self.type_();
    let content = match self.content_type() {
      Message::NONE => MessageT::NONE,
      Message::ParsedEvent => MessageT::ParsedEvent(Box::new(
        self.content_as_parsed_event()
            .expect("Invalid union table, expected `Message::ParsedEvent`.")
            .unpack()
      )),
      Message::NostrEvent => MessageT::NostrEvent(Box::new(
        self.content_as_nostr_event()
            .expect("Invalid union table, expected `Message::NostrEvent`.")
            .unpack()
      )),
      Message::ConnectionStatus => MessageT::ConnectionStatus(Box::new(
        self.content_as_connection_status()
            .expect("Invalid union table, expected `Message::ConnectionStatus`.")
            .unpack()
      )),
      Message::CountResponse => MessageT::CountResponse(Box::new(
        self.content_as_count_response()
            .expect("Invalid union table, expected `Message::CountResponse`.")
            .unpack()
      )),
      Message::Eoce => MessageT::Eoce(Box::new(
        self.content_as_eoce()
            .expect("Invalid union table, expected `Message::Eoce`.")
            .unpack()
      )),
      Message::BufferFull => MessageT::BufferFull(Box::new(
        self.content_as_buffer_full()
            .expect("Invalid union table, expected `Message::BufferFull`.")
            .unpack()
      )),
      Message::ValidProofs => MessageT::ValidProofs(Box::new(
        self.content_as_valid_proofs()
            .expect("Invalid union table, expected `Message::ValidProofs`.")
            .unpack()
      )),
      Message::SignedEvent => MessageT::SignedEvent(Box::new(
        self.content_as_signed_event()
            .expect("Invalid union table, expected `Message::SignedEvent`.")
            .unpack()
      )),
      Message::Pubkey => MessageT::Pubkey(Box::new(
        self.content_as_pubkey()
            .expect("Invalid union table, expected `Message::Pubkey`.")
            .unpack()
      )),
      Message::Raw => MessageT::Raw(Box::new(
        self.content_as_raw()
            .expect("Invalid union table, expected `Message::Raw`.")
            .unpack()
      )),
      _ => MessageT::NONE,
    };
    WorkerMessageT {
      sub_id,
      url,
      type_,
      content,
    }
  }

  #[inline]
  pub fn sub_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorkerMessage::VT_SUB_ID, None)}
  }
  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorkerMessage::VT_URL, None)}
  }
  #[inline]
  pub fn type_(&self) -> MessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageType>(WorkerMessage::VT_TYPE_, Some(MessageType::ParsedNostrEvent)).unwrap()}
  }
  #[inline]
  pub fn content_type(&self) -> Message {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Message>(WorkerMessage::VT_CONTENT_TYPE, Some(Message::NONE)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(WorkerMessage::VT_CONTENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_parsed_event(&self) -> Option<ParsedEvent<'a>> {
    if self.content_type() == Message::ParsedEvent {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ParsedEvent::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_nostr_event(&self) -> Option<NostrEvent<'a>> {
    if self.content_type() == Message::NostrEvent {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NostrEvent::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_connection_status(&self) -> Option<ConnectionStatus<'a>> {
    if self.content_type() == Message::ConnectionStatus {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ConnectionStatus::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_count_response(&self) -> Option<CountResponse<'a>> {
    if self.content_type() == Message::CountResponse {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CountResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_eoce(&self) -> Option<Eoce<'a>> {
    if self.content_type() == Message::Eoce {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Eoce::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_buffer_full(&self) -> Option<BufferFull<'a>> {
    if self.content_type() == Message::BufferFull {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BufferFull::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_valid_proofs(&self) -> Option<ValidProofs<'a>> {
    if self.content_type() == Message::ValidProofs {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ValidProofs::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_signed_event(&self) -> Option<SignedEvent<'a>> {
    if self.content_type() == Message::SignedEvent {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SignedEvent::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_pubkey(&self) -> Option<Pubkey<'a>> {
    if self.content_type() == Message::Pubkey {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Pubkey::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_raw(&self) -> Option<Raw<'a>> {
    if self.content_type() == Message::Raw {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Raw::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for WorkerMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sub_id", Self::VT_SUB_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, false)?
     .visit_field::<MessageType>("type_", Self::VT_TYPE_, false)?
     .visit_union::<Message, _>("content_type", Self::VT_CONTENT_TYPE, "content", Self::VT_CONTENT, false, |key, v, pos| {
        match key {
          Message::ParsedEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParsedEvent>>("Message::ParsedEvent", pos),
          Message::NostrEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NostrEvent>>("Message::NostrEvent", pos),
          Message::ConnectionStatus => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConnectionStatus>>("Message::ConnectionStatus", pos),
          Message::CountResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CountResponse>>("Message::CountResponse", pos),
          Message::Eoce => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Eoce>>("Message::Eoce", pos),
          Message::BufferFull => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BufferFull>>("Message::BufferFull", pos),
          Message::ValidProofs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ValidProofs>>("Message::ValidProofs", pos),
          Message::SignedEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SignedEvent>>("Message::SignedEvent", pos),
          Message::Pubkey => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Pubkey>>("Message::Pubkey", pos),
          Message::Raw => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Raw>>("Message::Raw", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct WorkerMessageArgs<'a> {
    pub sub_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: MessageType,
    pub content_type: Message,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for WorkerMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    WorkerMessageArgs {
      sub_id: None,
      url: None,
      type_: MessageType::ParsedNostrEvent,
      content_type: Message::NONE,
      content: None,
    }
  }
}

pub struct WorkerMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorkerMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sub_id(&mut self, sub_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorkerMessage::VT_SUB_ID, sub_id);
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorkerMessage::VT_URL, url);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: MessageType) {
    self.fbb_.push_slot::<MessageType>(WorkerMessage::VT_TYPE_, type_, MessageType::ParsedNostrEvent);
  }
  #[inline]
  pub fn add_content_type(&mut self, content_type: Message) {
    self.fbb_.push_slot::<Message>(WorkerMessage::VT_CONTENT_TYPE, content_type, Message::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorkerMessage::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WorkerMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WorkerMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorkerMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WorkerMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WorkerMessage");
      ds.field("sub_id", &self.sub_id());
      ds.field("url", &self.url());
      ds.field("type_", &self.type_());
      ds.field("content_type", &self.content_type());
      match self.content_type() {
        Message::ParsedEvent => {
          if let Some(x) = self.content_as_parsed_event() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::NostrEvent => {
          if let Some(x) = self.content_as_nostr_event() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::ConnectionStatus => {
          if let Some(x) = self.content_as_connection_status() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::CountResponse => {
          if let Some(x) = self.content_as_count_response() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::Eoce => {
          if let Some(x) = self.content_as_eoce() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::BufferFull => {
          if let Some(x) = self.content_as_buffer_full() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::ValidProofs => {
          if let Some(x) = self.content_as_valid_proofs() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::SignedEvent => {
          if let Some(x) = self.content_as_signed_event() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::Pubkey => {
          if let Some(x) = self.content_as_pubkey() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::Raw => {
          if let Some(x) = self.content_as_raw() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("content", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WorkerMessageT {
  pub sub_id: Option<String>,
  pub url: Option<String>,
  pub type_: MessageType,
  pub content: MessageT,
}
impl Default for WorkerMessageT {
  fn default() -> Self {
    Self {
      sub_id: None,
      url: None,
      type_: MessageType::ParsedNostrEvent,
      content: MessageT::NONE,
    }
  }
}
impl WorkerMessageT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WorkerMessage<'b>> {
    let sub_id = self.sub_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let url = self.url.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let type_ = self.type_;
    let content_type = self.content.message_type();
    let content = self.content.pack(_fbb);
    WorkerMessage::create(_fbb, &WorkerMessageArgs{
      sub_id,
      url,
      type_,
      content_type,
      content,
    })
  }
}
pub enum CacheRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CacheRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CacheRequest<'a> {
  type Inner = CacheRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CacheRequest<'a> {
  pub const VT_SUB_ID: flatbuffers::VOffsetT = 4;
  pub const VT_REQUESTS: flatbuffers::VOffsetT = 6;
  pub const VT_EVENT: flatbuffers::VOffsetT = 8;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CacheRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CacheRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CacheRequest<'bldr>> {
    let mut builder = CacheRequestBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.event { builder.add_event(x); }
    if let Some(x) = args.requests { builder.add_requests(x); }
    if let Some(x) = args.sub_id { builder.add_sub_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CacheRequestT {
    let sub_id = {
      let x = self.sub_id();
      x.to_string()
    };
    let requests = self.requests().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let event = self.event().map(|x| {
      Box::new(x.unpack())
    });
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    CacheRequestT {
      sub_id,
      requests,
      event,
      relays,
    }
  }

  #[inline]
  pub fn sub_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CacheRequest::VT_SUB_ID, None).unwrap()}
  }
  #[inline]
  pub fn requests(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request>>>>(CacheRequest::VT_REQUESTS, None)}
  }
  #[inline]
  pub fn event(&self) -> Option<NostrEvent<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<NostrEvent>>(CacheRequest::VT_EVENT, None)}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CacheRequest::VT_RELAYS, None)}
  }
}

impl flatbuffers::Verifiable for CacheRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sub_id", Self::VT_SUB_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Request>>>>("requests", Self::VT_REQUESTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<NostrEvent>>("event", Self::VT_EVENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct CacheRequestArgs<'a> {
    pub sub_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub requests: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>>>,
    pub event: Option<flatbuffers::WIPOffset<NostrEvent<'a>>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CacheRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CacheRequestArgs {
      sub_id: None, // required field
      requests: None,
      event: None,
      relays: None,
    }
  }
}

pub struct CacheRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CacheRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sub_id(&mut self, sub_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CacheRequest::VT_SUB_ID, sub_id);
  }
  #[inline]
  pub fn add_requests(&mut self, requests: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Request<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CacheRequest::VT_REQUESTS, requests);
  }
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<NostrEvent<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NostrEvent>>(CacheRequest::VT_EVENT, event);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CacheRequest::VT_RELAYS, relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CacheRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CacheRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CacheRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CacheRequest::VT_SUB_ID,"sub_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CacheRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CacheRequest");
      ds.field("sub_id", &self.sub_id());
      ds.field("requests", &self.requests());
      ds.field("event", &self.event());
      ds.field("relays", &self.relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CacheRequestT {
  pub sub_id: String,
  pub requests: Option<Vec<RequestT>>,
  pub event: Option<Box<NostrEventT>>,
  pub relays: Option<Vec<String>>,
}
impl Default for CacheRequestT {
  fn default() -> Self {
    Self {
      sub_id: "".to_string(),
      requests: None,
      event: None,
      relays: None,
    }
  }
}
impl CacheRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CacheRequest<'b>> {
    let sub_id = Some({
      let x = &self.sub_id;
      _fbb.create_string(x)
    });
    let requests = self.requests.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let event = self.event.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    CacheRequest::create(_fbb, &CacheRequestArgs{
      sub_id,
      requests,
      event,
      relays,
    })
  }
}
pub enum SignerRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignerRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignerRequest<'a> {
  type Inner = SignerRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignerRequest<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OP: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 10;
  pub const VT_SENDER_PUBKEY: flatbuffers::VOffsetT = 12;
  pub const VT_RECIPIENT_PUBKEY: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignerRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SignerRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SignerRequest<'bldr>> {
    let mut builder = SignerRequestBuilder::new(_fbb);
    builder.add_request_id(args.request_id);
    if let Some(x) = args.recipient_pubkey { builder.add_recipient_pubkey(x); }
    if let Some(x) = args.sender_pubkey { builder.add_sender_pubkey(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    builder.add_op(args.op);
    builder.finish()
  }

  pub fn unpack(&self) -> SignerRequestT {
    let request_id = self.request_id();
    let op = self.op();
    let payload = self.payload().map(|x| {
      x.to_string()
    });
    let pubkey = self.pubkey().map(|x| {
      x.to_string()
    });
    let sender_pubkey = self.sender_pubkey().map(|x| {
      x.to_string()
    });
    let recipient_pubkey = self.recipient_pubkey().map(|x| {
      x.to_string()
    });
    SignerRequestT {
      request_id,
      op,
      payload,
      pubkey,
      sender_pubkey,
      recipient_pubkey,
    }
  }

  #[inline]
  pub fn request_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SignerRequest::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn op(&self) -> SignerOp {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SignerOp>(SignerRequest::VT_OP, Some(SignerOp::GetPubkey)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SignerRequest::VT_PAYLOAD, None)}
  }
  #[inline]
  pub fn pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SignerRequest::VT_PUBKEY, None)}
  }
  #[inline]
  pub fn sender_pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SignerRequest::VT_SENDER_PUBKEY, None)}
  }
  #[inline]
  pub fn recipient_pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SignerRequest::VT_RECIPIENT_PUBKEY, None)}
  }
}

impl flatbuffers::Verifiable for SignerRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<SignerOp>("op", Self::VT_OP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender_pubkey", Self::VT_SENDER_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient_pubkey", Self::VT_RECIPIENT_PUBKEY, false)?
     .finish();
    Ok(())
  }
}
pub struct SignerRequestArgs<'a> {
    pub request_id: u64,
    pub op: SignerOp,
    pub payload: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sender_pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient_pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SignerRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignerRequestArgs {
      request_id: 0,
      op: SignerOp::GetPubkey,
      payload: None,
      pubkey: None,
      sender_pubkey: None,
      recipient_pubkey: None,
    }
  }
}

pub struct SignerRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignerRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: u64) {
    self.fbb_.push_slot::<u64>(SignerRequest::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn add_op(&mut self, op: SignerOp) {
    self.fbb_.push_slot::<SignerOp>(SignerRequest::VT_OP, op, SignerOp::GetPubkey);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignerRequest::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignerRequest::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_sender_pubkey(&mut self, sender_pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignerRequest::VT_SENDER_PUBKEY, sender_pubkey);
  }
  #[inline]
  pub fn add_recipient_pubkey(&mut self, recipient_pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignerRequest::VT_RECIPIENT_PUBKEY, recipient_pubkey);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SignerRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SignerRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignerRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignerRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignerRequest");
      ds.field("request_id", &self.request_id());
      ds.field("op", &self.op());
      ds.field("payload", &self.payload());
      ds.field("pubkey", &self.pubkey());
      ds.field("sender_pubkey", &self.sender_pubkey());
      ds.field("recipient_pubkey", &self.recipient_pubkey());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SignerRequestT {
  pub request_id: u64,
  pub op: SignerOp,
  pub payload: Option<String>,
  pub pubkey: Option<String>,
  pub sender_pubkey: Option<String>,
  pub recipient_pubkey: Option<String>,
}
impl Default for SignerRequestT {
  fn default() -> Self {
    Self {
      request_id: 0,
      op: SignerOp::GetPubkey,
      payload: None,
      pubkey: None,
      sender_pubkey: None,
      recipient_pubkey: None,
    }
  }
}
impl SignerRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SignerRequest<'b>> {
    let request_id = self.request_id;
    let op = self.op;
    let payload = self.payload.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let pubkey = self.pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sender_pubkey = self.sender_pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let recipient_pubkey = self.recipient_pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    SignerRequest::create(_fbb, &SignerRequestArgs{
      request_id,
      op,
      payload,
      pubkey,
      sender_pubkey,
      recipient_pubkey,
    })
  }
}
pub enum SignerResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignerResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignerResponse<'a> {
  type Inner = SignerResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignerResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_RESULT: flatbuffers::VOffsetT = 6;
  pub const VT_ERROR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignerResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SignerResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<SignerResponse<'bldr>> {
    let mut builder = SignerResponseBuilder::new(_fbb);
    builder.add_request_id(args.request_id);
    if let Some(x) = args.error { builder.add_error(x); }
    if let Some(x) = args.result { builder.add_result(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SignerResponseT {
    let request_id = self.request_id();
    let result = self.result().map(|x| {
      x.to_string()
    });
    let error = self.error().map(|x| {
      x.to_string()
    });
    SignerResponseT {
      request_id,
      result,
      error,
    }
  }

  #[inline]
  pub fn request_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SignerResponse::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn result(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SignerResponse::VT_RESULT, None)}
  }
  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SignerResponse::VT_ERROR, None)}
  }
}

impl flatbuffers::Verifiable for SignerResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("result", Self::VT_RESULT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error", Self::VT_ERROR, false)?
     .finish();
    Ok(())
  }
}
pub struct SignerResponseArgs<'a> {
    pub request_id: u64,
    pub result: Option<flatbuffers::WIPOffset<&'a str>>,
    pub error: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SignerResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignerResponseArgs {
      request_id: 0,
      result: None,
      error: None,
    }
  }
}

pub struct SignerResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignerResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: u64) {
    self.fbb_.push_slot::<u64>(SignerResponse::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignerResponse::VT_RESULT, result);
  }
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignerResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SignerResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SignerResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignerResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignerResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignerResponse");
      ds.field("request_id", &self.request_id());
      ds.field("result", &self.result());
      ds.field("error", &self.error());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SignerResponseT {
  pub request_id: u64,
  pub result: Option<String>,
  pub error: Option<String>,
}
impl Default for SignerResponseT {
  fn default() -> Self {
    Self {
      request_id: 0,
      result: None,
      error: None,
    }
  }
}
impl SignerResponseT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SignerResponse<'b>> {
    let request_id = self.request_id;
    let result = self.result.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let error = self.error.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    SignerResponse::create(_fbb, &SignerResponseArgs{
      request_id,
      result,
      error,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `WorkerMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_worker_message_unchecked`.
pub fn root_as_worker_message(buf: &[u8]) -> Result<WorkerMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<WorkerMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `WorkerMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_worker_message_unchecked`.
pub fn size_prefixed_root_as_worker_message(buf: &[u8]) -> Result<WorkerMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<WorkerMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `WorkerMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_worker_message_unchecked`.
pub fn root_as_worker_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WorkerMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<WorkerMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `WorkerMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_worker_message_unchecked`.
pub fn size_prefixed_root_as_worker_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WorkerMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<WorkerMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a WorkerMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `WorkerMessage`.
pub unsafe fn root_as_worker_message_unchecked(buf: &[u8]) -> WorkerMessage {
  flatbuffers::root_unchecked::<WorkerMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed WorkerMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `WorkerMessage`.
pub unsafe fn size_prefixed_root_as_worker_message_unchecked(buf: &[u8]) -> WorkerMessage {
  flatbuffers::size_prefixed_root_unchecked::<WorkerMessage>(buf)
}
#[inline]
pub fn finish_worker_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<WorkerMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_worker_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<WorkerMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fb
}  // pub mod nostr

