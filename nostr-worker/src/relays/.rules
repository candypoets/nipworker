# .rules file for Nostr Relay Management Module

## Module Overview

This module provides a complete Rust implementation of a Nostr relay management system, designed for WASM compatibility and optimized for browser environments including Safari.

## Architecture Principles

### 1. **WASM-First Design**
- All components MUST work in browser WASM environments
- Use `tokio-tungstenite-wasm` for unified WebSocket support
- Avoid platform-specific dependencies
- Handle browser limitations gracefully (especially Safari)

### 2. **Thread Safety & Async Compatibility**
- Use `tokio::sync::RwLock` instead of `std::sync::RwLock` for async operations
- All shared state MUST be `Send + Sync`
- Avoid holding lock guards across await points
- Use proper async/await patterns throughout

### 3. **Safari Optimization**
- Implement channel-based connection coordination
- Limit concurrent connections appropriately
- Handle Safari's WebSocket quirks and limitations
- Use simplified connection state management

### 4. **Resource Management**
- Automatic cleanup of idle connections
- Connection pooling and reuse
- Proper shutdown and cleanup procedures
- Memory-efficient event handling

## File Structure and Responsibilities

### Core Files
- **`mod.rs`** - Public API exports and module organization
- **`interfaces.rs`** - Trait definitions and common types
- **`relay.rs`** - Main relay implementation (translated from go-nostr)
- **`connection.rs`** - WebSocket connection abstraction
- **`relay_connection.rs`** - Individual relay connection management
- **`relay_manager.rs`** - High-level relay pool management
- **`connections_registry.rs`** - Connection registry and lifecycle
- **`clean_relays.rs`** - URL filtering and validation utilities

### Utility Files
- **`README.md`** - Comprehensive module documentation
- **`clean_relays_test.rs`** - Additional test cases for URL cleaning

## Coding Standards

### 1. **Error Handling**
- Use `anyhow::Result<T>` for most functions
- Define custom errors in `interfaces.rs` using `thiserror`
- Provide meaningful error messages with context
- Handle timeouts and connection failures gracefully

### 2. **Async Patterns**
- All blocking operations MUST be async
- Use `tokio::spawn` for background tasks
- Implement proper cancellation with `CancellationToken`
- Handle async lifetimes correctly

### 3. **Type Safety**
- Use strong typing throughout
- Implement proper trait bounds (`Send + Sync` where needed)
- Use `Arc<T>` for shared ownership
- Prefer `Box<dyn Trait>` for trait objects

### 4. **Testing**
- Each module MUST have comprehensive unit tests
- Test both success and failure paths
- Use `#[tokio::test]` for async tests
- Mock external dependencies where appropriate

## Key Design Patterns

### 1. **Connection Registry Pattern**
```rust
// Registry manages connection lifecycle
let conn = registry.get_or_create(url).await?;
let relay = conn.try_connect(timeout).await?;
```

### 2. **Channel-Based Coordination**
```rust
// Safari-optimized connection handling
let (tx, rx) = oneshot::channel();
tokio::spawn(async move {
    let result = connect_async(url, timeout).await;
    let _ = tx.send(result);
});
```

### 3. **Resource Cleanup Pattern**
```rust
// Automatic cleanup with proper scoping
{
    let _guard = cleanup_mutex.lock().await;
    // Cleanup operations
}
```

## Integration Guidelines

### 1. **With Nostr Types**
- Use `nostr` crate types (`Event`, `Filter`, etc.)
- Implement proper serialization/deserialization
- Handle Nostr protocol specifics (REQ, EVENT, EOSE, etc.)

### 2. **With WASM**
- All public functions should be WASM-compatible
- Use `wasm-bindgen` for JavaScript interop where needed
- Handle browser security restrictions

### 3. **With Database Layer**
- Integrate with `NostrDB` for event storage
- Implement proper event parsing and validation
- Handle event deduplication

## Performance Considerations

### 1. **Connection Pooling**
- Reuse existing connections when possible
- Implement connection health monitoring
- Clean up idle connections automatically

### 2. **Memory Management**
- Use weak references to avoid circular dependencies
- Implement proper Drop traits for cleanup
- Monitor memory usage in long-running operations

### 3. **Network Efficiency**
- Batch operations where possible
- Implement proper backoff strategies
- Handle network failures gracefully

## Security Considerations

### 1. **URL Validation**
- Filter malicious or invalid URLs
- Prevent access to local network addresses
- Validate WebSocket protocols only

### 2. **Connection Security**
- Use secure WebSocket connections (WSS) when possible
- Implement proper certificate validation
- Handle authentication (NIP-42) securely

### 3. **Resource Limits**
- Limit concurrent connections
- Implement timeouts for all operations
- Prevent resource exhaustion attacks

## Debugging and Monitoring

### 1. **Logging**
- Use `tracing` crate for structured logging
- Log connection state changes
- Include relay URLs in log messages

### 2. **Metrics**
- Track connection counts and success rates
- Monitor cleanup operations
- Measure connection latency

### 3. **Error Reporting**
- Provide detailed error context
- Include relay information in errors
- Track error patterns for debugging

## Future Considerations

### 1. **Advanced Features**
- Connection multiplexing
- Advanced subscription optimization
- Rate limiting and backoff
- Metrics and monitoring dashboard

### 2. **Protocol Extensions**
- NIP-42 (Authentication)
- NIP-11 (Relay Information Document)
- Custom relay extensions

### 3. **Performance Optimizations**
- WebAssembly SIMD for cryptography
- Connection pre-warming
- Intelligent relay selection

## Testing Strategy

### 1. **Unit Tests**
- Test individual components in isolation
- Mock external dependencies
- Test error conditions thoroughly

### 2. **Integration Tests**
- Test full relay connection workflows
- Test cleanup and resource management
- Test Safari-specific behaviors

### 3. **Performance Tests**
- Test with many concurrent connections
- Test memory usage patterns
- Test cleanup efficiency

## Maintenance Guidelines

### 1. **Code Updates**
- Keep up with `nostr` crate updates
- Monitor browser compatibility
- Update dependencies regularly

### 2. **Documentation**
- Keep README.md updated with changes
- Document breaking changes
- Provide migration guides

### 3. **Monitoring**
- Monitor real-world performance
- Track user-reported issues
- Collect usage metrics

## Common Pitfalls to Avoid

1. **Holding locks across await points** - Always drop guards before awaiting
2. **Creating circular Arc references** - Use weak references where appropriate
3. **Blocking in async context** - Use proper async alternatives
4. **Ignoring Safari limitations** - Test on Safari regularly
5. **Memory leaks in long-running operations** - Implement proper cleanup
6. **Race conditions in connection state** - Use proper synchronization
7. **Forgetting error context** - Always provide meaningful error messages

## Version Compatibility

- **Rust**: 1.70+ (for async traits and modern features)
- **Tokio**: 1.0+ (for async runtime)
- **Nostr**: 0.29+ (for latest protocol features)
- **WASM**: Target wasm32-unknown-unknown

This module is a critical component of the broader NutsCash application and should be maintained to the highest standards of reliability, performance, and security.
```

---

Now updating the README.md:

```md
# Nostr Relay Management System

This module provides a complete Rust implementation of a Nostr relay management system, designed specifically for WASM environments and optimized for browser compatibility, including Safari's unique WebSocket behavior.

## ğŸ—ï¸ Architecture Overview

The relay management system consists of several key components working together to provide robust, efficient relay connectivity:

### Core Components

- **`relay.rs`** - Main relay implementation with full Nostr protocol support
- **`connection.rs`** - Unified WebSocket connection handling (WASM-compatible)
- **`relay_connection.rs`** - Individual relay connection lifecycle management
- **`relay_manager.rs`** - High-level relay pool with automatic cleanup
- **`connections_registry.rs`** - Thread-safe connection registry and statistics
- **`interfaces.rs`** - Trait definitions and common types
- **`clean_relays.rs`** - URL filtering and validation utilities

### Design Principles

1. **ğŸŒ WASM Compatibility** - All components work seamlessly in browser environments
2. **ğŸ¦‹ Safari Optimization** - Special handling for Safari's WebSocket limitations and behaviors
3. **ğŸ”’ Thread Safety** - All components use async-compatible locks for safe concurrent access
4. **ğŸ›¡ï¸ Error Resilience** - Comprehensive error handling with automatic reconnection strategies
5. **â™»ï¸ Resource Management** - Automatic cleanup of idle connections and memory management

## âœ¨ Key Features

### ğŸ”Œ Advanced Connection Management
- **Connection Pooling**: Intelligent reuse of existing connections
- **Health Monitoring**: Continuous connection health checks and recovery
- **Timeout Handling**: Configurable timeouts with exponential backoff
- **Clean Shutdown**: Graceful connection termination and resource cleanup

### ğŸ”— Smart URL Processing
- **Automatic Filtering**: Removes invalid URLs (media files, local addresses, malicious content)
- **Protocol Normalization**: Handles ws/wss protocols and various URL formats
- **Security Validation**: Prevents access to local network resources
- **Format Support**: Accepts various relay URL formats and normalizes them

### ğŸ“¡ Subscription Management
- **Event Filtering**: Advanced filtering with multiple criteria support
- **EOSE Handling**: Proper End-of-Stored-Events processing
- **Subscription Lifecycle**: Automatic subscription cleanup and management
- **Memory Efficient**: Optimized event routing and processing

### ğŸ Safari Compatibility Layer
- **Channel Coordination**: Uses oneshot channels for connection synchronization
- **Connection Limits**: Respects Safari's concurrent connection restrictions
- **WebSocket Optimization**: Handles Safari's unique WebSocket behaviors
- **Reduced Complexity**: Simplified state management for browser compatibility

## ğŸš€ Quick Start

### Basic Relay Connection

```rust
use nutscash_nostr::relays::{RelayConnectionManager, clean_relays};
use instant::Duration;

// Create a relay manager with configuration
let manager = RelayConnectionManager::new(
    Duration::from_secs(10), // connect timeout
    3, // max retries
);

// Clean and validate relay URLs
let raw_relays = vec![
    "wss://relay.damus.io".to_string(),
    "wss://relay.snort.social".to_string(),
    "wss://localhost".to_string(), // Will be filtered out
    "relay.primal.net".to_string(), // Will be normalized to wss://
];

let clean_relay_urls = clean_relays(raw_relays);
println!("Valid relays: {:?}", clean_relay_urls);

// Connect to relays
for url in clean_relay_urls {
    match manager.get_relay(&url).await {
        Ok(relay) => println!("âœ… Connected to: {}", url),
        Err(e) => eprintln!("âŒ Failed to connect to {}: {}", url, e),
    }
}

// Get connection statistics
let stats = manager.get_stats();
println!("ğŸ“Š Active connections: {}", stats.active_connections);
println!("ğŸ“ˆ Success rate: {}/{}", stats.successful_conns, stats.total_requests);

// Clean shutdown
manager.close().await;
```

### Publishing Events

```rust
use nostr::{EventBuilder, Keys, Kind};

// Get a relay connection
let relay = manager.get_relay("wss://relay.damus.io").await?;

// Create and sign an event
let keys = Keys::generate();
let event = EventBuilder::text_note("Hello from Rust relay manager! ğŸ¦€", [])
    .to_event(&keys)?;

// Publish with automatic OK response handling
match relay.publish(event.clone()).await {
    Ok(_) => println!("ğŸ“¤ Event published: {}", event.id),
    Err(e) => eprintln!("ğŸ’¥ Publish failed: {}", e),
}
```

### Event Subscriptions

```rust
use nostr::{Filter, Kind, Timestamp};

// Create subscription filter
let since = Timestamp::now() - Duration::from_secs(3600); // Last hour
let filter = Filter::new()
    .kinds([Kind::TextNote])
    .since(since)
    .limit(10);

// Subscribe to events
let subscription = relay.subscribe(vec![filter], vec![]).await?;

// Process incoming events
tokio::spawn(async move {
    while let Some(event) = subscription.events.recv().await {
        println!("ğŸ“¨ New event: {} from {}", event.event.id, event.event.pubkey);
    }
});
```

## ğŸ”§ Configuration

### Manager Configuration

The relay manager supports extensive configuration for different use cases:

```rust
use nutscash_nostr::relays::{RelayConnectionManager, Config};

// Default configuration
let manager = RelayConnectionManager::default();

// Custom configuration
let custom_manager = RelayConnectionManager::new(
    Duration::from_secs(15),  // Longer timeout for slow networks
    5,                        // More retries for unstable connections
);

// Advanced configuration via Config struct
let config = Config {
    connect_timeout: Duration::from_secs(10),
    max_retries: 3,
    cleanup_interval: Duration::from_secs(30),
    max_concurrent_conns: 20,
    safari_optimized: true,  // Enable Safari optimizations
    debug: false,
};
```

### URL Cleaning Configuration

The URL cleaning system automatically filters dangerous or invalid URLs:

```rust
let test_urls = vec![
    "wss://valid.relay.com".to_string(),           // âœ… Valid
    "http://insecure.relay.com".to_string(),       // âŒ HTTP filtered
    "wss://localhost".to_string(),                 // âŒ Local address
    "wss://192.168.1.100".to_string(),            // âŒ Private IP
    "wss://relay.com/image.jpg".to_string(),       // âŒ Media file
    "relay.example.com".to_string(),               // âœ… Normalized to wss://
];

let clean_urls = clean_relays(test_urls);
// Result: ["wss://valid.relay.com", "wss://relay.example.com"]
```

## ğŸ“Š Connection Registry

The connection registry provides powerful lifecycle management:

```rust
// Get registry statistics
let stats = manager.get_stats();
println!("Registry Stats:");
println!("  Total connections: {}", stats.registry.total_connections);
println!("  Connected: {}", stats.registry.connected_count);
println!("  Connecting: {}", stats.registry.connecting_count);
println!("  Failed: {}", stats.registry.failed_count);

// Manual connection management
let registry = manager.get_registry();

// Get all connected relays
let connected = registry.get_connected_relays().await;
println!("Connected to {} relays", connected.len());

// Check connection status
for conn in connected {
    println!("ğŸ”— {}: {} subscribers",
        conn.get_url(),
        conn.get_subscribers()
    );
}
```

## ğŸ›¡ï¸ Error Handling

Comprehensive error handling with meaningful context:

```rust
use nutscash_nostr::relays::RelayError;

match manager.get_relay("wss://invalid.relay.com").await {
    Ok(relay) => { /* Connection successful */ },
    Err(e) => {
        match e.downcast_ref::<RelayError>() {
            Some(RelayError::ConnectionTimeout) => {
                println!("â° Connection timed out - try again later");
            },
            Some(RelayError::InvalidURL { url }) => {
                println!("ğŸš« Invalid URL: {}", url);
            },
            Some(RelayError::TooManyConnections) => {
                println!("ğŸ”’ Too many concurrent connections");
            },
            _ => {
                println!("ğŸ’¥ Unknown error: {}", e);
            }
        }
    }
}
```

## ğŸ§ª Testing

The module includes comprehensive test coverage:

### Running Tests

```bash
# Run all relay tests
cargo test relays::

# Run specific test modules
cargo test relays::clean_relays::tests
cargo test relays::connections_registry::tests
cargo test relays::relay_connection::tests

# Run with output
cargo test relays:: -- --nocapture
```

### Test Categories

- **ğŸ§¹ URL Cleaning Tests**: Validate URL filtering and normalization
- **ğŸ”— Connection Tests**: Test connection lifecycle and error handling
- **ğŸ“‹ Registry Tests**: Verify registry operations and statistics
- **âš¡ Manager Tests**: Integration tests for the full system
- **ğŸ Safari Tests**: Browser-specific behavior validation

## ğŸ” Debugging & Monitoring

### Logging Configuration

Enable detailed logging for debugging:

```rust
use tracing::{info, debug, warn, error};
use tracing_subscriber;

// Initialize logging
tracing_subscriber::fmt()
    .with_max_level(tracing::Level::DEBUG)
    .init();

// Relay operations will now log detailed information
let manager = RelayConnectionManager::new(
    Duration::from_secs(10),
    3
);
```

### Performance Monitoring

```rust
// Monitor connection performance
let stats = manager.get_stats();
println!("ğŸ“ˆ Performance Metrics:");
println!("  Uptime: {:?}", stats.uptime);
println!("  Success rate: {:.1}%",
    (stats.successful_conns as f64 / stats.total_requests as f64) * 100.0
);
println!("  Last cleanup: {:?}", stats.last_cleanup);

// Memory usage tracking
println!("  Active connections: {}", stats.active_connections);
println!("  Registry size: {}", stats.registry.total_connections);
```

## ğŸš€ Advanced Usage

### Custom Relay Options

```rust
use nutscash_nostr::relays::{Relay, WithNoticeHandler, WithCustomHandler};

// Create relay with custom handlers
let notice_handler = Arc::new(|notice: String| {
    println!("ğŸ“¢ Notice from relay: {}", notice);
});

let custom_handler = Arc::new(|message: String| {
    println!("ğŸ”§ Custom message: {}", message);
});

let relay = Relay::connect(
    "wss://relay.example.com".to_string(),
    vec![
        Box::new(WithNoticeHandler(notice_handler)),
        Box::new(WithCustomHandler(custom_handler)),
    ]
).await?;
```

## ğŸ”„ Migration Guide

### From Previous Versions

If migrating from an older version of the relay system:

1. **Update imports**: Module structure has been reorganized
2. **Async compatibility**: All operations are now async
3. **Error handling**: New error types with better context
4. **Configuration**: New configuration options available

### Breaking Changes

- `RelayManager` is now fully async
- Connection methods return `Result` types
- URL cleaning is now mandatory for security

## ğŸ¤ Contributing

### Development Setup

```bash
# Clone and setup
git clone <repository>
cd nutscash/src/model/nostr-rust

# Run tests
cargo test --lib relays::

# Check formatting
cargo fmt --check

# Lint code
cargo clippy -- -D warnings
```

### Code Style

- Use `async/await` throughout
- Implement proper error handling with context
- Add comprehensive tests for new features
- Document public APIs thoroughly
- Follow Rust naming conventions

## ğŸ“‹ Current Status

### âœ… Completed Features
- âœ… Basic relay connection management
- âœ… URL cleaning and validation
- âœ… Connection registry with statistics
- âœ… WASM-compatible WebSocket handling
- âœ… Safari-optimized connection coordination
- âœ… Automatic cleanup routines
- âœ… Comprehensive error handling
- âœ… Thread-safe operations
- âœ… Event publishing and subscriptions
- âœ… Connection pooling and reuse

### ğŸ”„ In Progress
- ğŸ”„ Advanced subscription optimization
- ğŸ”„ Connection multiplexing
- ğŸ”„ Enhanced metrics collection
- ğŸ”„ Performance optimizations

### ğŸ“… Planned Features
- âŒ NIP-42 (Authentication) support
- âŒ NIP-11 (Relay Information) integration
- âŒ Rate limiting and backoff strategies
- âŒ Advanced monitoring dashboard
- âŒ Connection pre-warming
- âŒ Intelligent relay selection algorithms

## ğŸ“š Dependencies

### Core Dependencies
- **`tokio`** (1.0+) - Async runtime and utilities
- **`nostr`** (0.29+) - Nostr protocol implementation
- **`anyhow`** (1.0+) - Error handling
- **`serde`** (1.0+) - Serialization support
- **`tracing`** (0.1+) - Structured logging

### WASM Dependencies
- **`tokio-tungstenite-wasm`** (0.5+) - Unified WebSocket support
- **`wasm-bindgen`** (0.2+) - JavaScript interop
- **`web-sys`** (0.3+) - Browser API bindings

### Development Dependencies
- **`tokio-test`** - Async testing utilities
- **`criterion`** - Benchmarking framework

## ğŸ“„ License

This code is part of the NutsCash project and follows the same license terms.

---

**Built with â¤ï¸ for the Nostr ecosystem**

For more information, see the [NutsCash project documentation](../../README.md).
