// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod nostr {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fb {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTENT_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTENT_DATA: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTENT_DATA: [ContentData; 9] = [
  ContentData::NONE,
  ContentData::CodeData,
  ContentData::HashtagData,
  ContentData::CashuData,
  ContentData::ImageData,
  ContentData::VideoData,
  ContentData::MediaGroupData,
  ContentData::NostrData,
  ContentData::LinkPreviewData,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ContentData(pub u8);
#[allow(non_upper_case_globals)]
impl ContentData {
  pub const NONE: Self = Self(0);
  pub const CodeData: Self = Self(1);
  pub const HashtagData: Self = Self(2);
  pub const CashuData: Self = Self(3);
  pub const ImageData: Self = Self(4);
  pub const VideoData: Self = Self(5);
  pub const MediaGroupData: Self = Self(6);
  pub const NostrData: Self = Self(7);
  pub const LinkPreviewData: Self = Self(8);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CodeData,
    Self::HashtagData,
    Self::CashuData,
    Self::ImageData,
    Self::VideoData,
    Self::MediaGroupData,
    Self::NostrData,
    Self::LinkPreviewData,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CodeData => Some("CodeData"),
      Self::HashtagData => Some("HashtagData"),
      Self::CashuData => Some("CashuData"),
      Self::ImageData => Some("ImageData"),
      Self::VideoData => Some("VideoData"),
      Self::MediaGroupData => Some("MediaGroupData"),
      Self::NostrData => Some("NostrData"),
      Self::LinkPreviewData => Some("LinkPreviewData"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ContentData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ContentData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ContentData {
    type Output = ContentData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ContentData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ContentData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ContentData {}
pub struct ContentDataUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum ContentDataT {
  NONE,
  CodeData(Box<CodeDataT>),
  HashtagData(Box<HashtagDataT>),
  CashuData(Box<CashuDataT>),
  ImageData(Box<ImageDataT>),
  VideoData(Box<VideoDataT>),
  MediaGroupData(Box<MediaGroupDataT>),
  NostrData(Box<NostrDataT>),
  LinkPreviewData(Box<LinkPreviewDataT>),
}
impl Default for ContentDataT {
  fn default() -> Self {
    Self::NONE
  }
}
impl ContentDataT {
  pub fn content_data_type(&self) -> ContentData {
    match self {
      Self::NONE => ContentData::NONE,
      Self::CodeData(_) => ContentData::CodeData,
      Self::HashtagData(_) => ContentData::HashtagData,
      Self::CashuData(_) => ContentData::CashuData,
      Self::ImageData(_) => ContentData::ImageData,
      Self::VideoData(_) => ContentData::VideoData,
      Self::MediaGroupData(_) => ContentData::MediaGroupData,
      Self::NostrData(_) => ContentData::NostrData,
      Self::LinkPreviewData(_) => ContentData::LinkPreviewData,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::CodeData(v) => Some(v.pack(fbb).as_union_value()),
      Self::HashtagData(v) => Some(v.pack(fbb).as_union_value()),
      Self::CashuData(v) => Some(v.pack(fbb).as_union_value()),
      Self::ImageData(v) => Some(v.pack(fbb).as_union_value()),
      Self::VideoData(v) => Some(v.pack(fbb).as_union_value()),
      Self::MediaGroupData(v) => Some(v.pack(fbb).as_union_value()),
      Self::NostrData(v) => Some(v.pack(fbb).as_union_value()),
      Self::LinkPreviewData(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned CodeDataT, setting the union to NONE.
  pub fn take_code_data(&mut self) -> Option<Box<CodeDataT>> {
    if let Self::CodeData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CodeData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CodeDataT.
  pub fn as_code_data(&self) -> Option<&CodeDataT> {
    if let Self::CodeData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CodeDataT.
  pub fn as_code_data_mut(&mut self) -> Option<&mut CodeDataT> {
    if let Self::CodeData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned HashtagDataT, setting the union to NONE.
  pub fn take_hashtag_data(&mut self) -> Option<Box<HashtagDataT>> {
    if let Self::HashtagData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::HashtagData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the HashtagDataT.
  pub fn as_hashtag_data(&self) -> Option<&HashtagDataT> {
    if let Self::HashtagData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the HashtagDataT.
  pub fn as_hashtag_data_mut(&mut self) -> Option<&mut HashtagDataT> {
    if let Self::HashtagData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CashuDataT, setting the union to NONE.
  pub fn take_cashu_data(&mut self) -> Option<Box<CashuDataT>> {
    if let Self::CashuData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CashuData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CashuDataT.
  pub fn as_cashu_data(&self) -> Option<&CashuDataT> {
    if let Self::CashuData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CashuDataT.
  pub fn as_cashu_data_mut(&mut self) -> Option<&mut CashuDataT> {
    if let Self::CashuData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ImageDataT, setting the union to NONE.
  pub fn take_image_data(&mut self) -> Option<Box<ImageDataT>> {
    if let Self::ImageData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ImageData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ImageDataT.
  pub fn as_image_data(&self) -> Option<&ImageDataT> {
    if let Self::ImageData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ImageDataT.
  pub fn as_image_data_mut(&mut self) -> Option<&mut ImageDataT> {
    if let Self::ImageData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned VideoDataT, setting the union to NONE.
  pub fn take_video_data(&mut self) -> Option<Box<VideoDataT>> {
    if let Self::VideoData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::VideoData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the VideoDataT.
  pub fn as_video_data(&self) -> Option<&VideoDataT> {
    if let Self::VideoData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the VideoDataT.
  pub fn as_video_data_mut(&mut self) -> Option<&mut VideoDataT> {
    if let Self::VideoData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MediaGroupDataT, setting the union to NONE.
  pub fn take_media_group_data(&mut self) -> Option<Box<MediaGroupDataT>> {
    if let Self::MediaGroupData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MediaGroupData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MediaGroupDataT.
  pub fn as_media_group_data(&self) -> Option<&MediaGroupDataT> {
    if let Self::MediaGroupData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MediaGroupDataT.
  pub fn as_media_group_data_mut(&mut self) -> Option<&mut MediaGroupDataT> {
    if let Self::MediaGroupData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NostrDataT, setting the union to NONE.
  pub fn take_nostr_data(&mut self) -> Option<Box<NostrDataT>> {
    if let Self::NostrData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NostrData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NostrDataT.
  pub fn as_nostr_data(&self) -> Option<&NostrDataT> {
    if let Self::NostrData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NostrDataT.
  pub fn as_nostr_data_mut(&mut self) -> Option<&mut NostrDataT> {
    if let Self::NostrData(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LinkPreviewDataT, setting the union to NONE.
  pub fn take_link_preview_data(&mut self) -> Option<Box<LinkPreviewDataT>> {
    if let Self::LinkPreviewData(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LinkPreviewData(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LinkPreviewDataT.
  pub fn as_link_preview_data(&self) -> Option<&LinkPreviewDataT> {
    if let Self::LinkPreviewData(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LinkPreviewDataT.
  pub fn as_link_preview_data_mut(&mut self) -> Option<&mut LinkPreviewDataT> {
    if let Self::LinkPreviewData(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REACTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REACTION_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REACTION_TYPE: [ReactionType; 4] = [
  ReactionType::Like,
  ReactionType::Dislike,
  ReactionType::Emoji,
  ReactionType::Custom,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReactionType(pub i8);
#[allow(non_upper_case_globals)]
impl ReactionType {
  pub const Like: Self = Self(0);
  pub const Dislike: Self = Self(1);
  pub const Emoji: Self = Self(2);
  pub const Custom: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Like,
    Self::Dislike,
    Self::Emoji,
    Self::Custom,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Like => Some("Like"),
      Self::Dislike => Some("Dislike"),
      Self::Emoji => Some("Emoji"),
      Self::Custom => Some("Custom"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ReactionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ReactionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ReactionType {
    type Output = ReactionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ReactionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ReactionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ReactionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SUBSCRIBE_KIND: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SUBSCRIBE_KIND: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SUBSCRIBE_KIND: [SubscribeKind; 6] = [
  SubscribeKind::CachedEvent,
  SubscribeKind::FetchedEvent,
  SubscribeKind::Count,
  SubscribeKind::ConnectionStatus,
  SubscribeKind::Eoce,
  SubscribeKind::BufferFull,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SubscribeKind(pub i8);
#[allow(non_upper_case_globals)]
impl SubscribeKind {
  pub const CachedEvent: Self = Self(0);
  pub const FetchedEvent: Self = Self(1);
  pub const Count: Self = Self(2);
  pub const ConnectionStatus: Self = Self(3);
  pub const Eoce: Self = Self(4);
  pub const BufferFull: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CachedEvent,
    Self::FetchedEvent,
    Self::Count,
    Self::ConnectionStatus,
    Self::Eoce,
    Self::BufferFull,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CachedEvent => Some("CachedEvent"),
      Self::FetchedEvent => Some("FetchedEvent"),
      Self::Count => Some("Count"),
      Self::ConnectionStatus => Some("ConnectionStatus"),
      Self::Eoce => Some("Eoce"),
      Self::BufferFull => Some("BufferFull"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SubscribeKind {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SubscribeKind {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SubscribeKind {
    type Output = SubscribeKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SubscribeKind {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SubscribeKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SubscribeKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_TYPE: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_TYPE: u32 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 6] = [
  MessageType::ParsedNostrEvent,
  MessageType::ConnectionStatus,
  MessageType::CountResponse,
  MessageType::Eoce,
  MessageType::BufferFull,
  MessageType::ValidProofs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageType(pub u32);
#[allow(non_upper_case_globals)]
impl MessageType {
  pub const ParsedNostrEvent: Self = Self(0);
  pub const ConnectionStatus: Self = Self(1);
  pub const CountResponse: Self = Self(2);
  pub const Eoce: Self = Self(3);
  pub const BufferFull: Self = Self(4);
  pub const ValidProofs: Self = Self(5);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ParsedNostrEvent,
    Self::ConnectionStatus,
    Self::CountResponse,
    Self::Eoce,
    Self::BufferFull,
    Self::ValidProofs,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ParsedNostrEvent => Some("ParsedNostrEvent"),
      Self::ConnectionStatus => Some("ConnectionStatus"),
      Self::CountResponse => Some("CountResponse"),
      Self::Eoce => Some("Eoce"),
      Self::BufferFull => Some("BufferFull"),
      Self::ValidProofs => Some("ValidProofs"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessageType {
    type Output = MessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessageType {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARSED_DATA_UNION: u32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARSED_DATA_UNION: u32 = 39089;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARSED_DATA_UNION: [ParsedDataUnion; 16] = [
  ParsedDataUnion::Kind0Parsed,
  ParsedDataUnion::Kind1Parsed,
  ParsedDataUnion::Kind3Parsed,
  ParsedDataUnion::Kind4Parsed,
  ParsedDataUnion::Kind6Parsed,
  ParsedDataUnion::Kind7Parsed,
  ParsedDataUnion::Kind17Parsed,
  ParsedDataUnion::Kind7374Parsed,
  ParsedDataUnion::Kind7375Parsed,
  ParsedDataUnion::Kind7376Parsed,
  ParsedDataUnion::Kind9321Parsed,
  ParsedDataUnion::Kind9735Parsed,
  ParsedDataUnion::Kind10002Parsed,
  ParsedDataUnion::Kind10019Parsed,
  ParsedDataUnion::Kind17375Parsed,
  ParsedDataUnion::Kind39089Parsed,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ParsedDataUnion(pub u32);
#[allow(non_upper_case_globals)]
impl ParsedDataUnion {
  pub const Kind0Parsed: Self = Self(0);
  pub const Kind1Parsed: Self = Self(1);
  pub const Kind3Parsed: Self = Self(3);
  pub const Kind4Parsed: Self = Self(4);
  pub const Kind6Parsed: Self = Self(6);
  pub const Kind7Parsed: Self = Self(7);
  pub const Kind17Parsed: Self = Self(17);
  pub const Kind7374Parsed: Self = Self(7374);
  pub const Kind7375Parsed: Self = Self(7375);
  pub const Kind7376Parsed: Self = Self(7376);
  pub const Kind9321Parsed: Self = Self(9321);
  pub const Kind9735Parsed: Self = Self(9735);
  pub const Kind10002Parsed: Self = Self(10002);
  pub const Kind10019Parsed: Self = Self(10019);
  pub const Kind17375Parsed: Self = Self(17375);
  pub const Kind39089Parsed: Self = Self(39089);

  pub const ENUM_MIN: u32 = 0;
  pub const ENUM_MAX: u32 = 39089;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Kind0Parsed,
    Self::Kind1Parsed,
    Self::Kind3Parsed,
    Self::Kind4Parsed,
    Self::Kind6Parsed,
    Self::Kind7Parsed,
    Self::Kind17Parsed,
    Self::Kind7374Parsed,
    Self::Kind7375Parsed,
    Self::Kind7376Parsed,
    Self::Kind9321Parsed,
    Self::Kind9735Parsed,
    Self::Kind10002Parsed,
    Self::Kind10019Parsed,
    Self::Kind17375Parsed,
    Self::Kind39089Parsed,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Kind0Parsed => Some("Kind0Parsed"),
      Self::Kind1Parsed => Some("Kind1Parsed"),
      Self::Kind3Parsed => Some("Kind3Parsed"),
      Self::Kind4Parsed => Some("Kind4Parsed"),
      Self::Kind6Parsed => Some("Kind6Parsed"),
      Self::Kind7Parsed => Some("Kind7Parsed"),
      Self::Kind17Parsed => Some("Kind17Parsed"),
      Self::Kind7374Parsed => Some("Kind7374Parsed"),
      Self::Kind7375Parsed => Some("Kind7375Parsed"),
      Self::Kind7376Parsed => Some("Kind7376Parsed"),
      Self::Kind9321Parsed => Some("Kind9321Parsed"),
      Self::Kind9735Parsed => Some("Kind9735Parsed"),
      Self::Kind10002Parsed => Some("Kind10002Parsed"),
      Self::Kind10019Parsed => Some("Kind10019Parsed"),
      Self::Kind17375Parsed => Some("Kind17375Parsed"),
      Self::Kind39089Parsed => Some("Kind39089Parsed"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ParsedDataUnion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ParsedDataUnion {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ParsedDataUnion {
    type Output = ParsedDataUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ParsedDataUnion {
  type Scalar = u32;
  #[inline]
  fn to_little_endian(self) -> u32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u32) -> Self {
    let b = u32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ParsedDataUnion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ParsedDataUnion {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARSED_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARSED_DATA: u8 = 16;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARSED_DATA: [ParsedData; 17] = [
  ParsedData::NONE,
  ParsedData::Kind0Parsed,
  ParsedData::Kind1Parsed,
  ParsedData::Kind3Parsed,
  ParsedData::Kind4Parsed,
  ParsedData::Kind6Parsed,
  ParsedData::Kind7Parsed,
  ParsedData::Kind17Parsed,
  ParsedData::Kind10002Parsed,
  ParsedData::Kind10019Parsed,
  ParsedData::Kind17375Parsed,
  ParsedData::Kind39089Parsed,
  ParsedData::Kind7374Parsed,
  ParsedData::Kind7375Parsed,
  ParsedData::Kind7376Parsed,
  ParsedData::Kind9321Parsed,
  ParsedData::Kind9735Parsed,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ParsedData(pub u8);
#[allow(non_upper_case_globals)]
impl ParsedData {
  pub const NONE: Self = Self(0);
  pub const Kind0Parsed: Self = Self(1);
  pub const Kind1Parsed: Self = Self(2);
  pub const Kind3Parsed: Self = Self(3);
  pub const Kind4Parsed: Self = Self(4);
  pub const Kind6Parsed: Self = Self(5);
  pub const Kind7Parsed: Self = Self(6);
  pub const Kind17Parsed: Self = Self(7);
  pub const Kind10002Parsed: Self = Self(8);
  pub const Kind10019Parsed: Self = Self(9);
  pub const Kind17375Parsed: Self = Self(10);
  pub const Kind39089Parsed: Self = Self(11);
  pub const Kind7374Parsed: Self = Self(12);
  pub const Kind7375Parsed: Self = Self(13);
  pub const Kind7376Parsed: Self = Self(14);
  pub const Kind9321Parsed: Self = Self(15);
  pub const Kind9735Parsed: Self = Self(16);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 16;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Kind0Parsed,
    Self::Kind1Parsed,
    Self::Kind3Parsed,
    Self::Kind4Parsed,
    Self::Kind6Parsed,
    Self::Kind7Parsed,
    Self::Kind17Parsed,
    Self::Kind10002Parsed,
    Self::Kind10019Parsed,
    Self::Kind17375Parsed,
    Self::Kind39089Parsed,
    Self::Kind7374Parsed,
    Self::Kind7375Parsed,
    Self::Kind7376Parsed,
    Self::Kind9321Parsed,
    Self::Kind9735Parsed,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Kind0Parsed => Some("Kind0Parsed"),
      Self::Kind1Parsed => Some("Kind1Parsed"),
      Self::Kind3Parsed => Some("Kind3Parsed"),
      Self::Kind4Parsed => Some("Kind4Parsed"),
      Self::Kind6Parsed => Some("Kind6Parsed"),
      Self::Kind7Parsed => Some("Kind7Parsed"),
      Self::Kind17Parsed => Some("Kind17Parsed"),
      Self::Kind10002Parsed => Some("Kind10002Parsed"),
      Self::Kind10019Parsed => Some("Kind10019Parsed"),
      Self::Kind17375Parsed => Some("Kind17375Parsed"),
      Self::Kind39089Parsed => Some("Kind39089Parsed"),
      Self::Kind7374Parsed => Some("Kind7374Parsed"),
      Self::Kind7375Parsed => Some("Kind7375Parsed"),
      Self::Kind7376Parsed => Some("Kind7376Parsed"),
      Self::Kind9321Parsed => Some("Kind9321Parsed"),
      Self::Kind9735Parsed => Some("Kind9735Parsed"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ParsedData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ParsedData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ParsedData {
    type Output = ParsedData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ParsedData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ParsedData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ParsedData {}
pub struct ParsedDataUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum ParsedDataT {
  NONE,
  Kind0Parsed(Box<Kind0ParsedT>),
  Kind1Parsed(Box<Kind1ParsedT>),
  Kind3Parsed(Box<Kind3ParsedT>),
  Kind4Parsed(Box<Kind4ParsedT>),
  Kind6Parsed(Box<Kind6ParsedT>),
  Kind7Parsed(Box<Kind7ParsedT>),
  Kind17Parsed(Box<Kind17ParsedT>),
  Kind10002Parsed(Box<Kind10002ParsedT>),
  Kind10019Parsed(Box<Kind10019ParsedT>),
  Kind17375Parsed(Box<Kind17375ParsedT>),
  Kind39089Parsed(Box<Kind39089ParsedT>),
  Kind7374Parsed(Box<Kind7374ParsedT>),
  Kind7375Parsed(Box<Kind7375ParsedT>),
  Kind7376Parsed(Box<Kind7376ParsedT>),
  Kind9321Parsed(Box<Kind9321ParsedT>),
  Kind9735Parsed(Box<Kind9735ParsedT>),
}
impl Default for ParsedDataT {
  fn default() -> Self {
    Self::NONE
  }
}
impl ParsedDataT {
  pub fn parsed_data_type(&self) -> ParsedData {
    match self {
      Self::NONE => ParsedData::NONE,
      Self::Kind0Parsed(_) => ParsedData::Kind0Parsed,
      Self::Kind1Parsed(_) => ParsedData::Kind1Parsed,
      Self::Kind3Parsed(_) => ParsedData::Kind3Parsed,
      Self::Kind4Parsed(_) => ParsedData::Kind4Parsed,
      Self::Kind6Parsed(_) => ParsedData::Kind6Parsed,
      Self::Kind7Parsed(_) => ParsedData::Kind7Parsed,
      Self::Kind17Parsed(_) => ParsedData::Kind17Parsed,
      Self::Kind10002Parsed(_) => ParsedData::Kind10002Parsed,
      Self::Kind10019Parsed(_) => ParsedData::Kind10019Parsed,
      Self::Kind17375Parsed(_) => ParsedData::Kind17375Parsed,
      Self::Kind39089Parsed(_) => ParsedData::Kind39089Parsed,
      Self::Kind7374Parsed(_) => ParsedData::Kind7374Parsed,
      Self::Kind7375Parsed(_) => ParsedData::Kind7375Parsed,
      Self::Kind7376Parsed(_) => ParsedData::Kind7376Parsed,
      Self::Kind9321Parsed(_) => ParsedData::Kind9321Parsed,
      Self::Kind9735Parsed(_) => ParsedData::Kind9735Parsed,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Kind0Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind1Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind3Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind4Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind6Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind17Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind10002Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind10019Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind17375Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind39089Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7374Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7375Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind7376Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind9321Parsed(v) => Some(v.pack(fbb).as_union_value()),
      Self::Kind9735Parsed(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned Kind0ParsedT, setting the union to NONE.
  pub fn take_kind_0_parsed(&mut self) -> Option<Box<Kind0ParsedT>> {
    if let Self::Kind0Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind0Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind0ParsedT.
  pub fn as_kind_0_parsed(&self) -> Option<&Kind0ParsedT> {
    if let Self::Kind0Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind0ParsedT.
  pub fn as_kind_0_parsed_mut(&mut self) -> Option<&mut Kind0ParsedT> {
    if let Self::Kind0Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind1ParsedT, setting the union to NONE.
  pub fn take_kind_1_parsed(&mut self) -> Option<Box<Kind1ParsedT>> {
    if let Self::Kind1Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind1Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind1ParsedT.
  pub fn as_kind_1_parsed(&self) -> Option<&Kind1ParsedT> {
    if let Self::Kind1Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind1ParsedT.
  pub fn as_kind_1_parsed_mut(&mut self) -> Option<&mut Kind1ParsedT> {
    if let Self::Kind1Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind3ParsedT, setting the union to NONE.
  pub fn take_kind_3_parsed(&mut self) -> Option<Box<Kind3ParsedT>> {
    if let Self::Kind3Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind3Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind3ParsedT.
  pub fn as_kind_3_parsed(&self) -> Option<&Kind3ParsedT> {
    if let Self::Kind3Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind3ParsedT.
  pub fn as_kind_3_parsed_mut(&mut self) -> Option<&mut Kind3ParsedT> {
    if let Self::Kind3Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind4ParsedT, setting the union to NONE.
  pub fn take_kind_4_parsed(&mut self) -> Option<Box<Kind4ParsedT>> {
    if let Self::Kind4Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind4Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind4ParsedT.
  pub fn as_kind_4_parsed(&self) -> Option<&Kind4ParsedT> {
    if let Self::Kind4Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind4ParsedT.
  pub fn as_kind_4_parsed_mut(&mut self) -> Option<&mut Kind4ParsedT> {
    if let Self::Kind4Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind6ParsedT, setting the union to NONE.
  pub fn take_kind_6_parsed(&mut self) -> Option<Box<Kind6ParsedT>> {
    if let Self::Kind6Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind6Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind6ParsedT.
  pub fn as_kind_6_parsed(&self) -> Option<&Kind6ParsedT> {
    if let Self::Kind6Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind6ParsedT.
  pub fn as_kind_6_parsed_mut(&mut self) -> Option<&mut Kind6ParsedT> {
    if let Self::Kind6Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7ParsedT, setting the union to NONE.
  pub fn take_kind_7_parsed(&mut self) -> Option<Box<Kind7ParsedT>> {
    if let Self::Kind7Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7ParsedT.
  pub fn as_kind_7_parsed(&self) -> Option<&Kind7ParsedT> {
    if let Self::Kind7Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7ParsedT.
  pub fn as_kind_7_parsed_mut(&mut self) -> Option<&mut Kind7ParsedT> {
    if let Self::Kind7Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind17ParsedT, setting the union to NONE.
  pub fn take_kind_17_parsed(&mut self) -> Option<Box<Kind17ParsedT>> {
    if let Self::Kind17Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind17Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind17ParsedT.
  pub fn as_kind_17_parsed(&self) -> Option<&Kind17ParsedT> {
    if let Self::Kind17Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind17ParsedT.
  pub fn as_kind_17_parsed_mut(&mut self) -> Option<&mut Kind17ParsedT> {
    if let Self::Kind17Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind10002ParsedT, setting the union to NONE.
  pub fn take_kind_10002_parsed(&mut self) -> Option<Box<Kind10002ParsedT>> {
    if let Self::Kind10002Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind10002Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind10002ParsedT.
  pub fn as_kind_10002_parsed(&self) -> Option<&Kind10002ParsedT> {
    if let Self::Kind10002Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind10002ParsedT.
  pub fn as_kind_10002_parsed_mut(&mut self) -> Option<&mut Kind10002ParsedT> {
    if let Self::Kind10002Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind10019ParsedT, setting the union to NONE.
  pub fn take_kind_10019_parsed(&mut self) -> Option<Box<Kind10019ParsedT>> {
    if let Self::Kind10019Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind10019Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind10019ParsedT.
  pub fn as_kind_10019_parsed(&self) -> Option<&Kind10019ParsedT> {
    if let Self::Kind10019Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind10019ParsedT.
  pub fn as_kind_10019_parsed_mut(&mut self) -> Option<&mut Kind10019ParsedT> {
    if let Self::Kind10019Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind17375ParsedT, setting the union to NONE.
  pub fn take_kind_17375_parsed(&mut self) -> Option<Box<Kind17375ParsedT>> {
    if let Self::Kind17375Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind17375Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind17375ParsedT.
  pub fn as_kind_17375_parsed(&self) -> Option<&Kind17375ParsedT> {
    if let Self::Kind17375Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind17375ParsedT.
  pub fn as_kind_17375_parsed_mut(&mut self) -> Option<&mut Kind17375ParsedT> {
    if let Self::Kind17375Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind39089ParsedT, setting the union to NONE.
  pub fn take_kind_39089_parsed(&mut self) -> Option<Box<Kind39089ParsedT>> {
    if let Self::Kind39089Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind39089Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind39089ParsedT.
  pub fn as_kind_39089_parsed(&self) -> Option<&Kind39089ParsedT> {
    if let Self::Kind39089Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind39089ParsedT.
  pub fn as_kind_39089_parsed_mut(&mut self) -> Option<&mut Kind39089ParsedT> {
    if let Self::Kind39089Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7374ParsedT, setting the union to NONE.
  pub fn take_kind_7374_parsed(&mut self) -> Option<Box<Kind7374ParsedT>> {
    if let Self::Kind7374Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7374Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7374ParsedT.
  pub fn as_kind_7374_parsed(&self) -> Option<&Kind7374ParsedT> {
    if let Self::Kind7374Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7374ParsedT.
  pub fn as_kind_7374_parsed_mut(&mut self) -> Option<&mut Kind7374ParsedT> {
    if let Self::Kind7374Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7375ParsedT, setting the union to NONE.
  pub fn take_kind_7375_parsed(&mut self) -> Option<Box<Kind7375ParsedT>> {
    if let Self::Kind7375Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7375Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7375ParsedT.
  pub fn as_kind_7375_parsed(&self) -> Option<&Kind7375ParsedT> {
    if let Self::Kind7375Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7375ParsedT.
  pub fn as_kind_7375_parsed_mut(&mut self) -> Option<&mut Kind7375ParsedT> {
    if let Self::Kind7375Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind7376ParsedT, setting the union to NONE.
  pub fn take_kind_7376_parsed(&mut self) -> Option<Box<Kind7376ParsedT>> {
    if let Self::Kind7376Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind7376Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind7376ParsedT.
  pub fn as_kind_7376_parsed(&self) -> Option<&Kind7376ParsedT> {
    if let Self::Kind7376Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind7376ParsedT.
  pub fn as_kind_7376_parsed_mut(&mut self) -> Option<&mut Kind7376ParsedT> {
    if let Self::Kind7376Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind9321ParsedT, setting the union to NONE.
  pub fn take_kind_9321_parsed(&mut self) -> Option<Box<Kind9321ParsedT>> {
    if let Self::Kind9321Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind9321Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind9321ParsedT.
  pub fn as_kind_9321_parsed(&self) -> Option<&Kind9321ParsedT> {
    if let Self::Kind9321Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind9321ParsedT.
  pub fn as_kind_9321_parsed_mut(&mut self) -> Option<&mut Kind9321ParsedT> {
    if let Self::Kind9321Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Kind9735ParsedT, setting the union to NONE.
  pub fn take_kind_9735_parsed(&mut self) -> Option<Box<Kind9735ParsedT>> {
    if let Self::Kind9735Parsed(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Kind9735Parsed(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Kind9735ParsedT.
  pub fn as_kind_9735_parsed(&self) -> Option<&Kind9735ParsedT> {
    if let Self::Kind9735Parsed(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Kind9735ParsedT.
  pub fn as_kind_9735_parsed_mut(&mut self) -> Option<&mut Kind9735ParsedT> {
    if let Self::Kind9735Parsed(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE: [Message; 7] = [
  Message::NONE,
  Message::ParsedEvent,
  Message::ConnectionStatus,
  Message::CountResponse,
  Message::Eoce,
  Message::BufferFull,
  Message::ValidProofs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Message(pub u8);
#[allow(non_upper_case_globals)]
impl Message {
  pub const NONE: Self = Self(0);
  pub const ParsedEvent: Self = Self(1);
  pub const ConnectionStatus: Self = Self(2);
  pub const CountResponse: Self = Self(3);
  pub const Eoce: Self = Self(4);
  pub const BufferFull: Self = Self(5);
  pub const ValidProofs: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ParsedEvent,
    Self::ConnectionStatus,
    Self::CountResponse,
    Self::Eoce,
    Self::BufferFull,
    Self::ValidProofs,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ParsedEvent => Some("ParsedEvent"),
      Self::ConnectionStatus => Some("ConnectionStatus"),
      Self::CountResponse => Some("CountResponse"),
      Self::Eoce => Some("Eoce"),
      Self::BufferFull => Some("BufferFull"),
      Self::ValidProofs => Some("ValidProofs"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Message {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Message {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Message {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Message {}
pub struct MessageUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum MessageT {
  NONE,
  ParsedEvent(Box<ParsedEventT>),
  ConnectionStatus(Box<ConnectionStatusT>),
  CountResponse(Box<CountResponseT>),
  Eoce(Box<EoceT>),
  BufferFull(Box<BufferFullT>),
  ValidProofs(Box<ValidProofsT>),
}
impl Default for MessageT {
  fn default() -> Self {
    Self::NONE
  }
}
impl MessageT {
  pub fn message_type(&self) -> Message {
    match self {
      Self::NONE => Message::NONE,
      Self::ParsedEvent(_) => Message::ParsedEvent,
      Self::ConnectionStatus(_) => Message::ConnectionStatus,
      Self::CountResponse(_) => Message::CountResponse,
      Self::Eoce(_) => Message::Eoce,
      Self::BufferFull(_) => Message::BufferFull,
      Self::ValidProofs(_) => Message::ValidProofs,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::ParsedEvent(v) => Some(v.pack(fbb).as_union_value()),
      Self::ConnectionStatus(v) => Some(v.pack(fbb).as_union_value()),
      Self::CountResponse(v) => Some(v.pack(fbb).as_union_value()),
      Self::Eoce(v) => Some(v.pack(fbb).as_union_value()),
      Self::BufferFull(v) => Some(v.pack(fbb).as_union_value()),
      Self::ValidProofs(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned ParsedEventT, setting the union to NONE.
  pub fn take_parsed_event(&mut self) -> Option<Box<ParsedEventT>> {
    if let Self::ParsedEvent(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ParsedEvent(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ParsedEventT.
  pub fn as_parsed_event(&self) -> Option<&ParsedEventT> {
    if let Self::ParsedEvent(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ParsedEventT.
  pub fn as_parsed_event_mut(&mut self) -> Option<&mut ParsedEventT> {
    if let Self::ParsedEvent(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ConnectionStatusT, setting the union to NONE.
  pub fn take_connection_status(&mut self) -> Option<Box<ConnectionStatusT>> {
    if let Self::ConnectionStatus(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ConnectionStatus(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ConnectionStatusT.
  pub fn as_connection_status(&self) -> Option<&ConnectionStatusT> {
    if let Self::ConnectionStatus(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ConnectionStatusT.
  pub fn as_connection_status_mut(&mut self) -> Option<&mut ConnectionStatusT> {
    if let Self::ConnectionStatus(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CountResponseT, setting the union to NONE.
  pub fn take_count_response(&mut self) -> Option<Box<CountResponseT>> {
    if let Self::CountResponse(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CountResponse(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CountResponseT.
  pub fn as_count_response(&self) -> Option<&CountResponseT> {
    if let Self::CountResponse(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CountResponseT.
  pub fn as_count_response_mut(&mut self) -> Option<&mut CountResponseT> {
    if let Self::CountResponse(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned EoceT, setting the union to NONE.
  pub fn take_eoce(&mut self) -> Option<Box<EoceT>> {
    if let Self::Eoce(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Eoce(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the EoceT.
  pub fn as_eoce(&self) -> Option<&EoceT> {
    if let Self::Eoce(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the EoceT.
  pub fn as_eoce_mut(&mut self) -> Option<&mut EoceT> {
    if let Self::Eoce(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned BufferFullT, setting the union to NONE.
  pub fn take_buffer_full(&mut self) -> Option<Box<BufferFullT>> {
    if let Self::BufferFull(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::BufferFull(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the BufferFullT.
  pub fn as_buffer_full(&self) -> Option<&BufferFullT> {
    if let Self::BufferFull(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the BufferFullT.
  pub fn as_buffer_full_mut(&mut self) -> Option<&mut BufferFullT> {
    if let Self::BufferFull(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ValidProofsT, setting the union to NONE.
  pub fn take_valid_proofs(&mut self) -> Option<Box<ValidProofsT>> {
    if let Self::ValidProofs(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ValidProofs(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ValidProofsT.
  pub fn as_valid_proofs(&self) -> Option<&ValidProofsT> {
    if let Self::ValidProofs(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ValidProofsT.
  pub fn as_valid_proofs_mut(&mut self) -> Option<&mut ValidProofsT> {
    if let Self::ValidProofs(v) = self { Some(v.as_mut()) } else { None }
  }
}
pub enum CodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CodeData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CodeData<'a> {
  type Inner = CodeData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CodeData<'a> {
  pub const VT_LANGUAGE: flatbuffers::VOffsetT = 4;
  pub const VT_CODE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CodeData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CodeDataArgs<'args>
  ) -> flatbuffers::WIPOffset<CodeData<'bldr>> {
    let mut builder = CodeDataBuilder::new(_fbb);
    if let Some(x) = args.code { builder.add_code(x); }
    if let Some(x) = args.language { builder.add_language(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CodeDataT {
    let language = self.language().map(|x| {
      x.to_string()
    });
    let code = {
      let x = self.code();
      x.to_string()
    };
    CodeDataT {
      language,
      code,
    }
  }

  #[inline]
  pub fn language(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeData::VT_LANGUAGE, None)}
  }
  #[inline]
  pub fn code(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodeData::VT_CODE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for CodeData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, true)?
     .finish();
    Ok(())
  }
}
pub struct CodeDataArgs<'a> {
    pub language: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CodeDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    CodeDataArgs {
      language: None,
      code: None, // required field
    }
  }
}

pub struct CodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CodeDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_language(&mut self, language: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeData::VT_LANGUAGE, language);
  }
  #[inline]
  pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodeData::VT_CODE, code);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CodeDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CodeDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CodeData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CodeData::VT_CODE,"code");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CodeData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CodeData");
      ds.field("language", &self.language());
      ds.field("code", &self.code());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CodeDataT {
  pub language: Option<String>,
  pub code: String,
}
impl Default for CodeDataT {
  fn default() -> Self {
    Self {
      language: None,
      code: "".to_string(),
    }
  }
}
impl CodeDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CodeData<'b>> {
    let language = self.language.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let code = Some({
      let x = &self.code;
      _fbb.create_string(x)
    });
    CodeData::create(_fbb, &CodeDataArgs{
      language,
      code,
    })
  }
}
pub enum HashtagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HashtagData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HashtagData<'a> {
  type Inner = HashtagData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HashtagData<'a> {
  pub const VT_TAG: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HashtagData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HashtagDataArgs<'args>
  ) -> flatbuffers::WIPOffset<HashtagData<'bldr>> {
    let mut builder = HashtagDataBuilder::new(_fbb);
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> HashtagDataT {
    let tag = {
      let x = self.tag();
      x.to_string()
    };
    HashtagDataT {
      tag,
    }
  }

  #[inline]
  pub fn tag(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HashtagData::VT_TAG, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for HashtagData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, true)?
     .finish();
    Ok(())
  }
}
pub struct HashtagDataArgs<'a> {
    pub tag: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HashtagDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    HashtagDataArgs {
      tag: None, // required field
    }
  }
}

pub struct HashtagDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HashtagDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HashtagData::VT_TAG, tag);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HashtagDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HashtagDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HashtagData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, HashtagData::VT_TAG,"tag");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HashtagData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HashtagData");
      ds.field("tag", &self.tag());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HashtagDataT {
  pub tag: String,
}
impl Default for HashtagDataT {
  fn default() -> Self {
    Self {
      tag: "".to_string(),
    }
  }
}
impl HashtagDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<HashtagData<'b>> {
    let tag = Some({
      let x = &self.tag;
      _fbb.create_string(x)
    });
    HashtagData::create(_fbb, &HashtagDataArgs{
      tag,
    })
  }
}
pub enum CashuDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CashuData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CashuData<'a> {
  type Inner = CashuData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CashuData<'a> {
  pub const VT_TOKEN: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CashuData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CashuDataArgs<'args>
  ) -> flatbuffers::WIPOffset<CashuData<'bldr>> {
    let mut builder = CashuDataBuilder::new(_fbb);
    if let Some(x) = args.token { builder.add_token(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CashuDataT {
    let token = {
      let x = self.token();
      x.to_string()
    };
    CashuDataT {
      token,
    }
  }

  #[inline]
  pub fn token(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CashuData::VT_TOKEN, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for CashuData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("token", Self::VT_TOKEN, true)?
     .finish();
    Ok(())
  }
}
pub struct CashuDataArgs<'a> {
    pub token: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CashuDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    CashuDataArgs {
      token: None, // required field
    }
  }
}

pub struct CashuDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CashuDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_token(&mut self, token: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CashuData::VT_TOKEN, token);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CashuDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CashuDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CashuData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CashuData::VT_TOKEN,"token");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CashuData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CashuData");
      ds.field("token", &self.token());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CashuDataT {
  pub token: String,
}
impl Default for CashuDataT {
  fn default() -> Self {
    Self {
      token: "".to_string(),
    }
  }
}
impl CashuDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CashuData<'b>> {
    let token = Some({
      let x = &self.token;
      _fbb.create_string(x)
    });
    CashuData::create(_fbb, &CashuDataArgs{
      token,
    })
  }
}
pub enum ImageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageData<'a> {
  type Inner = ImageData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ImageData<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_ALT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ImageDataArgs<'args>
  ) -> flatbuffers::WIPOffset<ImageData<'bldr>> {
    let mut builder = ImageDataBuilder::new(_fbb);
    if let Some(x) = args.alt { builder.add_alt(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ImageDataT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let alt = self.alt().map(|x| {
      x.to_string()
    });
    ImageDataT {
      url,
      alt,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageData::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn alt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageData::VT_ALT, None)}
  }
}

impl flatbuffers::Verifiable for ImageData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alt", Self::VT_ALT, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageDataArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alt: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ImageDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ImageDataArgs {
      url: None, // required field
      alt: None,
    }
  }
}

pub struct ImageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ImageDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageData::VT_URL, url);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageData::VT_ALT, alt);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ImageDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ImageDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ImageData::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageData");
      ds.field("url", &self.url());
      ds.field("alt", &self.alt());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ImageDataT {
  pub url: String,
  pub alt: Option<String>,
}
impl Default for ImageDataT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      alt: None,
    }
  }
}
impl ImageDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ImageData<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let alt = self.alt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ImageData::create(_fbb, &ImageDataArgs{
      url,
      alt,
    })
  }
}
pub enum VideoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VideoData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VideoData<'a> {
  type Inner = VideoData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VideoData<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_THUMBNAIL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VideoData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VideoDataArgs<'args>
  ) -> flatbuffers::WIPOffset<VideoData<'bldr>> {
    let mut builder = VideoDataBuilder::new(_fbb);
    if let Some(x) = args.thumbnail { builder.add_thumbnail(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> VideoDataT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let thumbnail = self.thumbnail().map(|x| {
      x.to_string()
    });
    VideoDataT {
      url,
      thumbnail,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VideoData::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn thumbnail(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VideoData::VT_THUMBNAIL, None)}
  }
}

impl flatbuffers::Verifiable for VideoData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("thumbnail", Self::VT_THUMBNAIL, false)?
     .finish();
    Ok(())
  }
}
pub struct VideoDataArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub thumbnail: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for VideoDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    VideoDataArgs {
      url: None, // required field
      thumbnail: None,
    }
  }
}

pub struct VideoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VideoDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VideoData::VT_URL, url);
  }
  #[inline]
  pub fn add_thumbnail(&mut self, thumbnail: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VideoData::VT_THUMBNAIL, thumbnail);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VideoDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VideoDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VideoData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, VideoData::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VideoData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VideoData");
      ds.field("url", &self.url());
      ds.field("thumbnail", &self.thumbnail());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VideoDataT {
  pub url: String,
  pub thumbnail: Option<String>,
}
impl Default for VideoDataT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      thumbnail: None,
    }
  }
}
impl VideoDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<VideoData<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let thumbnail = self.thumbnail.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    VideoData::create(_fbb, &VideoDataArgs{
      url,
      thumbnail,
    })
  }
}
pub enum MediaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MediaItem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MediaItem<'a> {
  type Inner = MediaItem<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MediaItem<'a> {
  pub const VT_IMAGE: flatbuffers::VOffsetT = 4;
  pub const VT_VIDEO: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MediaItem { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MediaItemArgs<'args>
  ) -> flatbuffers::WIPOffset<MediaItem<'bldr>> {
    let mut builder = MediaItemBuilder::new(_fbb);
    if let Some(x) = args.video { builder.add_video(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MediaItemT {
    let image = self.image().map(|x| {
      Box::new(x.unpack())
    });
    let video = self.video().map(|x| {
      Box::new(x.unpack())
    });
    MediaItemT {
      image,
      video,
    }
  }

  #[inline]
  pub fn image(&self) -> Option<ImageData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ImageData>>(MediaItem::VT_IMAGE, None)}
  }
  #[inline]
  pub fn video(&self) -> Option<VideoData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VideoData>>(MediaItem::VT_VIDEO, None)}
  }
}

impl flatbuffers::Verifiable for MediaItem<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ImageData>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VideoData>>("video", Self::VT_VIDEO, false)?
     .finish();
    Ok(())
  }
}
pub struct MediaItemArgs<'a> {
    pub image: Option<flatbuffers::WIPOffset<ImageData<'a>>>,
    pub video: Option<flatbuffers::WIPOffset<VideoData<'a>>>,
}
impl<'a> Default for MediaItemArgs<'a> {
  #[inline]
  fn default() -> Self {
    MediaItemArgs {
      image: None,
      video: None,
    }
  }
}

pub struct MediaItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MediaItemBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<ImageData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ImageData>>(MediaItem::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_video(&mut self, video: flatbuffers::WIPOffset<VideoData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VideoData>>(MediaItem::VT_VIDEO, video);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MediaItemBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MediaItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MediaItem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MediaItem<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MediaItem");
      ds.field("image", &self.image());
      ds.field("video", &self.video());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MediaItemT {
  pub image: Option<Box<ImageDataT>>,
  pub video: Option<Box<VideoDataT>>,
}
impl Default for MediaItemT {
  fn default() -> Self {
    Self {
      image: None,
      video: None,
    }
  }
}
impl MediaItemT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MediaItem<'b>> {
    let image = self.image.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let video = self.video.as_ref().map(|x|{
      x.pack(_fbb)
    });
    MediaItem::create(_fbb, &MediaItemArgs{
      image,
      video,
    })
  }
}
pub enum MediaGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MediaGroupData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MediaGroupData<'a> {
  type Inner = MediaGroupData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MediaGroupData<'a> {
  pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MediaGroupData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MediaGroupDataArgs<'args>
  ) -> flatbuffers::WIPOffset<MediaGroupData<'bldr>> {
    let mut builder = MediaGroupDataBuilder::new(_fbb);
    if let Some(x) = args.items { builder.add_items(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MediaGroupDataT {
    let items = self.items().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MediaGroupDataT {
      items,
    }
  }

  #[inline]
  pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MediaItem<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MediaItem>>>>(MediaGroupData::VT_ITEMS, None)}
  }
}

impl flatbuffers::Verifiable for MediaGroupData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MediaItem>>>>("items", Self::VT_ITEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct MediaGroupDataArgs<'a> {
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MediaItem<'a>>>>>,
}
impl<'a> Default for MediaGroupDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MediaGroupDataArgs {
      items: None,
    }
  }
}

pub struct MediaGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MediaGroupDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_items(&mut self, items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MediaItem<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MediaGroupData::VT_ITEMS, items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MediaGroupDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MediaGroupDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MediaGroupData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MediaGroupData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MediaGroupData");
      ds.field("items", &self.items());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MediaGroupDataT {
  pub items: Option<Vec<MediaItemT>>,
}
impl Default for MediaGroupDataT {
  fn default() -> Self {
    Self {
      items: None,
    }
  }
}
impl MediaGroupDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MediaGroupData<'b>> {
    let items = self.items.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MediaGroupData::create(_fbb, &MediaGroupDataArgs{
      items,
    })
  }
}
pub enum NostrDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NostrData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NostrData<'a> {
  type Inner = NostrData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NostrData<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITY: flatbuffers::VOffsetT = 6;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 8;
  pub const VT_AUTHOR: flatbuffers::VOffsetT = 10;
  pub const VT_KIND: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NostrData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NostrDataArgs<'args>
  ) -> flatbuffers::WIPOffset<NostrData<'bldr>> {
    let mut builder = NostrDataBuilder::new(_fbb);
    builder.add_kind(args.kind);
    if let Some(x) = args.author { builder.add_author(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.entity { builder.add_entity(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> NostrDataT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let entity = {
      let x = self.entity();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let author = self.author().map(|x| {
      x.to_string()
    });
    let kind = self.kind();
    NostrDataT {
      id,
      entity,
      relays,
      author,
      kind,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrData::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn entity(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrData::VT_ENTITY, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(NostrData::VT_RELAYS, None)}
  }
  #[inline]
  pub fn author(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrData::VT_AUTHOR, None)}
  }
  #[inline]
  pub fn kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(NostrData::VT_KIND, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for NostrData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entity", Self::VT_ENTITY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("author", Self::VT_AUTHOR, false)?
     .visit_field::<u64>("kind", Self::VT_KIND, false)?
     .finish();
    Ok(())
  }
}
pub struct NostrDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entity: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub author: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u64,
}
impl<'a> Default for NostrDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    NostrDataArgs {
      id: None, // required field
      entity: None, // required field
      relays: None,
      author: None,
      kind: 0,
    }
  }
}

pub struct NostrDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NostrDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_ID, id);
  }
  #[inline]
  pub fn add_entity(&mut self, entity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_ENTITY, entity);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_author(&mut self, author: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrData::VT_AUTHOR, author);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u64) {
    self.fbb_.push_slot::<u64>(NostrData::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NostrDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NostrDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NostrData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, NostrData::VT_ID,"id");
    self.fbb_.required(o, NostrData::VT_ENTITY,"entity");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NostrData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NostrData");
      ds.field("id", &self.id());
      ds.field("entity", &self.entity());
      ds.field("relays", &self.relays());
      ds.field("author", &self.author());
      ds.field("kind", &self.kind());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NostrDataT {
  pub id: String,
  pub entity: String,
  pub relays: Option<Vec<String>>,
  pub author: Option<String>,
  pub kind: u64,
}
impl Default for NostrDataT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      entity: "".to_string(),
      relays: None,
      author: None,
      kind: 0,
    }
  }
}
impl NostrDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<NostrData<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let entity = Some({
      let x = &self.entity;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let author = self.author.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let kind = self.kind;
    NostrData::create(_fbb, &NostrDataArgs{
      id,
      entity,
      relays,
      author,
      kind,
    })
  }
}
pub enum LinkPreviewDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LinkPreviewData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinkPreviewData<'a> {
  type Inner = LinkPreviewData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinkPreviewData<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_TITLE: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinkPreviewData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LinkPreviewDataArgs<'args>
  ) -> flatbuffers::WIPOffset<LinkPreviewData<'bldr>> {
    let mut builder = LinkPreviewDataBuilder::new(_fbb);
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> LinkPreviewDataT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let title = self.title().map(|x| {
      x.to_string()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    LinkPreviewDataT {
      url,
      title,
      description,
      image,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_TITLE, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinkPreviewData::VT_IMAGE, None)}
  }
}

impl flatbuffers::Verifiable for LinkPreviewData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct LinkPreviewDataArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LinkPreviewDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinkPreviewDataArgs {
      url: None, // required field
      title: None,
      description: None,
      image: None,
    }
  }
}

pub struct LinkPreviewDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LinkPreviewDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_URL, url);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_TITLE, title);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinkPreviewData::VT_IMAGE, image);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LinkPreviewDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LinkPreviewDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinkPreviewData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LinkPreviewData::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinkPreviewData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinkPreviewData");
      ds.field("url", &self.url());
      ds.field("title", &self.title());
      ds.field("description", &self.description());
      ds.field("image", &self.image());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LinkPreviewDataT {
  pub url: String,
  pub title: Option<String>,
  pub description: Option<String>,
  pub image: Option<String>,
}
impl Default for LinkPreviewDataT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      title: None,
      description: None,
      image: None,
    }
  }
}
impl LinkPreviewDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LinkPreviewData<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let title = self.title.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    LinkPreviewData::create(_fbb, &LinkPreviewDataArgs{
      url,
      title,
      description,
      image,
    })
  }
}
pub enum ContentBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentBlock<'a> {
  type Inner = ContentBlock<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentBlock<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentBlock { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentBlockArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentBlock<'bldr>> {
    let mut builder = ContentBlockBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.add_data_type(args.data_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ContentBlockT {
    let type_ = {
      let x = self.type_();
      x.to_string()
    };
    let text = {
      let x = self.text();
      x.to_string()
    };
    let data = match self.data_type() {
      ContentData::NONE => ContentDataT::NONE,
      ContentData::CodeData => ContentDataT::CodeData(Box::new(
        self.data_as_code_data()
            .expect("Invalid union table, expected `ContentData::CodeData`.")
            .unpack()
      )),
      ContentData::HashtagData => ContentDataT::HashtagData(Box::new(
        self.data_as_hashtag_data()
            .expect("Invalid union table, expected `ContentData::HashtagData`.")
            .unpack()
      )),
      ContentData::CashuData => ContentDataT::CashuData(Box::new(
        self.data_as_cashu_data()
            .expect("Invalid union table, expected `ContentData::CashuData`.")
            .unpack()
      )),
      ContentData::ImageData => ContentDataT::ImageData(Box::new(
        self.data_as_image_data()
            .expect("Invalid union table, expected `ContentData::ImageData`.")
            .unpack()
      )),
      ContentData::VideoData => ContentDataT::VideoData(Box::new(
        self.data_as_video_data()
            .expect("Invalid union table, expected `ContentData::VideoData`.")
            .unpack()
      )),
      ContentData::MediaGroupData => ContentDataT::MediaGroupData(Box::new(
        self.data_as_media_group_data()
            .expect("Invalid union table, expected `ContentData::MediaGroupData`.")
            .unpack()
      )),
      ContentData::NostrData => ContentDataT::NostrData(Box::new(
        self.data_as_nostr_data()
            .expect("Invalid union table, expected `ContentData::NostrData`.")
            .unpack()
      )),
      ContentData::LinkPreviewData => ContentDataT::LinkPreviewData(Box::new(
        self.data_as_link_preview_data()
            .expect("Invalid union table, expected `ContentData::LinkPreviewData`.")
            .unpack()
      )),
      _ => ContentDataT::NONE,
    };
    ContentBlockT {
      type_,
      text,
      data,
    }
  }

  #[inline]
  pub fn type_(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentBlock::VT_TYPE_, None).unwrap()}
  }
  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentBlock::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn data_type(&self) -> ContentData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ContentData>(ContentBlock::VT_DATA_TYPE, Some(ContentData::NONE)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ContentBlock::VT_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_code_data(&self) -> Option<CodeData<'a>> {
    if self.data_type() == ContentData::CodeData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CodeData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_hashtag_data(&self) -> Option<HashtagData<'a>> {
    if self.data_type() == ContentData::HashtagData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HashtagData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_cashu_data(&self) -> Option<CashuData<'a>> {
    if self.data_type() == ContentData::CashuData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CashuData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_image_data(&self) -> Option<ImageData<'a>> {
    if self.data_type() == ContentData::ImageData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ImageData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_video_data(&self) -> Option<VideoData<'a>> {
    if self.data_type() == ContentData::VideoData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { VideoData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_media_group_data(&self) -> Option<MediaGroupData<'a>> {
    if self.data_type() == ContentData::MediaGroupData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MediaGroupData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_nostr_data(&self) -> Option<NostrData<'a>> {
    if self.data_type() == ContentData::NostrData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NostrData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_link_preview_data(&self) -> Option<LinkPreviewData<'a>> {
    if self.data_type() == ContentData::LinkPreviewData {
      self.data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LinkPreviewData::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ContentBlock<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_union::<ContentData, _>("data_type", Self::VT_DATA_TYPE, "data", Self::VT_DATA, false, |key, v, pos| {
        match key {
          ContentData::CodeData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CodeData>>("ContentData::CodeData", pos),
          ContentData::HashtagData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtagData>>("ContentData::HashtagData", pos),
          ContentData::CashuData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CashuData>>("ContentData::CashuData", pos),
          ContentData::ImageData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ImageData>>("ContentData::ImageData", pos),
          ContentData::VideoData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VideoData>>("ContentData::VideoData", pos),
          ContentData::MediaGroupData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MediaGroupData>>("ContentData::MediaGroupData", pos),
          ContentData::NostrData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NostrData>>("ContentData::NostrData", pos),
          ContentData::LinkPreviewData => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LinkPreviewData>>("ContentData::LinkPreviewData", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ContentBlockArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_type: ContentData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ContentBlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentBlockArgs {
      type_: None, // required field
      text: None, // required field
      data_type: ContentData::NONE,
      data: None,
    }
  }
}

pub struct ContentBlockBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentBlockBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentBlock::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentBlock::VT_TEXT, text);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: ContentData) {
    self.fbb_.push_slot::<ContentData>(ContentBlock::VT_DATA_TYPE, data_type, ContentData::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentBlock::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentBlockBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContentBlock::VT_TYPE_,"type_");
    self.fbb_.required(o, ContentBlock::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentBlock<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentBlock");
      ds.field("type_", &self.type_());
      ds.field("text", &self.text());
      ds.field("data_type", &self.data_type());
      match self.data_type() {
        ContentData::CodeData => {
          if let Some(x) = self.data_as_code_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::HashtagData => {
          if let Some(x) = self.data_as_hashtag_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::CashuData => {
          if let Some(x) = self.data_as_cashu_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::ImageData => {
          if let Some(x) = self.data_as_image_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::VideoData => {
          if let Some(x) = self.data_as_video_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::MediaGroupData => {
          if let Some(x) = self.data_as_media_group_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::NostrData => {
          if let Some(x) = self.data_as_nostr_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ContentData::LinkPreviewData => {
          if let Some(x) = self.data_as_link_preview_data() {
            ds.field("data", &x)
          } else {
            ds.field("data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("data", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContentBlockT {
  pub type_: String,
  pub text: String,
  pub data: ContentDataT,
}
impl Default for ContentBlockT {
  fn default() -> Self {
    Self {
      type_: "".to_string(),
      text: "".to_string(),
      data: ContentDataT::NONE,
    }
  }
}
impl ContentBlockT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContentBlock<'b>> {
    let type_ = Some({
      let x = &self.type_;
      _fbb.create_string(x)
    });
    let text = Some({
      let x = &self.text;
      _fbb.create_string(x)
    });
    let data_type = self.data.content_data_type();
    let data = self.data.pack(_fbb);
    ContentBlock::create(_fbb, &ContentBlockArgs{
      type_,
      text,
      data_type,
      data,
    })
  }
}
pub enum StringVecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringVec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringVec<'a> {
  type Inner = StringVec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringVec<'a> {
  pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringVec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringVecArgs<'args>
  ) -> flatbuffers::WIPOffset<StringVec<'bldr>> {
    let mut builder = StringVecBuilder::new(_fbb);
    if let Some(x) = args.items { builder.add_items(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> StringVecT {
    let items = self.items().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    StringVecT {
      items,
    }
  }

  #[inline]
  pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StringVec::VT_ITEMS, None)}
  }
}

impl flatbuffers::Verifiable for StringVec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("items", Self::VT_ITEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct StringVecArgs<'a> {
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for StringVecArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringVecArgs {
      items: None,
    }
  }
}

pub struct StringVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringVecBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_items(&mut self, items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringVec::VT_ITEMS, items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringVecBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringVecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringVec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringVec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringVec");
      ds.field("items", &self.items());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StringVecT {
  pub items: Option<Vec<String>>,
}
impl Default for StringVecT {
  fn default() -> Self {
    Self {
      items: None,
    }
  }
}
impl StringVecT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StringVec<'b>> {
    let items = self.items.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    StringVec::create(_fbb, &StringVecArgs{
      items,
    })
  }
}
pub enum ProfilePointerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProfilePointer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProfilePointer<'a> {
  type Inner = ProfilePointer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProfilePointer<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProfilePointer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProfilePointerArgs<'args>
  ) -> flatbuffers::WIPOffset<ProfilePointer<'bldr>> {
    let mut builder = ProfilePointerBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ProfilePointerT {
    let public_key = {
      let x = self.public_key();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    ProfilePointerT {
      public_key,
      relays,
    }
  }

  #[inline]
  pub fn public_key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProfilePointer::VT_PUBLIC_KEY, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ProfilePointer::VT_RELAYS, None)}
  }
}

impl flatbuffers::Verifiable for ProfilePointer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("public_key", Self::VT_PUBLIC_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct ProfilePointerArgs<'a> {
    pub public_key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ProfilePointerArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProfilePointerArgs {
      public_key: None, // required field
      relays: None,
    }
  }
}

pub struct ProfilePointerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProfilePointerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilePointer::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProfilePointer::VT_RELAYS, relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProfilePointerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProfilePointerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProfilePointer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ProfilePointer::VT_PUBLIC_KEY,"public_key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProfilePointer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProfilePointer");
      ds.field("public_key", &self.public_key());
      ds.field("relays", &self.relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ProfilePointerT {
  pub public_key: String,
  pub relays: Option<Vec<String>>,
}
impl Default for ProfilePointerT {
  fn default() -> Self {
    Self {
      public_key: "".to_string(),
      relays: None,
    }
  }
}
impl ProfilePointerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ProfilePointer<'b>> {
    let public_key = Some({
      let x = &self.public_key;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    ProfilePointer::create(_fbb, &ProfilePointerArgs{
      public_key,
      relays,
    })
  }
}
pub enum EventPointerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EventPointer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventPointer<'a> {
  type Inner = EventPointer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EventPointer<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 6;
  pub const VT_AUTHOR: flatbuffers::VOffsetT = 8;
  pub const VT_KIND: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EventPointer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EventPointerArgs<'args>
  ) -> flatbuffers::WIPOffset<EventPointer<'bldr>> {
    let mut builder = EventPointerBuilder::new(_fbb);
    builder.add_kind(args.kind);
    if let Some(x) = args.author { builder.add_author(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EventPointerT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let author = self.author().map(|x| {
      x.to_string()
    });
    let kind = self.kind();
    EventPointerT {
      id,
      relays,
      author,
      kind,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventPointer::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EventPointer::VT_RELAYS, None)}
  }
  #[inline]
  pub fn author(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventPointer::VT_AUTHOR, None)}
  }
  #[inline]
  pub fn kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(EventPointer::VT_KIND, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EventPointer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("author", Self::VT_AUTHOR, false)?
     .visit_field::<u64>("kind", Self::VT_KIND, false)?
     .finish();
    Ok(())
  }
}
pub struct EventPointerArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub author: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u64,
}
impl<'a> Default for EventPointerArgs<'a> {
  #[inline]
  fn default() -> Self {
    EventPointerArgs {
      id: None, // required field
      relays: None,
      author: None,
      kind: 0,
    }
  }
}

pub struct EventPointerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventPointerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventPointer::VT_ID, id);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventPointer::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_author(&mut self, author: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventPointer::VT_AUTHOR, author);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u64) {
    self.fbb_.push_slot::<u64>(EventPointer::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EventPointerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EventPointerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventPointer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EventPointer::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EventPointer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EventPointer");
      ds.field("id", &self.id());
      ds.field("relays", &self.relays());
      ds.field("author", &self.author());
      ds.field("kind", &self.kind());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EventPointerT {
  pub id: String,
  pub relays: Option<Vec<String>>,
  pub author: Option<String>,
  pub kind: u64,
}
impl Default for EventPointerT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      relays: None,
      author: None,
      kind: 0,
    }
  }
}
impl EventPointerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EventPointer<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let author = self.author.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let kind = self.kind;
    EventPointer::create(_fbb, &EventPointerArgs{
      id,
      relays,
      author,
      kind,
    })
  }
}
pub enum RelayInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelayInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayInfo<'a> {
  type Inner = RelayInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelayInfo<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_READ: flatbuffers::VOffsetT = 6;
  pub const VT_WRITE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelayInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RelayInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<RelayInfo<'bldr>> {
    let mut builder = RelayInfoBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    builder.add_write(args.write);
    builder.add_read(args.read);
    builder.finish()
  }

  pub fn unpack(&self) -> RelayInfoT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let read = self.read();
    let write = self.write();
    RelayInfoT {
      url,
      read,
      write,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RelayInfo::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn read(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RelayInfo::VT_READ, Some(false)).unwrap()}
  }
  #[inline]
  pub fn write(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RelayInfo::VT_WRITE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RelayInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<bool>("read", Self::VT_READ, false)?
     .visit_field::<bool>("write", Self::VT_WRITE, false)?
     .finish();
    Ok(())
  }
}
pub struct RelayInfoArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub read: bool,
    pub write: bool,
}
impl<'a> Default for RelayInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelayInfoArgs {
      url: None, // required field
      read: false,
      write: false,
    }
  }
}

pub struct RelayInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RelayInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayInfo::VT_URL, url);
  }
  #[inline]
  pub fn add_read(&mut self, read: bool) {
    self.fbb_.push_slot::<bool>(RelayInfo::VT_READ, read, false);
  }
  #[inline]
  pub fn add_write(&mut self, write: bool) {
    self.fbb_.push_slot::<bool>(RelayInfo::VT_WRITE, write, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RelayInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RelayInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RelayInfo::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelayInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelayInfo");
      ds.field("url", &self.url());
      ds.field("read", &self.read());
      ds.field("write", &self.write());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RelayInfoT {
  pub url: String,
  pub read: bool,
  pub write: bool,
}
impl Default for RelayInfoT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      read: false,
      write: false,
    }
  }
}
impl RelayInfoT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RelayInfo<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let read = self.read;
    let write = self.write;
    RelayInfo::create(_fbb, &RelayInfoArgs{
      url,
      read,
      write,
    })
  }
}
pub enum MintInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MintInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MintInfo<'a> {
  type Inner = MintInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MintInfo<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_BASE_UNITS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MintInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MintInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<MintInfo<'bldr>> {
    let mut builder = MintInfoBuilder::new(_fbb);
    if let Some(x) = args.base_units { builder.add_base_units(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MintInfoT {
    let url = {
      let x = self.url();
      x.to_string()
    };
    let base_units = {
      let x = self.base_units();
      x.iter().map(|s| s.to_string()).collect()
    };
    MintInfoT {
      url,
      base_units,
    }
  }

  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MintInfo::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn base_units(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MintInfo::VT_BASE_UNITS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for MintInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("base_units", Self::VT_BASE_UNITS, true)?
     .finish();
    Ok(())
  }
}
pub struct MintInfoArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub base_units: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MintInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    MintInfoArgs {
      url: None, // required field
      base_units: None, // required field
    }
  }
}

pub struct MintInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MintInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintInfo::VT_URL, url);
  }
  #[inline]
  pub fn add_base_units(&mut self, base_units: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintInfo::VT_BASE_UNITS, base_units);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MintInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MintInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MintInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, MintInfo::VT_URL,"url");
    self.fbb_.required(o, MintInfo::VT_BASE_UNITS,"base_units");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MintInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MintInfo");
      ds.field("url", &self.url());
      ds.field("base_units", &self.base_units());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MintInfoT {
  pub url: String,
  pub base_units: Vec<String>,
}
impl Default for MintInfoT {
  fn default() -> Self {
    Self {
      url: "".to_string(),
      base_units: Default::default(),
    }
  }
}
impl MintInfoT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MintInfo<'b>> {
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    let base_units = Some({
      let x = &self.base_units;
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    MintInfo::create(_fbb, &MintInfoArgs{
      url,
      base_units,
    })
  }
}
pub enum EmojiOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Emoji<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Emoji<'a> {
  type Inner = Emoji<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Emoji<'a> {
  pub const VT_SHORTCODE: flatbuffers::VOffsetT = 4;
  pub const VT_URL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Emoji { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EmojiArgs<'args>
  ) -> flatbuffers::WIPOffset<Emoji<'bldr>> {
    let mut builder = EmojiBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.shortcode { builder.add_shortcode(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EmojiT {
    let shortcode = {
      let x = self.shortcode();
      x.to_string()
    };
    let url = {
      let x = self.url();
      x.to_string()
    };
    EmojiT {
      shortcode,
      url,
    }
  }

  #[inline]
  pub fn shortcode(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Emoji::VT_SHORTCODE, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Emoji::VT_URL, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Emoji<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shortcode", Self::VT_SHORTCODE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .finish();
    Ok(())
  }
}
pub struct EmojiArgs<'a> {
    pub shortcode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EmojiArgs<'a> {
  #[inline]
  fn default() -> Self {
    EmojiArgs {
      shortcode: None, // required field
      url: None, // required field
    }
  }
}

pub struct EmojiBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EmojiBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shortcode(&mut self, shortcode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Emoji::VT_SHORTCODE, shortcode);
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Emoji::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EmojiBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EmojiBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Emoji<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Emoji::VT_SHORTCODE,"shortcode");
    self.fbb_.required(o, Emoji::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Emoji<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Emoji");
      ds.field("shortcode", &self.shortcode());
      ds.field("url", &self.url());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EmojiT {
  pub shortcode: String,
  pub url: String,
}
impl Default for EmojiT {
  fn default() -> Self {
    Self {
      shortcode: "".to_string(),
      url: "".to_string(),
    }
  }
}
impl EmojiT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Emoji<'b>> {
    let shortcode = Some({
      let x = &self.shortcode;
      _fbb.create_string(x)
    });
    let url = Some({
      let x = &self.url;
      _fbb.create_string(x)
    });
    Emoji::create(_fbb, &EmojiArgs{
      shortcode,
      url,
    })
  }
}
pub enum ContactOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Contact<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Contact<'a> {
  type Inner = Contact<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Contact<'a> {
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 6;
  pub const VT_PETNAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Contact { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContactArgs<'args>
  ) -> flatbuffers::WIPOffset<Contact<'bldr>> {
    let mut builder = ContactBuilder::new(_fbb);
    if let Some(x) = args.petname { builder.add_petname(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContactT {
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let petname = self.petname().map(|x| {
      x.to_string()
    });
    ContactT {
      pubkey,
      relays,
      petname,
    }
  }

  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Contact::VT_RELAYS, None)}
  }
  #[inline]
  pub fn petname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_PETNAME, None)}
  }
}

impl flatbuffers::Verifiable for Contact<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("petname", Self::VT_PETNAME, false)?
     .finish();
    Ok(())
  }
}
pub struct ContactArgs<'a> {
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub petname: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ContactArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContactArgs {
      pubkey: None, // required field
      relays: None,
      petname: None,
    }
  }
}

pub struct ContactBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContactBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_petname(&mut self, petname: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_PETNAME, petname);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContactBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContactBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Contact<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Contact::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Contact<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Contact");
      ds.field("pubkey", &self.pubkey());
      ds.field("relays", &self.relays());
      ds.field("petname", &self.petname());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContactT {
  pub pubkey: String,
  pub relays: Option<Vec<String>>,
  pub petname: Option<String>,
}
impl Default for ContactT {
  fn default() -> Self {
    Self {
      pubkey: "".to_string(),
      relays: None,
      petname: None,
    }
  }
}
impl ContactT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Contact<'b>> {
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let petname = self.petname.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Contact::create(_fbb, &ContactArgs{
      pubkey,
      relays,
      petname,
    })
  }
}
pub enum DLEQProofOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DLEQProof<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DLEQProof<'a> {
  type Inner = DLEQProof<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DLEQProof<'a> {
  pub const VT_E: flatbuffers::VOffsetT = 4;
  pub const VT_S: flatbuffers::VOffsetT = 6;
  pub const VT_R: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DLEQProof { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DLEQProofArgs<'args>
  ) -> flatbuffers::WIPOffset<DLEQProof<'bldr>> {
    let mut builder = DLEQProofBuilder::new(_fbb);
    if let Some(x) = args.r { builder.add_r(x); }
    if let Some(x) = args.s { builder.add_s(x); }
    if let Some(x) = args.e { builder.add_e(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> DLEQProofT {
    let e = {
      let x = self.e();
      x.to_string()
    };
    let s = {
      let x = self.s();
      x.to_string()
    };
    let r = {
      let x = self.r();
      x.to_string()
    };
    DLEQProofT {
      e,
      s,
      r,
    }
  }

  #[inline]
  pub fn e(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DLEQProof::VT_E, None).unwrap()}
  }
  #[inline]
  pub fn s(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DLEQProof::VT_S, None).unwrap()}
  }
  #[inline]
  pub fn r(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DLEQProof::VT_R, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for DLEQProof<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("e", Self::VT_E, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("s", Self::VT_S, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("r", Self::VT_R, true)?
     .finish();
    Ok(())
  }
}
pub struct DLEQProofArgs<'a> {
    pub e: Option<flatbuffers::WIPOffset<&'a str>>,
    pub s: Option<flatbuffers::WIPOffset<&'a str>>,
    pub r: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DLEQProofArgs<'a> {
  #[inline]
  fn default() -> Self {
    DLEQProofArgs {
      e: None, // required field
      s: None, // required field
      r: None, // required field
    }
  }
}

pub struct DLEQProofBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DLEQProofBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_e(&mut self, e: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DLEQProof::VT_E, e);
  }
  #[inline]
  pub fn add_s(&mut self, s: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DLEQProof::VT_S, s);
  }
  #[inline]
  pub fn add_r(&mut self, r: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DLEQProof::VT_R, r);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DLEQProofBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DLEQProofBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DLEQProof<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DLEQProof::VT_E,"e");
    self.fbb_.required(o, DLEQProof::VT_S,"s");
    self.fbb_.required(o, DLEQProof::VT_R,"r");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DLEQProof<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DLEQProof");
      ds.field("e", &self.e());
      ds.field("s", &self.s());
      ds.field("r", &self.r());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DLEQProofT {
  pub e: String,
  pub s: String,
  pub r: String,
}
impl Default for DLEQProofT {
  fn default() -> Self {
    Self {
      e: "".to_string(),
      s: "".to_string(),
      r: "".to_string(),
    }
  }
}
impl DLEQProofT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DLEQProof<'b>> {
    let e = Some({
      let x = &self.e;
      _fbb.create_string(x)
    });
    let s = Some({
      let x = &self.s;
      _fbb.create_string(x)
    });
    let r = Some({
      let x = &self.r;
      _fbb.create_string(x)
    });
    DLEQProof::create(_fbb, &DLEQProofArgs{
      e,
      s,
      r,
    })
  }
}
pub enum ProofOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Proof<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Proof<'a> {
  type Inner = Proof<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Proof<'a> {
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SECRET: flatbuffers::VOffsetT = 8;
  pub const VT_C: flatbuffers::VOffsetT = 10;
  pub const VT_DLEQ: flatbuffers::VOffsetT = 12;
  pub const VT_VERSION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Proof { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProofArgs<'args>
  ) -> flatbuffers::WIPOffset<Proof<'bldr>> {
    let mut builder = ProofBuilder::new(_fbb);
    builder.add_amount(args.amount);
    if let Some(x) = args.dleq { builder.add_dleq(x); }
    if let Some(x) = args.c { builder.add_c(x); }
    if let Some(x) = args.secret { builder.add_secret(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_version(args.version);
    builder.finish()
  }

  pub fn unpack(&self) -> ProofT {
    let amount = self.amount();
    let id = {
      let x = self.id();
      x.to_string()
    };
    let secret = {
      let x = self.secret();
      x.to_string()
    };
    let c = {
      let x = self.c();
      x.to_string()
    };
    let dleq = self.dleq().map(|x| {
      Box::new(x.unpack())
    });
    let version = self.version();
    ProofT {
      amount,
      id,
      secret,
      c,
      dleq,
      version,
    }
  }

  #[inline]
  pub fn amount(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Proof::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Proof::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn secret(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Proof::VT_SECRET, None).unwrap()}
  }
  #[inline]
  pub fn c(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Proof::VT_C, None).unwrap()}
  }
  #[inline]
  pub fn dleq(&self) -> Option<DLEQProof<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DLEQProof>>(Proof::VT_DLEQ, None)}
  }
  #[inline]
  pub fn version(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Proof::VT_VERSION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Proof<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("secret", Self::VT_SECRET, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c", Self::VT_C, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DLEQProof>>("dleq", Self::VT_DLEQ, false)?
     .visit_field::<u8>("version", Self::VT_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct ProofArgs<'a> {
    pub amount: u64,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub secret: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dleq: Option<flatbuffers::WIPOffset<DLEQProof<'a>>>,
    pub version: u8,
}
impl<'a> Default for ProofArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProofArgs {
      amount: 0,
      id: None, // required field
      secret: None, // required field
      c: None, // required field
      dleq: None,
      version: 0,
    }
  }
}

pub struct ProofBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProofBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_amount(&mut self, amount: u64) {
    self.fbb_.push_slot::<u64>(Proof::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_ID, id);
  }
  #[inline]
  pub fn add_secret(&mut self, secret: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_SECRET, secret);
  }
  #[inline]
  pub fn add_c(&mut self, c: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_C, c);
  }
  #[inline]
  pub fn add_dleq(&mut self, dleq: flatbuffers::WIPOffset<DLEQProof<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DLEQProof>>(Proof::VT_DLEQ, dleq);
  }
  #[inline]
  pub fn add_version(&mut self, version: u8) {
    self.fbb_.push_slot::<u8>(Proof::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProofBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProofBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Proof<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Proof::VT_ID,"id");
    self.fbb_.required(o, Proof::VT_SECRET,"secret");
    self.fbb_.required(o, Proof::VT_C,"c");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Proof<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Proof");
      ds.field("amount", &self.amount());
      ds.field("id", &self.id());
      ds.field("secret", &self.secret());
      ds.field("c", &self.c());
      ds.field("dleq", &self.dleq());
      ds.field("version", &self.version());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ProofT {
  pub amount: u64,
  pub id: String,
  pub secret: String,
  pub c: String,
  pub dleq: Option<Box<DLEQProofT>>,
  pub version: u8,
}
impl Default for ProofT {
  fn default() -> Self {
    Self {
      amount: 0,
      id: "".to_string(),
      secret: "".to_string(),
      c: "".to_string(),
      dleq: None,
      version: 0,
    }
  }
}
impl ProofT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Proof<'b>> {
    let amount = self.amount;
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let secret = Some({
      let x = &self.secret;
      _fbb.create_string(x)
    });
    let c = Some({
      let x = &self.c;
      _fbb.create_string(x)
    });
    let dleq = self.dleq.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let version = self.version;
    Proof::create(_fbb, &ProofArgs{
      amount,
      id,
      secret,
      c,
      dleq,
      version,
    })
  }
}
pub enum HistoryTagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HistoryTag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HistoryTag<'a> {
  type Inner = HistoryTag<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HistoryTag<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_RELAY: flatbuffers::VOffsetT = 8;
  pub const VT_MARKER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HistoryTag { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HistoryTagArgs<'args>
  ) -> flatbuffers::WIPOffset<HistoryTag<'bldr>> {
    let mut builder = HistoryTagBuilder::new(_fbb);
    if let Some(x) = args.marker { builder.add_marker(x); }
    if let Some(x) = args.relay { builder.add_relay(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> HistoryTagT {
    let name = {
      let x = self.name();
      x.to_string()
    };
    let value = {
      let x = self.value();
      x.to_string()
    };
    let relay = self.relay().map(|x| {
      x.to_string()
    });
    let marker = self.marker().map(|x| {
      x.to_string()
    });
    HistoryTagT {
      name,
      value,
      relay,
      marker,
    }
  }

  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_VALUE, None).unwrap()}
  }
  #[inline]
  pub fn relay(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_RELAY, None)}
  }
  #[inline]
  pub fn marker(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HistoryTag::VT_MARKER, None)}
  }
}

impl flatbuffers::Verifiable for HistoryTag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relay", Self::VT_RELAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("marker", Self::VT_MARKER, false)?
     .finish();
    Ok(())
  }
}
pub struct HistoryTagArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relay: Option<flatbuffers::WIPOffset<&'a str>>,
    pub marker: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HistoryTagArgs<'a> {
  #[inline]
  fn default() -> Self {
    HistoryTagArgs {
      name: None, // required field
      value: None, // required field
      relay: None,
      marker: None,
    }
  }
}

pub struct HistoryTagBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HistoryTagBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_VALUE, value);
  }
  #[inline]
  pub fn add_relay(&mut self, relay: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_RELAY, relay);
  }
  #[inline]
  pub fn add_marker(&mut self, marker: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HistoryTag::VT_MARKER, marker);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HistoryTagBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HistoryTagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HistoryTag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, HistoryTag::VT_NAME,"name");
    self.fbb_.required(o, HistoryTag::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HistoryTag<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HistoryTag");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.field("relay", &self.relay());
      ds.field("marker", &self.marker());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HistoryTagT {
  pub name: String,
  pub value: String,
  pub relay: Option<String>,
  pub marker: Option<String>,
}
impl Default for HistoryTagT {
  fn default() -> Self {
    Self {
      name: "".to_string(),
      value: "".to_string(),
      relay: None,
      marker: None,
    }
  }
}
impl HistoryTagT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<HistoryTag<'b>> {
    let name = Some({
      let x = &self.name;
      _fbb.create_string(x)
    });
    let value = Some({
      let x = &self.value;
      _fbb.create_string(x)
    });
    let relay = self.relay.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let marker = self.marker.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    HistoryTag::create(_fbb, &HistoryTagArgs{
      name,
      value,
      relay,
      marker,
    })
  }
}
pub enum ZapRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZapRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZapRequest<'a> {
  type Inner = ZapRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ZapRequest<'a> {
  pub const VT_KIND: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;
  pub const VT_TAGS: flatbuffers::VOffsetT = 10;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZapRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ZapRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<ZapRequest<'bldr>> {
    let mut builder = ZapRequestBuilder::new(_fbb);
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.add_kind(args.kind);
    builder.finish()
  }

  pub fn unpack(&self) -> ZapRequestT {
    let kind = self.kind();
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let content = {
      let x = self.content();
      x.to_string()
    };
    let tags = {
      let x = self.tags();
      x.iter().map(|t| t.unpack()).collect()
    };
    let signature = self.signature().map(|x| {
      x.to_string()
    });
    ZapRequestT {
      kind,
      pubkey,
      content,
      tags,
      signature,
    }
  }

  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ZapRequest::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZapRequest::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZapRequest::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn tags(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(ZapRequest::VT_TAGS, None).unwrap()}
  }
  #[inline]
  pub fn signature(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ZapRequest::VT_SIGNATURE, None)}
  }
}

impl flatbuffers::Verifiable for ZapRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("signature", Self::VT_SIGNATURE, false)?
     .finish();
    Ok(())
  }
}
pub struct ZapRequestArgs<'a> {
    pub kind: u16,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
    pub signature: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ZapRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    ZapRequestArgs {
      kind: 0,
      pubkey: None, // required field
      content: None, // required field
      tags: None, // required field
      signature: None,
    }
  }
}

pub struct ZapRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZapRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(ZapRequest::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ZapRequest::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ZapRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ZapRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZapRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ZapRequest::VT_PUBKEY,"pubkey");
    self.fbb_.required(o, ZapRequest::VT_CONTENT,"content");
    self.fbb_.required(o, ZapRequest::VT_TAGS,"tags");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZapRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZapRequest");
      ds.field("kind", &self.kind());
      ds.field("pubkey", &self.pubkey());
      ds.field("content", &self.content());
      ds.field("tags", &self.tags());
      ds.field("signature", &self.signature());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ZapRequestT {
  pub kind: u16,
  pub pubkey: String,
  pub content: String,
  pub tags: Vec<StringVecT>,
  pub signature: Option<String>,
}
impl Default for ZapRequestT {
  fn default() -> Self {
    Self {
      kind: 0,
      pubkey: "".to_string(),
      content: "".to_string(),
      tags: Default::default(),
      signature: None,
    }
  }
}
impl ZapRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ZapRequest<'b>> {
    let kind = self.kind;
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let content = Some({
      let x = &self.content;
      _fbb.create_string(x)
    });
    let tags = Some({
      let x = &self.tags;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let signature = self.signature.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ZapRequest::create(_fbb, &ZapRequestArgs{
      kind,
      pubkey,
      content,
      tags,
      signature,
    })
  }
}
pub enum RequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Request<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Request<'a> {
  type Inner = Request<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Request<'a> {
  pub const VT_IDS: flatbuffers::VOffsetT = 4;
  pub const VT_AUTHORS: flatbuffers::VOffsetT = 6;
  pub const VT_KINDS: flatbuffers::VOffsetT = 8;
  pub const VT_TAGS: flatbuffers::VOffsetT = 10;
  pub const VT_LIMIT: flatbuffers::VOffsetT = 12;
  pub const VT_SINCE: flatbuffers::VOffsetT = 14;
  pub const VT_UNTIL: flatbuffers::VOffsetT = 16;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 18;
  pub const VT_CLOSE_ON_EOSE: flatbuffers::VOffsetT = 20;
  pub const VT_CACHE_FIRST: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Request { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestArgs<'args>
  ) -> flatbuffers::WIPOffset<Request<'bldr>> {
    let mut builder = RequestBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    builder.add_until(args.until);
    builder.add_since(args.since);
    builder.add_limit(args.limit);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.kinds { builder.add_kinds(x); }
    if let Some(x) = args.authors { builder.add_authors(x); }
    if let Some(x) = args.ids { builder.add_ids(x); }
    builder.add_cache_first(args.cache_first);
    builder.add_close_on_eose(args.close_on_eose);
    builder.finish()
  }

  pub fn unpack(&self) -> RequestT {
    let ids = self.ids().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let authors = self.authors().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let kinds = self.kinds().map(|x| {
      x.into_iter().collect()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let limit = self.limit();
    let since = self.since();
    let until = self.until();
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let close_on_eose = self.close_on_eose();
    let cache_first = self.cache_first();
    RequestT {
      ids,
      authors,
      kinds,
      tags,
      limit,
      since,
      until,
      relays,
      close_on_eose,
      cache_first,
    }
  }

  #[inline]
  pub fn ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Request::VT_IDS, None)}
  }
  #[inline]
  pub fn authors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Request::VT_AUTHORS, None)}
  }
  #[inline]
  pub fn kinds(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Request::VT_KINDS, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(Request::VT_TAGS, None)}
  }
  #[inline]
  pub fn limit(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Request::VT_LIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn since(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Request::VT_SINCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn until(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Request::VT_UNTIL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Request::VT_RELAYS, None)}
  }
  #[inline]
  pub fn close_on_eose(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Request::VT_CLOSE_ON_EOSE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn cache_first(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Request::VT_CACHE_FIRST, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Request<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ids", Self::VT_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("authors", Self::VT_AUTHORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("kinds", Self::VT_KINDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<i32>("limit", Self::VT_LIMIT, false)?
     .visit_field::<i32>("since", Self::VT_SINCE, false)?
     .visit_field::<i32>("until", Self::VT_UNTIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<bool>("close_on_eose", Self::VT_CLOSE_ON_EOSE, false)?
     .visit_field::<bool>("cache_first", Self::VT_CACHE_FIRST, false)?
     .finish();
    Ok(())
  }
}
pub struct RequestArgs<'a> {
    pub ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub authors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub kinds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
    pub limit: i32,
    pub since: i32,
    pub until: i32,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub close_on_eose: bool,
    pub cache_first: bool,
}
impl<'a> Default for RequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    RequestArgs {
      ids: None,
      authors: None,
      kinds: None,
      tags: None,
      limit: 0,
      since: 0,
      until: 0,
      relays: None,
      close_on_eose: false,
      cache_first: false,
    }
  }
}

pub struct RequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ids(&mut self, ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_IDS, ids);
  }
  #[inline]
  pub fn add_authors(&mut self, authors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_AUTHORS, authors);
  }
  #[inline]
  pub fn add_kinds(&mut self, kinds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_KINDS, kinds);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_limit(&mut self, limit: i32) {
    self.fbb_.push_slot::<i32>(Request::VT_LIMIT, limit, 0);
  }
  #[inline]
  pub fn add_since(&mut self, since: i32) {
    self.fbb_.push_slot::<i32>(Request::VT_SINCE, since, 0);
  }
  #[inline]
  pub fn add_until(&mut self, until: i32) {
    self.fbb_.push_slot::<i32>(Request::VT_UNTIL, until, 0);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_close_on_eose(&mut self, close_on_eose: bool) {
    self.fbb_.push_slot::<bool>(Request::VT_CLOSE_ON_EOSE, close_on_eose, false);
  }
  #[inline]
  pub fn add_cache_first(&mut self, cache_first: bool) {
    self.fbb_.push_slot::<bool>(Request::VT_CACHE_FIRST, cache_first, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Request<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Request<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Request");
      ds.field("ids", &self.ids());
      ds.field("authors", &self.authors());
      ds.field("kinds", &self.kinds());
      ds.field("tags", &self.tags());
      ds.field("limit", &self.limit());
      ds.field("since", &self.since());
      ds.field("until", &self.until());
      ds.field("relays", &self.relays());
      ds.field("close_on_eose", &self.close_on_eose());
      ds.field("cache_first", &self.cache_first());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RequestT {
  pub ids: Option<Vec<String>>,
  pub authors: Option<Vec<String>>,
  pub kinds: Option<Vec<u16>>,
  pub tags: Option<Vec<StringVecT>>,
  pub limit: i32,
  pub since: i32,
  pub until: i32,
  pub relays: Option<Vec<String>>,
  pub close_on_eose: bool,
  pub cache_first: bool,
}
impl Default for RequestT {
  fn default() -> Self {
    Self {
      ids: None,
      authors: None,
      kinds: None,
      tags: None,
      limit: 0,
      since: 0,
      until: 0,
      relays: None,
      close_on_eose: false,
      cache_first: false,
    }
  }
}
impl RequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Request<'b>> {
    let ids = self.ids.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let authors = self.authors.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let kinds = self.kinds.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let limit = self.limit;
    let since = self.since;
    let until = self.until;
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let close_on_eose = self.close_on_eose;
    let cache_first = self.cache_first;
    Request::create(_fbb, &RequestArgs{
      ids,
      authors,
      kinds,
      tags,
      limit,
      since,
      until,
      relays,
      close_on_eose,
      cache_first,
    })
  }
}
pub enum NostrEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NostrEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NostrEvent<'a> {
  type Inner = NostrEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NostrEvent<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_KIND: flatbuffers::VOffsetT = 8;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 10;
  pub const VT_TAGS: flatbuffers::VOffsetT = 12;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 14;
  pub const VT_SIG: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NostrEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NostrEventArgs<'args>
  ) -> flatbuffers::WIPOffset<NostrEvent<'bldr>> {
    let mut builder = NostrEventBuilder::new(_fbb);
    if let Some(x) = args.sig { builder.add_sig(x); }
    builder.add_created_at(args.created_at);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_kind(args.kind);
    builder.finish()
  }

  pub fn unpack(&self) -> NostrEventT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let kind = self.kind();
    let content = {
      let x = self.content();
      x.to_string()
    };
    let tags = {
      let x = self.tags();
      x.iter().map(|t| t.unpack()).collect()
    };
    let created_at = self.created_at();
    let sig = {
      let x = self.sig();
      x.to_string()
    };
    NostrEventT {
      id,
      pubkey,
      kind,
      content,
      tags,
      created_at,
      sig,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(NostrEvent::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn tags(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(NostrEvent::VT_TAGS, None).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(NostrEvent::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sig(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NostrEvent::VT_SIG, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for NostrEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, true)?
     .visit_field::<i32>("created_at", Self::VT_CREATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sig", Self::VT_SIG, true)?
     .finish();
    Ok(())
  }
}
pub struct NostrEventArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u16,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
    pub created_at: i32,
    pub sig: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NostrEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    NostrEventArgs {
      id: None, // required field
      pubkey: None, // required field
      kind: 0,
      content: None, // required field
      tags: None, // required field
      created_at: 0,
      sig: None, // required field
    }
  }
}

pub struct NostrEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NostrEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_ID, id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(NostrEvent::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: i32) {
    self.fbb_.push_slot::<i32>(NostrEvent::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_sig(&mut self, sig: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NostrEvent::VT_SIG, sig);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NostrEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NostrEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NostrEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, NostrEvent::VT_ID,"id");
    self.fbb_.required(o, NostrEvent::VT_PUBKEY,"pubkey");
    self.fbb_.required(o, NostrEvent::VT_CONTENT,"content");
    self.fbb_.required(o, NostrEvent::VT_TAGS,"tags");
    self.fbb_.required(o, NostrEvent::VT_SIG,"sig");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NostrEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NostrEvent");
      ds.field("id", &self.id());
      ds.field("pubkey", &self.pubkey());
      ds.field("kind", &self.kind());
      ds.field("content", &self.content());
      ds.field("tags", &self.tags());
      ds.field("created_at", &self.created_at());
      ds.field("sig", &self.sig());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NostrEventT {
  pub id: String,
  pub pubkey: String,
  pub kind: u16,
  pub content: String,
  pub tags: Vec<StringVecT>,
  pub created_at: i32,
  pub sig: String,
}
impl Default for NostrEventT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      pubkey: "".to_string(),
      kind: 0,
      content: "".to_string(),
      tags: Default::default(),
      created_at: 0,
      sig: "".to_string(),
    }
  }
}
impl NostrEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<NostrEvent<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let kind = self.kind;
    let content = Some({
      let x = &self.content;
      _fbb.create_string(x)
    });
    let tags = Some({
      let x = &self.tags;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let created_at = self.created_at;
    let sig = Some({
      let x = &self.sig;
      _fbb.create_string(x)
    });
    NostrEvent::create(_fbb, &NostrEventArgs{
      id,
      pubkey,
      kind,
      content,
      tags,
      created_at,
      sig,
    })
  }
}
pub enum Kind0ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind0Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind0Parsed<'a> {
  type Inner = Kind0Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind0Parsed<'a> {
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_DISPLAY_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_PICTURE: flatbuffers::VOffsetT = 10;
  pub const VT_BANNER: flatbuffers::VOffsetT = 12;
  pub const VT_ABOUT: flatbuffers::VOffsetT = 14;
  pub const VT_WEBSITE: flatbuffers::VOffsetT = 16;
  pub const VT_NIP05: flatbuffers::VOffsetT = 18;
  pub const VT_LUD06: flatbuffers::VOffsetT = 20;
  pub const VT_LUD16: flatbuffers::VOffsetT = 22;
  pub const VT_GITHUB: flatbuffers::VOffsetT = 24;
  pub const VT_TWITTER: flatbuffers::VOffsetT = 26;
  pub const VT_MASTODON: flatbuffers::VOffsetT = 28;
  pub const VT_NOSTR: flatbuffers::VOffsetT = 30;
  pub const VT_DISPLAY_NAME_ALT: flatbuffers::VOffsetT = 32;
  pub const VT_USERNAME: flatbuffers::VOffsetT = 34;
  pub const VT_BIO: flatbuffers::VOffsetT = 36;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 38;
  pub const VT_AVATAR: flatbuffers::VOffsetT = 40;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind0Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind0ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind0Parsed<'bldr>> {
    let mut builder = Kind0ParsedBuilder::new(_fbb);
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.avatar { builder.add_avatar(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.bio { builder.add_bio(x); }
    if let Some(x) = args.username { builder.add_username(x); }
    if let Some(x) = args.display_name_alt { builder.add_display_name_alt(x); }
    if let Some(x) = args.nostr { builder.add_nostr(x); }
    if let Some(x) = args.mastodon { builder.add_mastodon(x); }
    if let Some(x) = args.twitter { builder.add_twitter(x); }
    if let Some(x) = args.github { builder.add_github(x); }
    if let Some(x) = args.lud16 { builder.add_lud16(x); }
    if let Some(x) = args.lud06 { builder.add_lud06(x); }
    if let Some(x) = args.nip05 { builder.add_nip05(x); }
    if let Some(x) = args.website { builder.add_website(x); }
    if let Some(x) = args.about { builder.add_about(x); }
    if let Some(x) = args.banner { builder.add_banner(x); }
    if let Some(x) = args.picture { builder.add_picture(x); }
    if let Some(x) = args.display_name { builder.add_display_name(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind0ParsedT {
    let pubkey = self.pubkey().map(|x| {
      x.to_string()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    let display_name = self.display_name().map(|x| {
      x.to_string()
    });
    let picture = self.picture().map(|x| {
      x.to_string()
    });
    let banner = self.banner().map(|x| {
      x.to_string()
    });
    let about = self.about().map(|x| {
      x.to_string()
    });
    let website = self.website().map(|x| {
      x.to_string()
    });
    let nip05 = self.nip05().map(|x| {
      x.to_string()
    });
    let lud06 = self.lud06().map(|x| {
      x.to_string()
    });
    let lud16 = self.lud16().map(|x| {
      x.to_string()
    });
    let github = self.github().map(|x| {
      x.to_string()
    });
    let twitter = self.twitter().map(|x| {
      x.to_string()
    });
    let mastodon = self.mastodon().map(|x| {
      x.to_string()
    });
    let nostr = self.nostr().map(|x| {
      x.to_string()
    });
    let display_name_alt = self.display_name_alt().map(|x| {
      x.to_string()
    });
    let username = self.username().map(|x| {
      x.to_string()
    });
    let bio = self.bio().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    let avatar = self.avatar().map(|x| {
      x.to_string()
    });
    let background = self.background().map(|x| {
      x.to_string()
    });
    Kind0ParsedT {
      pubkey,
      name,
      display_name,
      picture,
      banner,
      about,
      website,
      nip05,
      lud06,
      lud16,
      github,
      twitter,
      mastodon,
      nostr,
      display_name_alt,
      username,
      bio,
      image,
      avatar,
      background,
    }
  }

  #[inline]
  pub fn pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_PUBKEY, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_NAME, None)}
  }
  #[inline]
  pub fn display_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_DISPLAY_NAME, None)}
  }
  #[inline]
  pub fn picture(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_PICTURE, None)}
  }
  #[inline]
  pub fn banner(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_BANNER, None)}
  }
  #[inline]
  pub fn about(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_ABOUT, None)}
  }
  #[inline]
  pub fn website(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_WEBSITE, None)}
  }
  #[inline]
  pub fn nip05(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_NIP05, None)}
  }
  #[inline]
  pub fn lud06(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_LUD06, None)}
  }
  #[inline]
  pub fn lud16(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_LUD16, None)}
  }
  #[inline]
  pub fn github(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_GITHUB, None)}
  }
  #[inline]
  pub fn twitter(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_TWITTER, None)}
  }
  #[inline]
  pub fn mastodon(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_MASTODON, None)}
  }
  #[inline]
  pub fn nostr(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_NOSTR, None)}
  }
  #[inline]
  pub fn display_name_alt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_DISPLAY_NAME_ALT, None)}
  }
  #[inline]
  pub fn username(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_USERNAME, None)}
  }
  #[inline]
  pub fn bio(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_BIO, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_IMAGE, None)}
  }
  #[inline]
  pub fn avatar(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_AVATAR, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind0Parsed::VT_BACKGROUND, None)}
  }
}

impl flatbuffers::Verifiable for Kind0Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("display_name", Self::VT_DISPLAY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picture", Self::VT_PICTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("banner", Self::VT_BANNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("about", Self::VT_ABOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("website", Self::VT_WEBSITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nip05", Self::VT_NIP05, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lud06", Self::VT_LUD06, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lud16", Self::VT_LUD16, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("github", Self::VT_GITHUB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("twitter", Self::VT_TWITTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mastodon", Self::VT_MASTODON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nostr", Self::VT_NOSTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("display_name_alt", Self::VT_DISPLAY_NAME_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("username", Self::VT_USERNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bio", Self::VT_BIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avatar", Self::VT_AVATAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("background", Self::VT_BACKGROUND, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind0ParsedArgs<'a> {
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub display_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picture: Option<flatbuffers::WIPOffset<&'a str>>,
    pub banner: Option<flatbuffers::WIPOffset<&'a str>>,
    pub about: Option<flatbuffers::WIPOffset<&'a str>>,
    pub website: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nip05: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lud06: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lud16: Option<flatbuffers::WIPOffset<&'a str>>,
    pub github: Option<flatbuffers::WIPOffset<&'a str>>,
    pub twitter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mastodon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nostr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub display_name_alt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub username: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bio: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub avatar: Option<flatbuffers::WIPOffset<&'a str>>,
    pub background: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind0ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind0ParsedArgs {
      pubkey: None,
      name: None,
      display_name: None,
      picture: None,
      banner: None,
      about: None,
      website: None,
      nip05: None,
      lud06: None,
      lud16: None,
      github: None,
      twitter: None,
      mastodon: None,
      nostr: None,
      display_name_alt: None,
      username: None,
      bio: None,
      image: None,
      avatar: None,
      background: None,
    }
  }
}

pub struct Kind0ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind0ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_NAME, name);
  }
  #[inline]
  pub fn add_display_name(&mut self, display_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_DISPLAY_NAME, display_name);
  }
  #[inline]
  pub fn add_picture(&mut self, picture: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_PICTURE, picture);
  }
  #[inline]
  pub fn add_banner(&mut self, banner: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_BANNER, banner);
  }
  #[inline]
  pub fn add_about(&mut self, about: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_ABOUT, about);
  }
  #[inline]
  pub fn add_website(&mut self, website: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_WEBSITE, website);
  }
  #[inline]
  pub fn add_nip05(&mut self, nip05: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_NIP05, nip05);
  }
  #[inline]
  pub fn add_lud06(&mut self, lud06: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_LUD06, lud06);
  }
  #[inline]
  pub fn add_lud16(&mut self, lud16: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_LUD16, lud16);
  }
  #[inline]
  pub fn add_github(&mut self, github: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_GITHUB, github);
  }
  #[inline]
  pub fn add_twitter(&mut self, twitter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_TWITTER, twitter);
  }
  #[inline]
  pub fn add_mastodon(&mut self, mastodon: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_MASTODON, mastodon);
  }
  #[inline]
  pub fn add_nostr(&mut self, nostr: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_NOSTR, nostr);
  }
  #[inline]
  pub fn add_display_name_alt(&mut self, display_name_alt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_DISPLAY_NAME_ALT, display_name_alt);
  }
  #[inline]
  pub fn add_username(&mut self, username: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_USERNAME, username);
  }
  #[inline]
  pub fn add_bio(&mut self, bio: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_BIO, bio);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_avatar(&mut self, avatar: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_AVATAR, avatar);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind0Parsed::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind0ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind0ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind0Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind0Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind0Parsed");
      ds.field("pubkey", &self.pubkey());
      ds.field("name", &self.name());
      ds.field("display_name", &self.display_name());
      ds.field("picture", &self.picture());
      ds.field("banner", &self.banner());
      ds.field("about", &self.about());
      ds.field("website", &self.website());
      ds.field("nip05", &self.nip05());
      ds.field("lud06", &self.lud06());
      ds.field("lud16", &self.lud16());
      ds.field("github", &self.github());
      ds.field("twitter", &self.twitter());
      ds.field("mastodon", &self.mastodon());
      ds.field("nostr", &self.nostr());
      ds.field("display_name_alt", &self.display_name_alt());
      ds.field("username", &self.username());
      ds.field("bio", &self.bio());
      ds.field("image", &self.image());
      ds.field("avatar", &self.avatar());
      ds.field("background", &self.background());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind0ParsedT {
  pub pubkey: Option<String>,
  pub name: Option<String>,
  pub display_name: Option<String>,
  pub picture: Option<String>,
  pub banner: Option<String>,
  pub about: Option<String>,
  pub website: Option<String>,
  pub nip05: Option<String>,
  pub lud06: Option<String>,
  pub lud16: Option<String>,
  pub github: Option<String>,
  pub twitter: Option<String>,
  pub mastodon: Option<String>,
  pub nostr: Option<String>,
  pub display_name_alt: Option<String>,
  pub username: Option<String>,
  pub bio: Option<String>,
  pub image: Option<String>,
  pub avatar: Option<String>,
  pub background: Option<String>,
}
impl Default for Kind0ParsedT {
  fn default() -> Self {
    Self {
      pubkey: None,
      name: None,
      display_name: None,
      picture: None,
      banner: None,
      about: None,
      website: None,
      nip05: None,
      lud06: None,
      lud16: None,
      github: None,
      twitter: None,
      mastodon: None,
      nostr: None,
      display_name_alt: None,
      username: None,
      bio: None,
      image: None,
      avatar: None,
      background: None,
    }
  }
}
impl Kind0ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind0Parsed<'b>> {
    let pubkey = self.pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let display_name = self.display_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let picture = self.picture.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let banner = self.banner.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let about = self.about.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let website = self.website.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let nip05 = self.nip05.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lud06 = self.lud06.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let lud16 = self.lud16.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let github = self.github.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let twitter = self.twitter.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mastodon = self.mastodon.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let nostr = self.nostr.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let display_name_alt = self.display_name_alt.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let username = self.username.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let bio = self.bio.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let avatar = self.avatar.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let background = self.background.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind0Parsed::create(_fbb, &Kind0ParsedArgs{
      pubkey,
      name,
      display_name,
      picture,
      banner,
      about,
      website,
      nip05,
      lud06,
      lud16,
      github,
      twitter,
      mastodon,
      nostr,
      display_name_alt,
      username,
      bio,
      image,
      avatar,
      background,
    })
  }
}
pub enum Kind1ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind1Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind1Parsed<'a> {
  type Inner = Kind1Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind1Parsed<'a> {
  pub const VT_PARSED_CONTENT: flatbuffers::VOffsetT = 4;
  pub const VT_SHORTENED_CONTENT: flatbuffers::VOffsetT = 6;
  pub const VT_QUOTES: flatbuffers::VOffsetT = 8;
  pub const VT_MENTIONS: flatbuffers::VOffsetT = 10;
  pub const VT_REPLY: flatbuffers::VOffsetT = 12;
  pub const VT_ROOT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind1Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind1ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind1Parsed<'bldr>> {
    let mut builder = Kind1ParsedBuilder::new(_fbb);
    if let Some(x) = args.root { builder.add_root(x); }
    if let Some(x) = args.reply { builder.add_reply(x); }
    if let Some(x) = args.mentions { builder.add_mentions(x); }
    if let Some(x) = args.quotes { builder.add_quotes(x); }
    if let Some(x) = args.shortened_content { builder.add_shortened_content(x); }
    if let Some(x) = args.parsed_content { builder.add_parsed_content(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind1ParsedT {
    let parsed_content = {
      let x = self.parsed_content();
      x.iter().map(|t| t.unpack()).collect()
    };
    let shortened_content = self.shortened_content().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let quotes = self.quotes().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let mentions = self.mentions().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let reply = self.reply().map(|x| {
      Box::new(x.unpack())
    });
    let root = self.root().map(|x| {
      Box::new(x.unpack())
    });
    Kind1ParsedT {
      parsed_content,
      shortened_content,
      quotes,
      mentions,
      reply,
      root,
    }
  }

  #[inline]
  pub fn parsed_content(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock>>>>(Kind1Parsed::VT_PARSED_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn shortened_content(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock>>>>(Kind1Parsed::VT_SHORTENED_CONTENT, None)}
  }
  #[inline]
  pub fn quotes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilePointer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilePointer>>>>(Kind1Parsed::VT_QUOTES, None)}
  }
  #[inline]
  pub fn mentions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventPointer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventPointer>>>>(Kind1Parsed::VT_MENTIONS, None)}
  }
  #[inline]
  pub fn reply(&self) -> Option<EventPointer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EventPointer>>(Kind1Parsed::VT_REPLY, None)}
  }
  #[inline]
  pub fn root(&self) -> Option<EventPointer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EventPointer>>(Kind1Parsed::VT_ROOT, None)}
  }
}

impl flatbuffers::Verifiable for Kind1Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentBlock>>>>("parsed_content", Self::VT_PARSED_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentBlock>>>>("shortened_content", Self::VT_SHORTENED_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProfilePointer>>>>("quotes", Self::VT_QUOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EventPointer>>>>("mentions", Self::VT_MENTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EventPointer>>("reply", Self::VT_REPLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EventPointer>>("root", Self::VT_ROOT, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind1ParsedArgs<'a> {
    pub parsed_content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>>>,
    pub shortened_content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>>>,
    pub quotes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProfilePointer<'a>>>>>,
    pub mentions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EventPointer<'a>>>>>,
    pub reply: Option<flatbuffers::WIPOffset<EventPointer<'a>>>,
    pub root: Option<flatbuffers::WIPOffset<EventPointer<'a>>>,
}
impl<'a> Default for Kind1ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind1ParsedArgs {
      parsed_content: None, // required field
      shortened_content: None,
      quotes: None,
      mentions: None,
      reply: None,
      root: None,
    }
  }
}

pub struct Kind1ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind1ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_parsed_content(&mut self, parsed_content: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_PARSED_CONTENT, parsed_content);
  }
  #[inline]
  pub fn add_shortened_content(&mut self, shortened_content: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_SHORTENED_CONTENT, shortened_content);
  }
  #[inline]
  pub fn add_quotes(&mut self, quotes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProfilePointer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_QUOTES, quotes);
  }
  #[inline]
  pub fn add_mentions(&mut self, mentions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EventPointer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind1Parsed::VT_MENTIONS, mentions);
  }
  #[inline]
  pub fn add_reply(&mut self, reply: flatbuffers::WIPOffset<EventPointer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EventPointer>>(Kind1Parsed::VT_REPLY, reply);
  }
  #[inline]
  pub fn add_root(&mut self, root: flatbuffers::WIPOffset<EventPointer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EventPointer>>(Kind1Parsed::VT_ROOT, root);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind1ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind1ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind1Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind1Parsed::VT_PARSED_CONTENT,"parsed_content");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind1Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind1Parsed");
      ds.field("parsed_content", &self.parsed_content());
      ds.field("shortened_content", &self.shortened_content());
      ds.field("quotes", &self.quotes());
      ds.field("mentions", &self.mentions());
      ds.field("reply", &self.reply());
      ds.field("root", &self.root());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind1ParsedT {
  pub parsed_content: Vec<ContentBlockT>,
  pub shortened_content: Option<Vec<ContentBlockT>>,
  pub quotes: Option<Vec<ProfilePointerT>>,
  pub mentions: Option<Vec<EventPointerT>>,
  pub reply: Option<Box<EventPointerT>>,
  pub root: Option<Box<EventPointerT>>,
}
impl Default for Kind1ParsedT {
  fn default() -> Self {
    Self {
      parsed_content: Default::default(),
      shortened_content: None,
      quotes: None,
      mentions: None,
      reply: None,
      root: None,
    }
  }
}
impl Kind1ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind1Parsed<'b>> {
    let parsed_content = Some({
      let x = &self.parsed_content;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let shortened_content = self.shortened_content.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let quotes = self.quotes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let mentions = self.mentions.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let reply = self.reply.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let root = self.root.as_ref().map(|x|{
      x.pack(_fbb)
    });
    Kind1Parsed::create(_fbb, &Kind1ParsedArgs{
      parsed_content,
      shortened_content,
      quotes,
      mentions,
      reply,
      root,
    })
  }
}
pub enum Kind3ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind3Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind3Parsed<'a> {
  type Inner = Kind3Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind3Parsed<'a> {
  pub const VT_CONTACTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind3Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind3ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind3Parsed<'bldr>> {
    let mut builder = Kind3ParsedBuilder::new(_fbb);
    if let Some(x) = args.contacts { builder.add_contacts(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind3ParsedT {
    let contacts = {
      let x = self.contacts();
      x.iter().map(|t| t.unpack()).collect()
    };
    Kind3ParsedT {
      contacts,
    }
  }

  #[inline]
  pub fn contacts(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact>>>>(Kind3Parsed::VT_CONTACTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind3Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Contact>>>>("contacts", Self::VT_CONTACTS, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind3ParsedArgs<'a> {
    pub contacts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>>>>,
}
impl<'a> Default for Kind3ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind3ParsedArgs {
      contacts: None, // required field
    }
  }
}

pub struct Kind3ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind3ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_contacts(&mut self, contacts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Contact<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind3Parsed::VT_CONTACTS, contacts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind3ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind3ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind3Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind3Parsed::VT_CONTACTS,"contacts");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind3Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind3Parsed");
      ds.field("contacts", &self.contacts());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind3ParsedT {
  pub contacts: Vec<ContactT>,
}
impl Default for Kind3ParsedT {
  fn default() -> Self {
    Self {
      contacts: Default::default(),
    }
  }
}
impl Kind3ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind3Parsed<'b>> {
    let contacts = Some({
      let x = &self.contacts;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Kind3Parsed::create(_fbb, &Kind3ParsedArgs{
      contacts,
    })
  }
}
pub enum Kind4ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind4Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind4Parsed<'a> {
  type Inner = Kind4Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind4Parsed<'a> {
  pub const VT_PARSED_CONTENT: flatbuffers::VOffsetT = 4;
  pub const VT_DECRYPTED_CONTENT: flatbuffers::VOffsetT = 6;
  pub const VT_CHAT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind4Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind4ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind4Parsed<'bldr>> {
    let mut builder = Kind4ParsedBuilder::new(_fbb);
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    if let Some(x) = args.chat_id { builder.add_chat_id(x); }
    if let Some(x) = args.decrypted_content { builder.add_decrypted_content(x); }
    if let Some(x) = args.parsed_content { builder.add_parsed_content(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind4ParsedT {
    let parsed_content = self.parsed_content().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let decrypted_content = self.decrypted_content().map(|x| {
      x.to_string()
    });
    let chat_id = {
      let x = self.chat_id();
      x.to_string()
    };
    let recipient = {
      let x = self.recipient();
      x.to_string()
    };
    Kind4ParsedT {
      parsed_content,
      decrypted_content,
      chat_id,
      recipient,
    }
  }

  #[inline]
  pub fn parsed_content(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock>>>>(Kind4Parsed::VT_PARSED_CONTENT, None)}
  }
  #[inline]
  pub fn decrypted_content(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind4Parsed::VT_DECRYPTED_CONTENT, None)}
  }
  #[inline]
  pub fn chat_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind4Parsed::VT_CHAT_ID, None).unwrap()}
  }
  #[inline]
  pub fn recipient(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind4Parsed::VT_RECIPIENT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind4Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentBlock>>>>("parsed_content", Self::VT_PARSED_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("decrypted_content", Self::VT_DECRYPTED_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chat_id", Self::VT_CHAT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind4ParsedArgs<'a> {
    pub parsed_content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentBlock<'a>>>>>,
    pub decrypted_content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chat_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind4ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind4ParsedArgs {
      parsed_content: None,
      decrypted_content: None,
      chat_id: None, // required field
      recipient: None, // required field
    }
  }
}

pub struct Kind4ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind4ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_parsed_content(&mut self, parsed_content: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_PARSED_CONTENT, parsed_content);
  }
  #[inline]
  pub fn add_decrypted_content(&mut self, decrypted_content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_DECRYPTED_CONTENT, decrypted_content);
  }
  #[inline]
  pub fn add_chat_id(&mut self, chat_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_CHAT_ID, chat_id);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind4Parsed::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind4ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind4ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind4Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind4Parsed::VT_CHAT_ID,"chat_id");
    self.fbb_.required(o, Kind4Parsed::VT_RECIPIENT,"recipient");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind4Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind4Parsed");
      ds.field("parsed_content", &self.parsed_content());
      ds.field("decrypted_content", &self.decrypted_content());
      ds.field("chat_id", &self.chat_id());
      ds.field("recipient", &self.recipient());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind4ParsedT {
  pub parsed_content: Option<Vec<ContentBlockT>>,
  pub decrypted_content: Option<String>,
  pub chat_id: String,
  pub recipient: String,
}
impl Default for Kind4ParsedT {
  fn default() -> Self {
    Self {
      parsed_content: None,
      decrypted_content: None,
      chat_id: "".to_string(),
      recipient: "".to_string(),
    }
  }
}
impl Kind4ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind4Parsed<'b>> {
    let parsed_content = self.parsed_content.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let decrypted_content = self.decrypted_content.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let chat_id = Some({
      let x = &self.chat_id;
      _fbb.create_string(x)
    });
    let recipient = Some({
      let x = &self.recipient;
      _fbb.create_string(x)
    });
    Kind4Parsed::create(_fbb, &Kind4ParsedArgs{
      parsed_content,
      decrypted_content,
      chat_id,
      recipient,
    })
  }
}
pub enum Kind6ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind6Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind6Parsed<'a> {
  type Inner = Kind6Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind6Parsed<'a> {
  pub const VT_REPOSTED_EVENT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind6Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind6ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind6Parsed<'bldr>> {
    let mut builder = Kind6ParsedBuilder::new(_fbb);
    if let Some(x) = args.reposted_event { builder.add_reposted_event(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind6ParsedT {
    let reposted_event = self.reposted_event().map(|x| {
      Box::new(x.unpack())
    });
    Kind6ParsedT {
      reposted_event,
    }
  }

  #[inline]
  pub fn reposted_event(&self) -> Option<ParsedEvent<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParsedEvent>>(Kind6Parsed::VT_REPOSTED_EVENT, None)}
  }
}

impl flatbuffers::Verifiable for Kind6Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParsedEvent>>("reposted_event", Self::VT_REPOSTED_EVENT, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind6ParsedArgs<'a> {
    pub reposted_event: Option<flatbuffers::WIPOffset<ParsedEvent<'a>>>,
}
impl<'a> Default for Kind6ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind6ParsedArgs {
      reposted_event: None,
    }
  }
}

pub struct Kind6ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind6ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reposted_event(&mut self, reposted_event: flatbuffers::WIPOffset<ParsedEvent<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParsedEvent>>(Kind6Parsed::VT_REPOSTED_EVENT, reposted_event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind6ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind6ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind6Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind6Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind6Parsed");
      ds.field("reposted_event", &self.reposted_event());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind6ParsedT {
  pub reposted_event: Option<Box<ParsedEventT>>,
}
impl Default for Kind6ParsedT {
  fn default() -> Self {
    Self {
      reposted_event: None,
    }
  }
}
impl Kind6ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind6Parsed<'b>> {
    let reposted_event = self.reposted_event.as_ref().map(|x|{
      x.pack(_fbb)
    });
    Kind6Parsed::create(_fbb, &Kind6ParsedArgs{
      reposted_event,
    })
  }
}
pub enum Kind7ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7Parsed<'a> {
  type Inner = Kind7Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7Parsed<'a> {
  pub const VT_REACTION_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 8;
  pub const VT_EVENT_KIND: flatbuffers::VOffsetT = 10;
  pub const VT_EMOJI: flatbuffers::VOffsetT = 12;
  pub const VT_TARGET_COORDINATES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7Parsed<'bldr>> {
    let mut builder = Kind7ParsedBuilder::new(_fbb);
    builder.add_event_kind(args.event_kind);
    if let Some(x) = args.target_coordinates { builder.add_target_coordinates(x); }
    if let Some(x) = args.emoji { builder.add_emoji(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.event_id { builder.add_event_id(x); }
    builder.add_reaction_type(args.reaction_type);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7ParsedT {
    let reaction_type = self.reaction_type();
    let event_id = {
      let x = self.event_id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let event_kind = self.event_kind();
    let emoji = self.emoji().map(|x| {
      Box::new(x.unpack())
    });
    let target_coordinates = self.target_coordinates().map(|x| {
      x.to_string()
    });
    Kind7ParsedT {
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    }
  }

  #[inline]
  pub fn reaction_type(&self) -> ReactionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReactionType>(Kind7Parsed::VT_REACTION_TYPE, Some(ReactionType::Like)).unwrap()}
  }
  #[inline]
  pub fn event_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7Parsed::VT_EVENT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7Parsed::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn event_kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind7Parsed::VT_EVENT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn emoji(&self) -> Option<Emoji<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Emoji>>(Kind7Parsed::VT_EMOJI, None)}
  }
  #[inline]
  pub fn target_coordinates(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7Parsed::VT_TARGET_COORDINATES, None)}
  }
}

impl flatbuffers::Verifiable for Kind7Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ReactionType>("reaction_type", Self::VT_REACTION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_id", Self::VT_EVENT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u64>("event_kind", Self::VT_EVENT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Emoji>>("emoji", Self::VT_EMOJI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_coordinates", Self::VT_TARGET_COORDINATES, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7ParsedArgs<'a> {
    pub reaction_type: ReactionType,
    pub event_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_kind: u64,
    pub emoji: Option<flatbuffers::WIPOffset<Emoji<'a>>>,
    pub target_coordinates: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind7ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7ParsedArgs {
      reaction_type: ReactionType::Like,
      event_id: None, // required field
      pubkey: None, // required field
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}

pub struct Kind7ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reaction_type(&mut self, reaction_type: ReactionType) {
    self.fbb_.push_slot::<ReactionType>(Kind7Parsed::VT_REACTION_TYPE, reaction_type, ReactionType::Like);
  }
  #[inline]
  pub fn add_event_id(&mut self, event_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7Parsed::VT_EVENT_ID, event_id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7Parsed::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_event_kind(&mut self, event_kind: u64) {
    self.fbb_.push_slot::<u64>(Kind7Parsed::VT_EVENT_KIND, event_kind, 0);
  }
  #[inline]
  pub fn add_emoji(&mut self, emoji: flatbuffers::WIPOffset<Emoji<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Emoji>>(Kind7Parsed::VT_EMOJI, emoji);
  }
  #[inline]
  pub fn add_target_coordinates(&mut self, target_coordinates: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7Parsed::VT_TARGET_COORDINATES, target_coordinates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7Parsed::VT_EVENT_ID,"event_id");
    self.fbb_.required(o, Kind7Parsed::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7Parsed");
      ds.field("reaction_type", &self.reaction_type());
      ds.field("event_id", &self.event_id());
      ds.field("pubkey", &self.pubkey());
      ds.field("event_kind", &self.event_kind());
      ds.field("emoji", &self.emoji());
      ds.field("target_coordinates", &self.target_coordinates());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7ParsedT {
  pub reaction_type: ReactionType,
  pub event_id: String,
  pub pubkey: String,
  pub event_kind: u64,
  pub emoji: Option<Box<EmojiT>>,
  pub target_coordinates: Option<String>,
}
impl Default for Kind7ParsedT {
  fn default() -> Self {
    Self {
      reaction_type: ReactionType::Like,
      event_id: "".to_string(),
      pubkey: "".to_string(),
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}
impl Kind7ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7Parsed<'b>> {
    let reaction_type = self.reaction_type;
    let event_id = Some({
      let x = &self.event_id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let event_kind = self.event_kind;
    let emoji = self.emoji.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let target_coordinates = self.target_coordinates.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind7Parsed::create(_fbb, &Kind7ParsedArgs{
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    })
  }
}
pub enum Kind17ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind17Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind17Parsed<'a> {
  type Inner = Kind17Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind17Parsed<'a> {
  pub const VT_REACTION_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 8;
  pub const VT_EVENT_KIND: flatbuffers::VOffsetT = 10;
  pub const VT_EMOJI: flatbuffers::VOffsetT = 12;
  pub const VT_TARGET_COORDINATES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind17Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind17ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind17Parsed<'bldr>> {
    let mut builder = Kind17ParsedBuilder::new(_fbb);
    builder.add_event_kind(args.event_kind);
    if let Some(x) = args.target_coordinates { builder.add_target_coordinates(x); }
    if let Some(x) = args.emoji { builder.add_emoji(x); }
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.event_id { builder.add_event_id(x); }
    builder.add_reaction_type(args.reaction_type);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind17ParsedT {
    let reaction_type = self.reaction_type();
    let event_id = {
      let x = self.event_id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let event_kind = self.event_kind();
    let emoji = self.emoji().map(|x| {
      Box::new(x.unpack())
    });
    let target_coordinates = self.target_coordinates().map(|x| {
      x.to_string()
    });
    Kind17ParsedT {
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    }
  }

  #[inline]
  pub fn reaction_type(&self) -> ReactionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReactionType>(Kind17Parsed::VT_REACTION_TYPE, Some(ReactionType::Like)).unwrap()}
  }
  #[inline]
  pub fn event_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17Parsed::VT_EVENT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17Parsed::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn event_kind(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind17Parsed::VT_EVENT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn emoji(&self) -> Option<Emoji<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Emoji>>(Kind17Parsed::VT_EMOJI, None)}
  }
  #[inline]
  pub fn target_coordinates(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17Parsed::VT_TARGET_COORDINATES, None)}
  }
}

impl flatbuffers::Verifiable for Kind17Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ReactionType>("reaction_type", Self::VT_REACTION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_id", Self::VT_EVENT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u64>("event_kind", Self::VT_EVENT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Emoji>>("emoji", Self::VT_EMOJI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_coordinates", Self::VT_TARGET_COORDINATES, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind17ParsedArgs<'a> {
    pub reaction_type: ReactionType,
    pub event_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_kind: u64,
    pub emoji: Option<flatbuffers::WIPOffset<Emoji<'a>>>,
    pub target_coordinates: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind17ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind17ParsedArgs {
      reaction_type: ReactionType::Like,
      event_id: None, // required field
      pubkey: None, // required field
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}

pub struct Kind17ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind17ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reaction_type(&mut self, reaction_type: ReactionType) {
    self.fbb_.push_slot::<ReactionType>(Kind17Parsed::VT_REACTION_TYPE, reaction_type, ReactionType::Like);
  }
  #[inline]
  pub fn add_event_id(&mut self, event_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17Parsed::VT_EVENT_ID, event_id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17Parsed::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_event_kind(&mut self, event_kind: u64) {
    self.fbb_.push_slot::<u64>(Kind17Parsed::VT_EVENT_KIND, event_kind, 0);
  }
  #[inline]
  pub fn add_emoji(&mut self, emoji: flatbuffers::WIPOffset<Emoji<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Emoji>>(Kind17Parsed::VT_EMOJI, emoji);
  }
  #[inline]
  pub fn add_target_coordinates(&mut self, target_coordinates: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17Parsed::VT_TARGET_COORDINATES, target_coordinates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind17ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind17ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind17Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind17Parsed::VT_EVENT_ID,"event_id");
    self.fbb_.required(o, Kind17Parsed::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind17Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind17Parsed");
      ds.field("reaction_type", &self.reaction_type());
      ds.field("event_id", &self.event_id());
      ds.field("pubkey", &self.pubkey());
      ds.field("event_kind", &self.event_kind());
      ds.field("emoji", &self.emoji());
      ds.field("target_coordinates", &self.target_coordinates());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind17ParsedT {
  pub reaction_type: ReactionType,
  pub event_id: String,
  pub pubkey: String,
  pub event_kind: u64,
  pub emoji: Option<Box<EmojiT>>,
  pub target_coordinates: Option<String>,
}
impl Default for Kind17ParsedT {
  fn default() -> Self {
    Self {
      reaction_type: ReactionType::Like,
      event_id: "".to_string(),
      pubkey: "".to_string(),
      event_kind: 0,
      emoji: None,
      target_coordinates: None,
    }
  }
}
impl Kind17ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind17Parsed<'b>> {
    let reaction_type = self.reaction_type;
    let event_id = Some({
      let x = &self.event_id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let event_kind = self.event_kind;
    let emoji = self.emoji.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let target_coordinates = self.target_coordinates.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind17Parsed::create(_fbb, &Kind17ParsedArgs{
      reaction_type,
      event_id,
      pubkey,
      event_kind,
      emoji,
      target_coordinates,
    })
  }
}
pub enum Kind10002ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind10002Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind10002Parsed<'a> {
  type Inner = Kind10002Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind10002Parsed<'a> {
  pub const VT_RELAYS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind10002Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind10002ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind10002Parsed<'bldr>> {
    let mut builder = Kind10002ParsedBuilder::new(_fbb);
    if let Some(x) = args.relays { builder.add_relays(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind10002ParsedT {
    let relays = {
      let x = self.relays();
      x.iter().map(|t| t.unpack()).collect()
    };
    Kind10002ParsedT {
      relays,
    }
  }

  #[inline]
  pub fn relays(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelayInfo<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelayInfo>>>>(Kind10002Parsed::VT_RELAYS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind10002Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RelayInfo>>>>("relays", Self::VT_RELAYS, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind10002ParsedArgs<'a> {
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelayInfo<'a>>>>>,
}
impl<'a> Default for Kind10002ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind10002ParsedArgs {
      relays: None, // required field
    }
  }
}

pub struct Kind10002ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind10002ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RelayInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10002Parsed::VT_RELAYS, relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind10002ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind10002ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind10002Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind10002Parsed::VT_RELAYS,"relays");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind10002Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind10002Parsed");
      ds.field("relays", &self.relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind10002ParsedT {
  pub relays: Vec<RelayInfoT>,
}
impl Default for Kind10002ParsedT {
  fn default() -> Self {
    Self {
      relays: Default::default(),
    }
  }
}
impl Kind10002ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind10002Parsed<'b>> {
    let relays = Some({
      let x = &self.relays;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Kind10002Parsed::create(_fbb, &Kind10002ParsedArgs{
      relays,
    })
  }
}
pub enum Kind10019ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind10019Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind10019Parsed<'a> {
  type Inner = Kind10019Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind10019Parsed<'a> {
  pub const VT_TRUSTED_MINTS: flatbuffers::VOffsetT = 4;
  pub const VT_P2PK_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_READ_RELAYS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind10019Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind10019ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind10019Parsed<'bldr>> {
    let mut builder = Kind10019ParsedBuilder::new(_fbb);
    if let Some(x) = args.read_relays { builder.add_read_relays(x); }
    if let Some(x) = args.p2pk_pubkey { builder.add_p2pk_pubkey(x); }
    if let Some(x) = args.trusted_mints { builder.add_trusted_mints(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind10019ParsedT {
    let trusted_mints = self.trusted_mints().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let p2pk_pubkey = self.p2pk_pubkey().map(|x| {
      x.to_string()
    });
    let read_relays = self.read_relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    Kind10019ParsedT {
      trusted_mints,
      p2pk_pubkey,
      read_relays,
    }
  }

  #[inline]
  pub fn trusted_mints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintInfo>>>>(Kind10019Parsed::VT_TRUSTED_MINTS, None)}
  }
  #[inline]
  pub fn p2pk_pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind10019Parsed::VT_P2PK_PUBKEY, None)}
  }
  #[inline]
  pub fn read_relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind10019Parsed::VT_READ_RELAYS, None)}
  }
}

impl flatbuffers::Verifiable for Kind10019Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MintInfo>>>>("trusted_mints", Self::VT_TRUSTED_MINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_pubkey", Self::VT_P2PK_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("read_relays", Self::VT_READ_RELAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind10019ParsedArgs<'a> {
    pub trusted_mints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintInfo<'a>>>>>,
    pub p2pk_pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub read_relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for Kind10019ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind10019ParsedArgs {
      trusted_mints: None,
      p2pk_pubkey: None,
      read_relays: None,
    }
  }
}

pub struct Kind10019ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind10019ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_trusted_mints(&mut self, trusted_mints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MintInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10019Parsed::VT_TRUSTED_MINTS, trusted_mints);
  }
  #[inline]
  pub fn add_p2pk_pubkey(&mut self, p2pk_pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10019Parsed::VT_P2PK_PUBKEY, p2pk_pubkey);
  }
  #[inline]
  pub fn add_read_relays(&mut self, read_relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind10019Parsed::VT_READ_RELAYS, read_relays);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind10019ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind10019ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind10019Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind10019Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind10019Parsed");
      ds.field("trusted_mints", &self.trusted_mints());
      ds.field("p2pk_pubkey", &self.p2pk_pubkey());
      ds.field("read_relays", &self.read_relays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind10019ParsedT {
  pub trusted_mints: Option<Vec<MintInfoT>>,
  pub p2pk_pubkey: Option<String>,
  pub read_relays: Option<Vec<String>>,
}
impl Default for Kind10019ParsedT {
  fn default() -> Self {
    Self {
      trusted_mints: None,
      p2pk_pubkey: None,
      read_relays: None,
    }
  }
}
impl Kind10019ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind10019Parsed<'b>> {
    let trusted_mints = self.trusted_mints.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let p2pk_pubkey = self.p2pk_pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let read_relays = self.read_relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    Kind10019Parsed::create(_fbb, &Kind10019ParsedArgs{
      trusted_mints,
      p2pk_pubkey,
      read_relays,
    })
  }
}
pub enum Kind17375ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind17375Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind17375Parsed<'a> {
  type Inner = Kind17375Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind17375Parsed<'a> {
  pub const VT_MINTS: flatbuffers::VOffsetT = 4;
  pub const VT_P2PK_PRIV_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_P2PK_PUB_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_DECRYPTED: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind17375Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind17375ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind17375Parsed<'bldr>> {
    let mut builder = Kind17375ParsedBuilder::new(_fbb);
    if let Some(x) = args.p2pk_pub_key { builder.add_p2pk_pub_key(x); }
    if let Some(x) = args.p2pk_priv_key { builder.add_p2pk_priv_key(x); }
    if let Some(x) = args.mints { builder.add_mints(x); }
    builder.add_decrypted(args.decrypted);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind17375ParsedT {
    let mints = {
      let x = self.mints();
      x.iter().map(|s| s.to_string()).collect()
    };
    let p2pk_priv_key = self.p2pk_priv_key().map(|x| {
      x.to_string()
    });
    let p2pk_pub_key = self.p2pk_pub_key().map(|x| {
      x.to_string()
    });
    let decrypted = self.decrypted();
    Kind17375ParsedT {
      mints,
      p2pk_priv_key,
      p2pk_pub_key,
      decrypted,
    }
  }

  #[inline]
  pub fn mints(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind17375Parsed::VT_MINTS, None).unwrap()}
  }
  #[inline]
  pub fn p2pk_priv_key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17375Parsed::VT_P2PK_PRIV_KEY, None)}
  }
  #[inline]
  pub fn p2pk_pub_key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind17375Parsed::VT_P2PK_PUB_KEY, None)}
  }
  #[inline]
  pub fn decrypted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind17375Parsed::VT_DECRYPTED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind17375Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mints", Self::VT_MINTS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_priv_key", Self::VT_P2PK_PRIV_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_pub_key", Self::VT_P2PK_PUB_KEY, false)?
     .visit_field::<bool>("decrypted", Self::VT_DECRYPTED, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind17375ParsedArgs<'a> {
    pub mints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub p2pk_priv_key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub p2pk_pub_key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub decrypted: bool,
}
impl<'a> Default for Kind17375ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind17375ParsedArgs {
      mints: None, // required field
      p2pk_priv_key: None,
      p2pk_pub_key: None,
      decrypted: false,
    }
  }
}

pub struct Kind17375ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind17375ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mints(&mut self, mints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17375Parsed::VT_MINTS, mints);
  }
  #[inline]
  pub fn add_p2pk_priv_key(&mut self, p2pk_priv_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17375Parsed::VT_P2PK_PRIV_KEY, p2pk_priv_key);
  }
  #[inline]
  pub fn add_p2pk_pub_key(&mut self, p2pk_pub_key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind17375Parsed::VT_P2PK_PUB_KEY, p2pk_pub_key);
  }
  #[inline]
  pub fn add_decrypted(&mut self, decrypted: bool) {
    self.fbb_.push_slot::<bool>(Kind17375Parsed::VT_DECRYPTED, decrypted, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind17375ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind17375ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind17375Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind17375Parsed::VT_MINTS,"mints");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind17375Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind17375Parsed");
      ds.field("mints", &self.mints());
      ds.field("p2pk_priv_key", &self.p2pk_priv_key());
      ds.field("p2pk_pub_key", &self.p2pk_pub_key());
      ds.field("decrypted", &self.decrypted());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind17375ParsedT {
  pub mints: Vec<String>,
  pub p2pk_priv_key: Option<String>,
  pub p2pk_pub_key: Option<String>,
  pub decrypted: bool,
}
impl Default for Kind17375ParsedT {
  fn default() -> Self {
    Self {
      mints: Default::default(),
      p2pk_priv_key: None,
      p2pk_pub_key: None,
      decrypted: false,
    }
  }
}
impl Kind17375ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind17375Parsed<'b>> {
    let mints = Some({
      let x = &self.mints;
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let p2pk_priv_key = self.p2pk_priv_key.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let p2pk_pub_key = self.p2pk_pub_key.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let decrypted = self.decrypted;
    Kind17375Parsed::create(_fbb, &Kind17375ParsedArgs{
      mints,
      p2pk_priv_key,
      p2pk_pub_key,
      decrypted,
    })
  }
}
pub enum Kind39089ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind39089Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind39089Parsed<'a> {
  type Inner = Kind39089Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind39089Parsed<'a> {
  pub const VT_LIST_IDENTIFIER: flatbuffers::VOffsetT = 4;
  pub const VT_PEOPLE: flatbuffers::VOffsetT = 6;
  pub const VT_TITLE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind39089Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind39089ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind39089Parsed<'bldr>> {
    let mut builder = Kind39089ParsedBuilder::new(_fbb);
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.people { builder.add_people(x); }
    if let Some(x) = args.list_identifier { builder.add_list_identifier(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind39089ParsedT {
    let list_identifier = {
      let x = self.list_identifier();
      x.to_string()
    };
    let people = {
      let x = self.people();
      x.iter().map(|s| s.to_string()).collect()
    };
    let title = self.title().map(|x| {
      x.to_string()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let image = self.image().map(|x| {
      x.to_string()
    });
    Kind39089ParsedT {
      list_identifier,
      people,
      title,
      description,
      image,
    }
  }

  #[inline]
  pub fn list_identifier(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind39089Parsed::VT_LIST_IDENTIFIER, None).unwrap()}
  }
  #[inline]
  pub fn people(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind39089Parsed::VT_PEOPLE, None).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind39089Parsed::VT_TITLE, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind39089Parsed::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind39089Parsed::VT_IMAGE, None)}
  }
}

impl flatbuffers::Verifiable for Kind39089Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("list_identifier", Self::VT_LIST_IDENTIFIER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("people", Self::VT_PEOPLE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind39089ParsedArgs<'a> {
    pub list_identifier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub people: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind39089ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind39089ParsedArgs {
      list_identifier: None, // required field
      people: None, // required field
      title: None,
      description: None,
      image: None,
    }
  }
}

pub struct Kind39089ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind39089ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_list_identifier(&mut self, list_identifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind39089Parsed::VT_LIST_IDENTIFIER, list_identifier);
  }
  #[inline]
  pub fn add_people(&mut self, people: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind39089Parsed::VT_PEOPLE, people);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind39089Parsed::VT_TITLE, title);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind39089Parsed::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind39089Parsed::VT_IMAGE, image);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind39089ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind39089ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind39089Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind39089Parsed::VT_LIST_IDENTIFIER,"list_identifier");
    self.fbb_.required(o, Kind39089Parsed::VT_PEOPLE,"people");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind39089Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind39089Parsed");
      ds.field("list_identifier", &self.list_identifier());
      ds.field("people", &self.people());
      ds.field("title", &self.title());
      ds.field("description", &self.description());
      ds.field("image", &self.image());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind39089ParsedT {
  pub list_identifier: String,
  pub people: Vec<String>,
  pub title: Option<String>,
  pub description: Option<String>,
  pub image: Option<String>,
}
impl Default for Kind39089ParsedT {
  fn default() -> Self {
    Self {
      list_identifier: "".to_string(),
      people: Default::default(),
      title: None,
      description: None,
      image: None,
    }
  }
}
impl Kind39089ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind39089Parsed<'b>> {
    let list_identifier = Some({
      let x = &self.list_identifier;
      _fbb.create_string(x)
    });
    let people = Some({
      let x = &self.people;
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let title = self.title.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let image = self.image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind39089Parsed::create(_fbb, &Kind39089ParsedArgs{
      list_identifier,
      people,
      title,
      description,
      image,
    })
  }
}
pub enum Kind7374ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7374Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7374Parsed<'a> {
  type Inner = Kind7374Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7374Parsed<'a> {
  pub const VT_QUOTE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MINT_URL: flatbuffers::VOffsetT = 6;
  pub const VT_EXPIRATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7374Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7374ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7374Parsed<'bldr>> {
    let mut builder = Kind7374ParsedBuilder::new(_fbb);
    builder.add_expiration(args.expiration);
    if let Some(x) = args.mint_url { builder.add_mint_url(x); }
    if let Some(x) = args.quote_id { builder.add_quote_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7374ParsedT {
    let quote_id = {
      let x = self.quote_id();
      x.to_string()
    };
    let mint_url = {
      let x = self.mint_url();
      x.to_string()
    };
    let expiration = self.expiration();
    Kind7374ParsedT {
      quote_id,
      mint_url,
      expiration,
    }
  }

  #[inline]
  pub fn quote_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7374Parsed::VT_QUOTE_ID, None).unwrap()}
  }
  #[inline]
  pub fn mint_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7374Parsed::VT_MINT_URL, None).unwrap()}
  }
  #[inline]
  pub fn expiration(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind7374Parsed::VT_EXPIRATION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind7374Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("quote_id", Self::VT_QUOTE_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint_url", Self::VT_MINT_URL, true)?
     .visit_field::<u64>("expiration", Self::VT_EXPIRATION, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7374ParsedArgs<'a> {
    pub quote_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mint_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expiration: u64,
}
impl<'a> Default for Kind7374ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7374ParsedArgs {
      quote_id: None, // required field
      mint_url: None, // required field
      expiration: 0,
    }
  }
}

pub struct Kind7374ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7374ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_quote_id(&mut self, quote_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7374Parsed::VT_QUOTE_ID, quote_id);
  }
  #[inline]
  pub fn add_mint_url(&mut self, mint_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7374Parsed::VT_MINT_URL, mint_url);
  }
  #[inline]
  pub fn add_expiration(&mut self, expiration: u64) {
    self.fbb_.push_slot::<u64>(Kind7374Parsed::VT_EXPIRATION, expiration, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7374ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7374ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7374Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7374Parsed::VT_QUOTE_ID,"quote_id");
    self.fbb_.required(o, Kind7374Parsed::VT_MINT_URL,"mint_url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7374Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7374Parsed");
      ds.field("quote_id", &self.quote_id());
      ds.field("mint_url", &self.mint_url());
      ds.field("expiration", &self.expiration());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7374ParsedT {
  pub quote_id: String,
  pub mint_url: String,
  pub expiration: u64,
}
impl Default for Kind7374ParsedT {
  fn default() -> Self {
    Self {
      quote_id: "".to_string(),
      mint_url: "".to_string(),
      expiration: 0,
    }
  }
}
impl Kind7374ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7374Parsed<'b>> {
    let quote_id = Some({
      let x = &self.quote_id;
      _fbb.create_string(x)
    });
    let mint_url = Some({
      let x = &self.mint_url;
      _fbb.create_string(x)
    });
    let expiration = self.expiration;
    Kind7374Parsed::create(_fbb, &Kind7374ParsedArgs{
      quote_id,
      mint_url,
      expiration,
    })
  }
}
pub enum Kind7375ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7375Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7375Parsed<'a> {
  type Inner = Kind7375Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7375Parsed<'a> {
  pub const VT_MINT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_PROOFS: flatbuffers::VOffsetT = 6;
  pub const VT_DELETED_IDS: flatbuffers::VOffsetT = 8;
  pub const VT_DECRYPTED: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7375Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7375ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7375Parsed<'bldr>> {
    let mut builder = Kind7375ParsedBuilder::new(_fbb);
    if let Some(x) = args.deleted_ids { builder.add_deleted_ids(x); }
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    if let Some(x) = args.mint_url { builder.add_mint_url(x); }
    builder.add_decrypted(args.decrypted);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7375ParsedT {
    let mint_url = {
      let x = self.mint_url();
      x.to_string()
    };
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    let deleted_ids = self.deleted_ids().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let decrypted = self.decrypted();
    Kind7375ParsedT {
      mint_url,
      proofs,
      deleted_ids,
      decrypted,
    }
  }

  #[inline]
  pub fn mint_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7375Parsed::VT_MINT_URL, None).unwrap()}
  }
  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof>>>>(Kind7375Parsed::VT_PROOFS, None).unwrap()}
  }
  #[inline]
  pub fn deleted_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7375Parsed::VT_DELETED_IDS, None)}
  }
  #[inline]
  pub fn decrypted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind7375Parsed::VT_DECRYPTED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind7375Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint_url", Self::VT_MINT_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Proof>>>>("proofs", Self::VT_PROOFS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("deleted_ids", Self::VT_DELETED_IDS, false)?
     .visit_field::<bool>("decrypted", Self::VT_DECRYPTED, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7375ParsedArgs<'a> {
    pub mint_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>>>,
    pub deleted_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub decrypted: bool,
}
impl<'a> Default for Kind7375ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7375ParsedArgs {
      mint_url: None, // required field
      proofs: None, // required field
      deleted_ids: None,
      decrypted: false,
    }
  }
}

pub struct Kind7375ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7375ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mint_url(&mut self, mint_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7375Parsed::VT_MINT_URL, mint_url);
  }
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Proof<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7375Parsed::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn add_deleted_ids(&mut self, deleted_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7375Parsed::VT_DELETED_IDS, deleted_ids);
  }
  #[inline]
  pub fn add_decrypted(&mut self, decrypted: bool) {
    self.fbb_.push_slot::<bool>(Kind7375Parsed::VT_DECRYPTED, decrypted, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7375ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7375ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7375Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7375Parsed::VT_MINT_URL,"mint_url");
    self.fbb_.required(o, Kind7375Parsed::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7375Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7375Parsed");
      ds.field("mint_url", &self.mint_url());
      ds.field("proofs", &self.proofs());
      ds.field("deleted_ids", &self.deleted_ids());
      ds.field("decrypted", &self.decrypted());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7375ParsedT {
  pub mint_url: String,
  pub proofs: Vec<ProofT>,
  pub deleted_ids: Option<Vec<String>>,
  pub decrypted: bool,
}
impl Default for Kind7375ParsedT {
  fn default() -> Self {
    Self {
      mint_url: "".to_string(),
      proofs: Default::default(),
      deleted_ids: None,
      decrypted: false,
    }
  }
}
impl Kind7375ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7375Parsed<'b>> {
    let mint_url = Some({
      let x = &self.mint_url;
      _fbb.create_string(x)
    });
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let deleted_ids = self.deleted_ids.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let decrypted = self.decrypted;
    Kind7375Parsed::create(_fbb, &Kind7375ParsedArgs{
      mint_url,
      proofs,
      deleted_ids,
      decrypted,
    })
  }
}
pub enum Kind7376ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind7376Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind7376Parsed<'a> {
  type Inner = Kind7376Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind7376Parsed<'a> {
  pub const VT_DIRECTION: flatbuffers::VOffsetT = 4;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_CREATED_EVENTS: flatbuffers::VOffsetT = 8;
  pub const VT_DESTROYED_EVENTS: flatbuffers::VOffsetT = 10;
  pub const VT_REDEEMED_EVENTS: flatbuffers::VOffsetT = 12;
  pub const VT_TAGS: flatbuffers::VOffsetT = 14;
  pub const VT_DECRYPTED: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind7376Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind7376ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind7376Parsed<'bldr>> {
    let mut builder = Kind7376ParsedBuilder::new(_fbb);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.redeemed_events { builder.add_redeemed_events(x); }
    if let Some(x) = args.destroyed_events { builder.add_destroyed_events(x); }
    if let Some(x) = args.created_events { builder.add_created_events(x); }
    builder.add_amount(args.amount);
    if let Some(x) = args.direction { builder.add_direction(x); }
    builder.add_decrypted(args.decrypted);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind7376ParsedT {
    let direction = {
      let x = self.direction();
      x.to_string()
    };
    let amount = self.amount();
    let created_events = self.created_events().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let destroyed_events = self.destroyed_events().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let redeemed_events = self.redeemed_events().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tags = self.tags().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let decrypted = self.decrypted();
    Kind7376ParsedT {
      direction,
      amount,
      created_events,
      destroyed_events,
      redeemed_events,
      tags,
      decrypted,
    }
  }

  #[inline]
  pub fn direction(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind7376Parsed::VT_DIRECTION, None).unwrap()}
  }
  #[inline]
  pub fn amount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Kind7376Parsed::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn created_events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7376Parsed::VT_CREATED_EVENTS, None)}
  }
  #[inline]
  pub fn destroyed_events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7376Parsed::VT_DESTROYED_EVENTS, None)}
  }
  #[inline]
  pub fn redeemed_events(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Kind7376Parsed::VT_REDEEMED_EVENTS, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HistoryTag<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HistoryTag>>>>(Kind7376Parsed::VT_TAGS, None)}
  }
  #[inline]
  pub fn decrypted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind7376Parsed::VT_DECRYPTED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind7376Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("direction", Self::VT_DIRECTION, true)?
     .visit_field::<i32>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("created_events", Self::VT_CREATED_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("destroyed_events", Self::VT_DESTROYED_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("redeemed_events", Self::VT_REDEEMED_EVENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HistoryTag>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<bool>("decrypted", Self::VT_DECRYPTED, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind7376ParsedArgs<'a> {
    pub direction: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amount: i32,
    pub created_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub destroyed_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub redeemed_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HistoryTag<'a>>>>>,
    pub decrypted: bool,
}
impl<'a> Default for Kind7376ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind7376ParsedArgs {
      direction: None, // required field
      amount: 0,
      created_events: None,
      destroyed_events: None,
      redeemed_events: None,
      tags: None,
      decrypted: false,
    }
  }
}

pub struct Kind7376ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind7376ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_direction(&mut self, direction: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_DIRECTION, direction);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: i32) {
    self.fbb_.push_slot::<i32>(Kind7376Parsed::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_created_events(&mut self, created_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_CREATED_EVENTS, created_events);
  }
  #[inline]
  pub fn add_destroyed_events(&mut self, destroyed_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_DESTROYED_EVENTS, destroyed_events);
  }
  #[inline]
  pub fn add_redeemed_events(&mut self, redeemed_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_REDEEMED_EVENTS, redeemed_events);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<HistoryTag<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind7376Parsed::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_decrypted(&mut self, decrypted: bool) {
    self.fbb_.push_slot::<bool>(Kind7376Parsed::VT_DECRYPTED, decrypted, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind7376ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind7376ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind7376Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind7376Parsed::VT_DIRECTION,"direction");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind7376Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind7376Parsed");
      ds.field("direction", &self.direction());
      ds.field("amount", &self.amount());
      ds.field("created_events", &self.created_events());
      ds.field("destroyed_events", &self.destroyed_events());
      ds.field("redeemed_events", &self.redeemed_events());
      ds.field("tags", &self.tags());
      ds.field("decrypted", &self.decrypted());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind7376ParsedT {
  pub direction: String,
  pub amount: i32,
  pub created_events: Option<Vec<String>>,
  pub destroyed_events: Option<Vec<String>>,
  pub redeemed_events: Option<Vec<String>>,
  pub tags: Option<Vec<HistoryTagT>>,
  pub decrypted: bool,
}
impl Default for Kind7376ParsedT {
  fn default() -> Self {
    Self {
      direction: "".to_string(),
      amount: 0,
      created_events: None,
      destroyed_events: None,
      redeemed_events: None,
      tags: None,
      decrypted: false,
    }
  }
}
impl Kind7376ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind7376Parsed<'b>> {
    let direction = Some({
      let x = &self.direction;
      _fbb.create_string(x)
    });
    let amount = self.amount;
    let created_events = self.created_events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let destroyed_events = self.destroyed_events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let redeemed_events = self.redeemed_events.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tags = self.tags.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let decrypted = self.decrypted;
    Kind7376Parsed::create(_fbb, &Kind7376ParsedArgs{
      direction,
      amount,
      created_events,
      destroyed_events,
      redeemed_events,
      tags,
      decrypted,
    })
  }
}
pub enum Kind9321ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind9321Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind9321Parsed<'a> {
  type Inner = Kind9321Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind9321Parsed<'a> {
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 4;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 6;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_MINT_URL: flatbuffers::VOffsetT = 10;
  pub const VT_REDEEMED: flatbuffers::VOffsetT = 12;
  pub const VT_PROOFS: flatbuffers::VOffsetT = 14;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 16;
  pub const VT_IS_P2PK_LOCKED: flatbuffers::VOffsetT = 18;
  pub const VT_P2PK_PUBKEY: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind9321Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind9321ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind9321Parsed<'bldr>> {
    let mut builder = Kind9321ParsedBuilder::new(_fbb);
    if let Some(x) = args.p2pk_pubkey { builder.add_p2pk_pubkey(x); }
    if let Some(x) = args.comment { builder.add_comment(x); }
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    if let Some(x) = args.mint_url { builder.add_mint_url(x); }
    if let Some(x) = args.event_id { builder.add_event_id(x); }
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    builder.add_amount(args.amount);
    builder.add_is_p2pk_locked(args.is_p2pk_locked);
    builder.add_redeemed(args.redeemed);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind9321ParsedT {
    let amount = self.amount();
    let recipient = {
      let x = self.recipient();
      x.to_string()
    };
    let event_id = self.event_id().map(|x| {
      x.to_string()
    });
    let mint_url = {
      let x = self.mint_url();
      x.to_string()
    };
    let redeemed = self.redeemed();
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    let comment = self.comment().map(|x| {
      x.to_string()
    });
    let is_p2pk_locked = self.is_p2pk_locked();
    let p2pk_pubkey = self.p2pk_pubkey().map(|x| {
      x.to_string()
    });
    Kind9321ParsedT {
      amount,
      recipient,
      event_id,
      mint_url,
      redeemed,
      proofs,
      comment,
      is_p2pk_locked,
      p2pk_pubkey,
    }
  }

  #[inline]
  pub fn amount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Kind9321Parsed::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn recipient(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_RECIPIENT, None).unwrap()}
  }
  #[inline]
  pub fn event_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_EVENT_ID, None)}
  }
  #[inline]
  pub fn mint_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_MINT_URL, None).unwrap()}
  }
  #[inline]
  pub fn redeemed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind9321Parsed::VT_REDEEMED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof>>>>(Kind9321Parsed::VT_PROOFS, None).unwrap()}
  }
  #[inline]
  pub fn comment(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_COMMENT, None)}
  }
  #[inline]
  pub fn is_p2pk_locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind9321Parsed::VT_IS_P2PK_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn p2pk_pubkey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9321Parsed::VT_P2PK_PUBKEY, None)}
  }
}

impl flatbuffers::Verifiable for Kind9321Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_id", Self::VT_EVENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint_url", Self::VT_MINT_URL, true)?
     .visit_field::<bool>("redeemed", Self::VT_REDEEMED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Proof>>>>("proofs", Self::VT_PROOFS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comment", Self::VT_COMMENT, false)?
     .visit_field::<bool>("is_p2pk_locked", Self::VT_IS_P2PK_LOCKED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("p2pk_pubkey", Self::VT_P2PK_PUBKEY, false)?
     .finish();
    Ok(())
  }
}
pub struct Kind9321ParsedArgs<'a> {
    pub amount: i32,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mint_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub redeemed: bool,
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>>>,
    pub comment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_p2pk_locked: bool,
    pub p2pk_pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for Kind9321ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind9321ParsedArgs {
      amount: 0,
      recipient: None, // required field
      event_id: None,
      mint_url: None, // required field
      redeemed: false,
      proofs: None, // required field
      comment: None,
      is_p2pk_locked: false,
      p2pk_pubkey: None,
    }
  }
}

pub struct Kind9321ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind9321ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_amount(&mut self, amount: i32) {
    self.fbb_.push_slot::<i32>(Kind9321Parsed::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn add_event_id(&mut self, event_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_EVENT_ID, event_id);
  }
  #[inline]
  pub fn add_mint_url(&mut self, mint_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_MINT_URL, mint_url);
  }
  #[inline]
  pub fn add_redeemed(&mut self, redeemed: bool) {
    self.fbb_.push_slot::<bool>(Kind9321Parsed::VT_REDEEMED, redeemed, false);
  }
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Proof<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_COMMENT, comment);
  }
  #[inline]
  pub fn add_is_p2pk_locked(&mut self, is_p2pk_locked: bool) {
    self.fbb_.push_slot::<bool>(Kind9321Parsed::VT_IS_P2PK_LOCKED, is_p2pk_locked, false);
  }
  #[inline]
  pub fn add_p2pk_pubkey(&mut self, p2pk_pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9321Parsed::VT_P2PK_PUBKEY, p2pk_pubkey);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind9321ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind9321ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind9321Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind9321Parsed::VT_RECIPIENT,"recipient");
    self.fbb_.required(o, Kind9321Parsed::VT_MINT_URL,"mint_url");
    self.fbb_.required(o, Kind9321Parsed::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind9321Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind9321Parsed");
      ds.field("amount", &self.amount());
      ds.field("recipient", &self.recipient());
      ds.field("event_id", &self.event_id());
      ds.field("mint_url", &self.mint_url());
      ds.field("redeemed", &self.redeemed());
      ds.field("proofs", &self.proofs());
      ds.field("comment", &self.comment());
      ds.field("is_p2pk_locked", &self.is_p2pk_locked());
      ds.field("p2pk_pubkey", &self.p2pk_pubkey());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind9321ParsedT {
  pub amount: i32,
  pub recipient: String,
  pub event_id: Option<String>,
  pub mint_url: String,
  pub redeemed: bool,
  pub proofs: Vec<ProofT>,
  pub comment: Option<String>,
  pub is_p2pk_locked: bool,
  pub p2pk_pubkey: Option<String>,
}
impl Default for Kind9321ParsedT {
  fn default() -> Self {
    Self {
      amount: 0,
      recipient: "".to_string(),
      event_id: None,
      mint_url: "".to_string(),
      redeemed: false,
      proofs: Default::default(),
      comment: None,
      is_p2pk_locked: false,
      p2pk_pubkey: None,
    }
  }
}
impl Kind9321ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind9321Parsed<'b>> {
    let amount = self.amount;
    let recipient = Some({
      let x = &self.recipient;
      _fbb.create_string(x)
    });
    let event_id = self.event_id.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let mint_url = Some({
      let x = &self.mint_url;
      _fbb.create_string(x)
    });
    let redeemed = self.redeemed;
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let comment = self.comment.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let is_p2pk_locked = self.is_p2pk_locked;
    let p2pk_pubkey = self.p2pk_pubkey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Kind9321Parsed::create(_fbb, &Kind9321ParsedArgs{
      amount,
      recipient,
      event_id,
      mint_url,
      redeemed,
      proofs,
      comment,
      is_p2pk_locked,
      p2pk_pubkey,
    })
  }
}
pub enum Kind9735ParsedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Kind9735Parsed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Kind9735Parsed<'a> {
  type Inner = Kind9735Parsed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Kind9735Parsed<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;
  pub const VT_BOLT11: flatbuffers::VOffsetT = 10;
  pub const VT_PREIMAGE: flatbuffers::VOffsetT = 12;
  pub const VT_SENDER: flatbuffers::VOffsetT = 14;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 16;
  pub const VT_EVENT: flatbuffers::VOffsetT = 18;
  pub const VT_EVENT_COORDINATE: flatbuffers::VOffsetT = 20;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 22;
  pub const VT_VALID: flatbuffers::VOffsetT = 24;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Kind9735Parsed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args Kind9735ParsedArgs<'args>
  ) -> flatbuffers::WIPOffset<Kind9735Parsed<'bldr>> {
    let mut builder = Kind9735ParsedBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.event_coordinate { builder.add_event_coordinate(x); }
    if let Some(x) = args.event { builder.add_event(x); }
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    if let Some(x) = args.sender { builder.add_sender(x); }
    if let Some(x) = args.preimage { builder.add_preimage(x); }
    if let Some(x) = args.bolt11 { builder.add_bolt11(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_amount(args.amount);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_valid(args.valid);
    builder.finish()
  }

  pub fn unpack(&self) -> Kind9735ParsedT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let amount = self.amount();
    let content = {
      let x = self.content();
      x.to_string()
    };
    let bolt11 = {
      let x = self.bolt11();
      x.to_string()
    };
    let preimage = self.preimage().map(|x| {
      x.to_string()
    });
    let sender = {
      let x = self.sender();
      x.to_string()
    };
    let recipient = {
      let x = self.recipient();
      x.to_string()
    };
    let event = self.event().map(|x| {
      x.to_string()
    });
    let event_coordinate = self.event_coordinate().map(|x| {
      x.to_string()
    });
    let timestamp = self.timestamp();
    let valid = self.valid();
    let description = {
      let x = self.description();
      Box::new(x.unpack())
    };
    Kind9735ParsedT {
      id,
      amount,
      content,
      bolt11,
      preimage,
      sender,
      recipient,
      event,
      event_coordinate,
      timestamp,
      valid,
      description,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn amount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Kind9735Parsed::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_CONTENT, None).unwrap()}
  }
  #[inline]
  pub fn bolt11(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_BOLT11, None).unwrap()}
  }
  #[inline]
  pub fn preimage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_PREIMAGE, None)}
  }
  #[inline]
  pub fn sender(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_SENDER, None).unwrap()}
  }
  #[inline]
  pub fn recipient(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_RECIPIENT, None).unwrap()}
  }
  #[inline]
  pub fn event(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_EVENT, None)}
  }
  #[inline]
  pub fn event_coordinate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Kind9735Parsed::VT_EVENT_COORDINATE, None)}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Kind9735Parsed::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn valid(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Kind9735Parsed::VT_VALID, Some(false)).unwrap()}
  }
  #[inline]
  pub fn description(&self) -> ZapRequest<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ZapRequest>>(Kind9735Parsed::VT_DESCRIPTION, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Kind9735Parsed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<i32>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bolt11", Self::VT_BOLT11, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("preimage", Self::VT_PREIMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender", Self::VT_SENDER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event", Self::VT_EVENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_coordinate", Self::VT_EVENT_COORDINATE, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<bool>("valid", Self::VT_VALID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ZapRequest>>("description", Self::VT_DESCRIPTION, true)?
     .finish();
    Ok(())
  }
}
pub struct Kind9735ParsedArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amount: i32,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bolt11: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preimage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_coordinate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
    pub valid: bool,
    pub description: Option<flatbuffers::WIPOffset<ZapRequest<'a>>>,
}
impl<'a> Default for Kind9735ParsedArgs<'a> {
  #[inline]
  fn default() -> Self {
    Kind9735ParsedArgs {
      id: None, // required field
      amount: 0,
      content: None, // required field
      bolt11: None, // required field
      preimage: None,
      sender: None, // required field
      recipient: None, // required field
      event: None,
      event_coordinate: None,
      timestamp: 0,
      valid: false,
      description: None, // required field
    }
  }
}

pub struct Kind9735ParsedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Kind9735ParsedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_ID, id);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: i32) {
    self.fbb_.push_slot::<i32>(Kind9735Parsed::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_bolt11(&mut self, bolt11: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_BOLT11, bolt11);
  }
  #[inline]
  pub fn add_preimage(&mut self, preimage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_PREIMAGE, preimage);
  }
  #[inline]
  pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_SENDER, sender);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_EVENT, event);
  }
  #[inline]
  pub fn add_event_coordinate(&mut self, event_coordinate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Kind9735Parsed::VT_EVENT_COORDINATE, event_coordinate);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(Kind9735Parsed::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_valid(&mut self, valid: bool) {
    self.fbb_.push_slot::<bool>(Kind9735Parsed::VT_VALID, valid, false);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<ZapRequest<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ZapRequest>>(Kind9735Parsed::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Kind9735ParsedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    Kind9735ParsedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Kind9735Parsed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Kind9735Parsed::VT_ID,"id");
    self.fbb_.required(o, Kind9735Parsed::VT_CONTENT,"content");
    self.fbb_.required(o, Kind9735Parsed::VT_BOLT11,"bolt11");
    self.fbb_.required(o, Kind9735Parsed::VT_SENDER,"sender");
    self.fbb_.required(o, Kind9735Parsed::VT_RECIPIENT,"recipient");
    self.fbb_.required(o, Kind9735Parsed::VT_DESCRIPTION,"description");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Kind9735Parsed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Kind9735Parsed");
      ds.field("id", &self.id());
      ds.field("amount", &self.amount());
      ds.field("content", &self.content());
      ds.field("bolt11", &self.bolt11());
      ds.field("preimage", &self.preimage());
      ds.field("sender", &self.sender());
      ds.field("recipient", &self.recipient());
      ds.field("event", &self.event());
      ds.field("event_coordinate", &self.event_coordinate());
      ds.field("timestamp", &self.timestamp());
      ds.field("valid", &self.valid());
      ds.field("description", &self.description());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Kind9735ParsedT {
  pub id: String,
  pub amount: i32,
  pub content: String,
  pub bolt11: String,
  pub preimage: Option<String>,
  pub sender: String,
  pub recipient: String,
  pub event: Option<String>,
  pub event_coordinate: Option<String>,
  pub timestamp: u64,
  pub valid: bool,
  pub description: Box<ZapRequestT>,
}
impl Default for Kind9735ParsedT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      amount: 0,
      content: "".to_string(),
      bolt11: "".to_string(),
      preimage: None,
      sender: "".to_string(),
      recipient: "".to_string(),
      event: None,
      event_coordinate: None,
      timestamp: 0,
      valid: false,
      description: Default::default(),
    }
  }
}
impl Kind9735ParsedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Kind9735Parsed<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let amount = self.amount;
    let content = Some({
      let x = &self.content;
      _fbb.create_string(x)
    });
    let bolt11 = Some({
      let x = &self.bolt11;
      _fbb.create_string(x)
    });
    let preimage = self.preimage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sender = Some({
      let x = &self.sender;
      _fbb.create_string(x)
    });
    let recipient = Some({
      let x = &self.recipient;
      _fbb.create_string(x)
    });
    let event = self.event.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let event_coordinate = self.event_coordinate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let timestamp = self.timestamp;
    let valid = self.valid;
    let description = Some({
      let x = &self.description;
      x.pack(_fbb)
    });
    Kind9735Parsed::create(_fbb, &Kind9735ParsedArgs{
      id,
      amount,
      content,
      bolt11,
      preimage,
      sender,
      recipient,
      event,
      event_coordinate,
      timestamp,
      valid,
      description,
    })
  }
}
pub enum ParsedEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ParsedEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParsedEvent<'a> {
  type Inner = ParsedEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParsedEvent<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
  pub const VT_KIND: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 10;
  pub const VT_PARSED_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_PARSED: flatbuffers::VOffsetT = 14;
  pub const VT_REQUESTS: flatbuffers::VOffsetT = 16;
  pub const VT_RELAYS: flatbuffers::VOffsetT = 18;
  pub const VT_TAGS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParsedEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParsedEventArgs<'args>
  ) -> flatbuffers::WIPOffset<ParsedEvent<'bldr>> {
    let mut builder = ParsedEventBuilder::new(_fbb);
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.relays { builder.add_relays(x); }
    if let Some(x) = args.requests { builder.add_requests(x); }
    if let Some(x) = args.parsed { builder.add_parsed(x); }
    builder.add_created_at(args.created_at);
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_kind(args.kind);
    builder.add_parsed_type(args.parsed_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ParsedEventT {
    let id = {
      let x = self.id();
      x.to_string()
    };
    let pubkey = {
      let x = self.pubkey();
      x.to_string()
    };
    let kind = self.kind();
    let created_at = self.created_at();
    let parsed = match self.parsed_type() {
      ParsedData::NONE => ParsedDataT::NONE,
      ParsedData::Kind0Parsed => ParsedDataT::Kind0Parsed(Box::new(
        self.parsed_as_kind_0_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind0Parsed`.")
            .unpack()
      )),
      ParsedData::Kind1Parsed => ParsedDataT::Kind1Parsed(Box::new(
        self.parsed_as_kind_1_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind1Parsed`.")
            .unpack()
      )),
      ParsedData::Kind3Parsed => ParsedDataT::Kind3Parsed(Box::new(
        self.parsed_as_kind_3_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind3Parsed`.")
            .unpack()
      )),
      ParsedData::Kind4Parsed => ParsedDataT::Kind4Parsed(Box::new(
        self.parsed_as_kind_4_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind4Parsed`.")
            .unpack()
      )),
      ParsedData::Kind6Parsed => ParsedDataT::Kind6Parsed(Box::new(
        self.parsed_as_kind_6_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind6Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7Parsed => ParsedDataT::Kind7Parsed(Box::new(
        self.parsed_as_kind_7_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7Parsed`.")
            .unpack()
      )),
      ParsedData::Kind17Parsed => ParsedDataT::Kind17Parsed(Box::new(
        self.parsed_as_kind_17_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind17Parsed`.")
            .unpack()
      )),
      ParsedData::Kind10002Parsed => ParsedDataT::Kind10002Parsed(Box::new(
        self.parsed_as_kind_10002_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind10002Parsed`.")
            .unpack()
      )),
      ParsedData::Kind10019Parsed => ParsedDataT::Kind10019Parsed(Box::new(
        self.parsed_as_kind_10019_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind10019Parsed`.")
            .unpack()
      )),
      ParsedData::Kind17375Parsed => ParsedDataT::Kind17375Parsed(Box::new(
        self.parsed_as_kind_17375_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind17375Parsed`.")
            .unpack()
      )),
      ParsedData::Kind39089Parsed => ParsedDataT::Kind39089Parsed(Box::new(
        self.parsed_as_kind_39089_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind39089Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7374Parsed => ParsedDataT::Kind7374Parsed(Box::new(
        self.parsed_as_kind_7374_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7374Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7375Parsed => ParsedDataT::Kind7375Parsed(Box::new(
        self.parsed_as_kind_7375_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7375Parsed`.")
            .unpack()
      )),
      ParsedData::Kind7376Parsed => ParsedDataT::Kind7376Parsed(Box::new(
        self.parsed_as_kind_7376_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind7376Parsed`.")
            .unpack()
      )),
      ParsedData::Kind9321Parsed => ParsedDataT::Kind9321Parsed(Box::new(
        self.parsed_as_kind_9321_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind9321Parsed`.")
            .unpack()
      )),
      ParsedData::Kind9735Parsed => ParsedDataT::Kind9735Parsed(Box::new(
        self.parsed_as_kind_9735_parsed()
            .expect("Invalid union table, expected `ParsedData::Kind9735Parsed`.")
            .unpack()
      )),
      _ => ParsedDataT::NONE,
    };
    let requests = self.requests().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let relays = self.relays().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let tags = {
      let x = self.tags();
      x.iter().map(|t| t.unpack()).collect()
    };
    ParsedEventT {
      id,
      pubkey,
      kind,
      created_at,
      parsed,
      requests,
      relays,
      tags,
    }
  }

  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParsedEvent::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pubkey(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParsedEvent::VT_PUBKEY, None).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ParsedEvent::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ParsedEvent::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn parsed_type(&self) -> ParsedData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParsedData>(ParsedEvent::VT_PARSED_TYPE, Some(ParsedData::NONE)).unwrap()}
  }
  #[inline]
  pub fn parsed(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ParsedEvent::VT_PARSED, None)}
  }
  #[inline]
  pub fn requests(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request>>>>(ParsedEvent::VT_REQUESTS, None)}
  }
  #[inline]
  pub fn relays(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ParsedEvent::VT_RELAYS, None)}
  }
  #[inline]
  pub fn tags(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec>>>>(ParsedEvent::VT_TAGS, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_0_parsed(&self) -> Option<Kind0Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind0Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind0Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_1_parsed(&self) -> Option<Kind1Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind1Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind1Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_3_parsed(&self) -> Option<Kind3Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind3Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind3Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_4_parsed(&self) -> Option<Kind4Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind4Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind4Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_6_parsed(&self) -> Option<Kind6Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind6Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind6Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7_parsed(&self) -> Option<Kind7Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_17_parsed(&self) -> Option<Kind17Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind17Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind17Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_10002_parsed(&self) -> Option<Kind10002Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind10002Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind10002Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_10019_parsed(&self) -> Option<Kind10019Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind10019Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind10019Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_17375_parsed(&self) -> Option<Kind17375Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind17375Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind17375Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_39089_parsed(&self) -> Option<Kind39089Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind39089Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind39089Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7374_parsed(&self) -> Option<Kind7374Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7374Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7374Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7375_parsed(&self) -> Option<Kind7375Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7375Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7375Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_7376_parsed(&self) -> Option<Kind7376Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind7376Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind7376Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_9321_parsed(&self) -> Option<Kind9321Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind9321Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind9321Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parsed_as_kind_9735_parsed(&self) -> Option<Kind9735Parsed<'a>> {
    if self.parsed_type() == ParsedData::Kind9735Parsed {
      self.parsed().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Kind9735Parsed::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ParsedEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<u32>("created_at", Self::VT_CREATED_AT, false)?
     .visit_union::<ParsedData, _>("parsed_type", Self::VT_PARSED_TYPE, "parsed", Self::VT_PARSED, false, |key, v, pos| {
        match key {
          ParsedData::Kind0Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind0Parsed>>("ParsedData::Kind0Parsed", pos),
          ParsedData::Kind1Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind1Parsed>>("ParsedData::Kind1Parsed", pos),
          ParsedData::Kind3Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind3Parsed>>("ParsedData::Kind3Parsed", pos),
          ParsedData::Kind4Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind4Parsed>>("ParsedData::Kind4Parsed", pos),
          ParsedData::Kind6Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind6Parsed>>("ParsedData::Kind6Parsed", pos),
          ParsedData::Kind7Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7Parsed>>("ParsedData::Kind7Parsed", pos),
          ParsedData::Kind17Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind17Parsed>>("ParsedData::Kind17Parsed", pos),
          ParsedData::Kind10002Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind10002Parsed>>("ParsedData::Kind10002Parsed", pos),
          ParsedData::Kind10019Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind10019Parsed>>("ParsedData::Kind10019Parsed", pos),
          ParsedData::Kind17375Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind17375Parsed>>("ParsedData::Kind17375Parsed", pos),
          ParsedData::Kind39089Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind39089Parsed>>("ParsedData::Kind39089Parsed", pos),
          ParsedData::Kind7374Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7374Parsed>>("ParsedData::Kind7374Parsed", pos),
          ParsedData::Kind7375Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7375Parsed>>("ParsedData::Kind7375Parsed", pos),
          ParsedData::Kind7376Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind7376Parsed>>("ParsedData::Kind7376Parsed", pos),
          ParsedData::Kind9321Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind9321Parsed>>("ParsedData::Kind9321Parsed", pos),
          ParsedData::Kind9735Parsed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Kind9735Parsed>>("ParsedData::Kind9735Parsed", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Request>>>>("requests", Self::VT_REQUESTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("relays", Self::VT_RELAYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringVec>>>>("tags", Self::VT_TAGS, true)?
     .finish();
    Ok(())
  }
}
pub struct ParsedEventArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: u16,
    pub created_at: u32,
    pub parsed_type: ParsedData,
    pub parsed: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub requests: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Request<'a>>>>>,
    pub relays: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringVec<'a>>>>>,
}
impl<'a> Default for ParsedEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParsedEventArgs {
      id: None, // required field
      pubkey: None, // required field
      kind: 0,
      created_at: 0,
      parsed_type: ParsedData::NONE,
      parsed: None,
      requests: None,
      relays: None,
      tags: None, // required field
    }
  }
}

pub struct ParsedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParsedEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_ID, id);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(ParsedEvent::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: u32) {
    self.fbb_.push_slot::<u32>(ParsedEvent::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_parsed_type(&mut self, parsed_type: ParsedData) {
    self.fbb_.push_slot::<ParsedData>(ParsedEvent::VT_PARSED_TYPE, parsed_type, ParsedData::NONE);
  }
  #[inline]
  pub fn add_parsed(&mut self, parsed: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_PARSED, parsed);
  }
  #[inline]
  pub fn add_requests(&mut self, requests: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Request<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_REQUESTS, requests);
  }
  #[inline]
  pub fn add_relays(&mut self, relays: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_RELAYS, relays);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringVec<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParsedEvent::VT_TAGS, tags);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParsedEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParsedEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParsedEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ParsedEvent::VT_ID,"id");
    self.fbb_.required(o, ParsedEvent::VT_PUBKEY,"pubkey");
    self.fbb_.required(o, ParsedEvent::VT_TAGS,"tags");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParsedEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParsedEvent");
      ds.field("id", &self.id());
      ds.field("pubkey", &self.pubkey());
      ds.field("kind", &self.kind());
      ds.field("created_at", &self.created_at());
      ds.field("parsed_type", &self.parsed_type());
      match self.parsed_type() {
        ParsedData::Kind0Parsed => {
          if let Some(x) = self.parsed_as_kind_0_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind1Parsed => {
          if let Some(x) = self.parsed_as_kind_1_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind3Parsed => {
          if let Some(x) = self.parsed_as_kind_3_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind4Parsed => {
          if let Some(x) = self.parsed_as_kind_4_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind6Parsed => {
          if let Some(x) = self.parsed_as_kind_6_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7Parsed => {
          if let Some(x) = self.parsed_as_kind_7_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind17Parsed => {
          if let Some(x) = self.parsed_as_kind_17_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind10002Parsed => {
          if let Some(x) = self.parsed_as_kind_10002_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind10019Parsed => {
          if let Some(x) = self.parsed_as_kind_10019_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind17375Parsed => {
          if let Some(x) = self.parsed_as_kind_17375_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind39089Parsed => {
          if let Some(x) = self.parsed_as_kind_39089_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7374Parsed => {
          if let Some(x) = self.parsed_as_kind_7374_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7375Parsed => {
          if let Some(x) = self.parsed_as_kind_7375_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind7376Parsed => {
          if let Some(x) = self.parsed_as_kind_7376_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind9321Parsed => {
          if let Some(x) = self.parsed_as_kind_9321_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParsedData::Kind9735Parsed => {
          if let Some(x) = self.parsed_as_kind_9735_parsed() {
            ds.field("parsed", &x)
          } else {
            ds.field("parsed", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("parsed", &x)
        },
      };
      ds.field("requests", &self.requests());
      ds.field("relays", &self.relays());
      ds.field("tags", &self.tags());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParsedEventT {
  pub id: String,
  pub pubkey: String,
  pub kind: u16,
  pub created_at: u32,
  pub parsed: ParsedDataT,
  pub requests: Option<Vec<RequestT>>,
  pub relays: Option<Vec<String>>,
  pub tags: Vec<StringVecT>,
}
impl Default for ParsedEventT {
  fn default() -> Self {
    Self {
      id: "".to_string(),
      pubkey: "".to_string(),
      kind: 0,
      created_at: 0,
      parsed: ParsedDataT::NONE,
      requests: None,
      relays: None,
      tags: Default::default(),
    }
  }
}
impl ParsedEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParsedEvent<'b>> {
    let id = Some({
      let x = &self.id;
      _fbb.create_string(x)
    });
    let pubkey = Some({
      let x = &self.pubkey;
      _fbb.create_string(x)
    });
    let kind = self.kind;
    let created_at = self.created_at;
    let parsed_type = self.parsed.parsed_data_type();
    let parsed = self.parsed.pack(_fbb);
    let requests = self.requests.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let relays = self.relays.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let tags = Some({
      let x = &self.tags;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ParsedEvent::create(_fbb, &ParsedEventArgs{
      id,
      pubkey,
      kind,
      created_at,
      parsed_type,
      parsed,
      requests,
      relays,
      tags,
    })
  }
}
pub enum ConnectionStatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConnectionStatus<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConnectionStatus<'a> {
  type Inner = ConnectionStatus<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConnectionStatus<'a> {
  pub const VT_RELAY_URL: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: flatbuffers::VOffsetT = 6;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConnectionStatus { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConnectionStatusArgs<'args>
  ) -> flatbuffers::WIPOffset<ConnectionStatus<'bldr>> {
    let mut builder = ConnectionStatusBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.relay_url { builder.add_relay_url(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ConnectionStatusT {
    let relay_url = {
      let x = self.relay_url();
      x.to_string()
    };
    let status = {
      let x = self.status();
      x.to_string()
    };
    let message = self.message().map(|x| {
      x.to_string()
    });
    ConnectionStatusT {
      relay_url,
      status,
      message,
    }
  }

  #[inline]
  pub fn relay_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionStatus::VT_RELAY_URL, None).unwrap()}
  }
  #[inline]
  pub fn status(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionStatus::VT_STATUS, None).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectionStatus::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for ConnectionStatus<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relay_url", Self::VT_RELAY_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct ConnectionStatusArgs<'a> {
    pub relay_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ConnectionStatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConnectionStatusArgs {
      relay_url: None, // required field
      status: None, // required field
      message: None,
    }
  }
}

pub struct ConnectionStatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConnectionStatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_relay_url(&mut self, relay_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionStatus::VT_RELAY_URL, relay_url);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionStatus::VT_STATUS, status);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectionStatus::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConnectionStatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConnectionStatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConnectionStatus<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ConnectionStatus::VT_RELAY_URL,"relay_url");
    self.fbb_.required(o, ConnectionStatus::VT_STATUS,"status");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConnectionStatus<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConnectionStatus");
      ds.field("relay_url", &self.relay_url());
      ds.field("status", &self.status());
      ds.field("message", &self.message());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConnectionStatusT {
  pub relay_url: String,
  pub status: String,
  pub message: Option<String>,
}
impl Default for ConnectionStatusT {
  fn default() -> Self {
    Self {
      relay_url: "".to_string(),
      status: "".to_string(),
      message: None,
    }
  }
}
impl ConnectionStatusT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ConnectionStatus<'b>> {
    let relay_url = Some({
      let x = &self.relay_url;
      _fbb.create_string(x)
    });
    let status = Some({
      let x = &self.status;
      _fbb.create_string(x)
    });
    let message = self.message.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ConnectionStatus::create(_fbb, &ConnectionStatusArgs{
      relay_url,
      status,
      message,
    })
  }
}
pub enum CountResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CountResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CountResponse<'a> {
  type Inner = CountResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CountResponse<'a> {
  pub const VT_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_KIND: flatbuffers::VOffsetT = 6;
  pub const VT_YOU: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CountResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CountResponseArgs
  ) -> flatbuffers::WIPOffset<CountResponse<'bldr>> {
    let mut builder = CountResponseBuilder::new(_fbb);
    builder.add_count(args.count);
    builder.add_kind(args.kind);
    builder.add_you(args.you);
    builder.finish()
  }

  pub fn unpack(&self) -> CountResponseT {
    let count = self.count();
    let kind = self.kind();
    let you = self.you();
    CountResponseT {
      count,
      kind,
      you,
    }
  }

  #[inline]
  pub fn count(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CountResponse::VT_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn kind(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(CountResponse::VT_KIND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn you(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CountResponse::VT_YOU, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CountResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("count", Self::VT_COUNT, false)?
     .visit_field::<u16>("kind", Self::VT_KIND, false)?
     .visit_field::<bool>("you", Self::VT_YOU, false)?
     .finish();
    Ok(())
  }
}
pub struct CountResponseArgs {
    pub count: u32,
    pub kind: u16,
    pub you: bool,
}
impl<'a> Default for CountResponseArgs {
  #[inline]
  fn default() -> Self {
    CountResponseArgs {
      count: 0,
      kind: 0,
      you: false,
    }
  }
}

pub struct CountResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CountResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_count(&mut self, count: u32) {
    self.fbb_.push_slot::<u32>(CountResponse::VT_COUNT, count, 0);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: u16) {
    self.fbb_.push_slot::<u16>(CountResponse::VT_KIND, kind, 0);
  }
  #[inline]
  pub fn add_you(&mut self, you: bool) {
    self.fbb_.push_slot::<bool>(CountResponse::VT_YOU, you, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CountResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CountResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CountResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CountResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CountResponse");
      ds.field("count", &self.count());
      ds.field("kind", &self.kind());
      ds.field("you", &self.you());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CountResponseT {
  pub count: u32,
  pub kind: u16,
  pub you: bool,
}
impl Default for CountResponseT {
  fn default() -> Self {
    Self {
      count: 0,
      kind: 0,
      you: false,
    }
  }
}
impl CountResponseT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CountResponse<'b>> {
    let count = self.count;
    let kind = self.kind;
    let you = self.you;
    CountResponse::create(_fbb, &CountResponseArgs{
      count,
      kind,
      you,
    })
  }
}
pub enum EoceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Eoce<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Eoce<'a> {
  type Inner = Eoce<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Eoce<'a> {
  pub const VT_SUBSCRIPTION_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Eoce { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EoceArgs<'args>
  ) -> flatbuffers::WIPOffset<Eoce<'bldr>> {
    let mut builder = EoceBuilder::new(_fbb);
    if let Some(x) = args.subscription_id { builder.add_subscription_id(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EoceT {
    let subscription_id = {
      let x = self.subscription_id();
      x.to_string()
    };
    EoceT {
      subscription_id,
    }
  }

  #[inline]
  pub fn subscription_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Eoce::VT_SUBSCRIPTION_ID, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Eoce<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscription_id", Self::VT_SUBSCRIPTION_ID, true)?
     .finish();
    Ok(())
  }
}
pub struct EoceArgs<'a> {
    pub subscription_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EoceArgs<'a> {
  #[inline]
  fn default() -> Self {
    EoceArgs {
      subscription_id: None, // required field
    }
  }
}

pub struct EoceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EoceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_subscription_id(&mut self, subscription_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Eoce::VT_SUBSCRIPTION_ID, subscription_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EoceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EoceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Eoce<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Eoce::VT_SUBSCRIPTION_ID,"subscription_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Eoce<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Eoce");
      ds.field("subscription_id", &self.subscription_id());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EoceT {
  pub subscription_id: String,
}
impl Default for EoceT {
  fn default() -> Self {
    Self {
      subscription_id: "".to_string(),
    }
  }
}
impl EoceT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Eoce<'b>> {
    let subscription_id = Some({
      let x = &self.subscription_id;
      _fbb.create_string(x)
    });
    Eoce::create(_fbb, &EoceArgs{
      subscription_id,
    })
  }
}
pub enum BufferFullOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BufferFull<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BufferFull<'a> {
  type Inner = BufferFull<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BufferFull<'a> {
  pub const VT_SUBSCRIPTION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DROPPED_EVENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BufferFull { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BufferFullArgs<'args>
  ) -> flatbuffers::WIPOffset<BufferFull<'bldr>> {
    let mut builder = BufferFullBuilder::new(_fbb);
    if let Some(x) = args.subscription_id { builder.add_subscription_id(x); }
    builder.add_dropped_events(args.dropped_events);
    builder.finish()
  }

  pub fn unpack(&self) -> BufferFullT {
    let subscription_id = {
      let x = self.subscription_id();
      x.to_string()
    };
    let dropped_events = self.dropped_events();
    BufferFullT {
      subscription_id,
      dropped_events,
    }
  }

  #[inline]
  pub fn subscription_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BufferFull::VT_SUBSCRIPTION_ID, None).unwrap()}
  }
  #[inline]
  pub fn dropped_events(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(BufferFull::VT_DROPPED_EVENTS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BufferFull<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscription_id", Self::VT_SUBSCRIPTION_ID, true)?
     .visit_field::<u16>("dropped_events", Self::VT_DROPPED_EVENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct BufferFullArgs<'a> {
    pub subscription_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropped_events: u16,
}
impl<'a> Default for BufferFullArgs<'a> {
  #[inline]
  fn default() -> Self {
    BufferFullArgs {
      subscription_id: None, // required field
      dropped_events: 0,
    }
  }
}

pub struct BufferFullBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BufferFullBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_subscription_id(&mut self, subscription_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BufferFull::VT_SUBSCRIPTION_ID, subscription_id);
  }
  #[inline]
  pub fn add_dropped_events(&mut self, dropped_events: u16) {
    self.fbb_.push_slot::<u16>(BufferFull::VT_DROPPED_EVENTS, dropped_events, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BufferFullBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BufferFullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BufferFull<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, BufferFull::VT_SUBSCRIPTION_ID,"subscription_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BufferFull<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BufferFull");
      ds.field("subscription_id", &self.subscription_id());
      ds.field("dropped_events", &self.dropped_events());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BufferFullT {
  pub subscription_id: String,
  pub dropped_events: u16,
}
impl Default for BufferFullT {
  fn default() -> Self {
    Self {
      subscription_id: "".to_string(),
      dropped_events: 0,
    }
  }
}
impl BufferFullT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BufferFull<'b>> {
    let subscription_id = Some({
      let x = &self.subscription_id;
      _fbb.create_string(x)
    });
    let dropped_events = self.dropped_events;
    BufferFull::create(_fbb, &BufferFullArgs{
      subscription_id,
      dropped_events,
    })
  }
}
pub enum ValidProofsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValidProofs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValidProofs<'a> {
  type Inner = ValidProofs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ValidProofs<'a> {
  pub const VT_PROOFS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ValidProofs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValidProofsArgs<'args>
  ) -> flatbuffers::WIPOffset<ValidProofs<'bldr>> {
    let mut builder = ValidProofsBuilder::new(_fbb);
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ValidProofsT {
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    ValidProofsT {
      proofs,
    }
  }

  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintProofs<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintProofs>>>>(ValidProofs::VT_PROOFS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ValidProofs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MintProofs>>>>("proofs", Self::VT_PROOFS, true)?
     .finish();
    Ok(())
  }
}
pub struct ValidProofsArgs<'a> {
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MintProofs<'a>>>>>,
}
impl<'a> Default for ValidProofsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValidProofsArgs {
      proofs: None, // required field
    }
  }
}

pub struct ValidProofsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValidProofsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MintProofs<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ValidProofs::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValidProofsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValidProofsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ValidProofs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ValidProofs::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ValidProofs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ValidProofs");
      ds.field("proofs", &self.proofs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ValidProofsT {
  pub proofs: Vec<MintProofsT>,
}
impl Default for ValidProofsT {
  fn default() -> Self {
    Self {
      proofs: Default::default(),
    }
  }
}
impl ValidProofsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ValidProofs<'b>> {
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ValidProofs::create(_fbb, &ValidProofsArgs{
      proofs,
    })
  }
}
pub enum MintProofsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MintProofs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MintProofs<'a> {
  type Inner = MintProofs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MintProofs<'a> {
  pub const VT_MINT: flatbuffers::VOffsetT = 4;
  pub const VT_PROOFS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MintProofs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MintProofsArgs<'args>
  ) -> flatbuffers::WIPOffset<MintProofs<'bldr>> {
    let mut builder = MintProofsBuilder::new(_fbb);
    if let Some(x) = args.proofs { builder.add_proofs(x); }
    if let Some(x) = args.mint { builder.add_mint(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MintProofsT {
    let mint = {
      let x = self.mint();
      x.to_string()
    };
    let proofs = {
      let x = self.proofs();
      x.iter().map(|t| t.unpack()).collect()
    };
    MintProofsT {
      mint,
      proofs,
    }
  }

  #[inline]
  pub fn mint(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MintProofs::VT_MINT, None).unwrap()}
  }
  #[inline]
  pub fn proofs(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof>>>>(MintProofs::VT_PROOFS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for MintProofs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mint", Self::VT_MINT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Proof>>>>("proofs", Self::VT_PROOFS, true)?
     .finish();
    Ok(())
  }
}
pub struct MintProofsArgs<'a> {
    pub mint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub proofs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>>>,
}
impl<'a> Default for MintProofsArgs<'a> {
  #[inline]
  fn default() -> Self {
    MintProofsArgs {
      mint: None, // required field
      proofs: None, // required field
    }
  }
}

pub struct MintProofsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MintProofsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mint(&mut self, mint: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintProofs::VT_MINT, mint);
  }
  #[inline]
  pub fn add_proofs(&mut self, proofs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Proof<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MintProofs::VT_PROOFS, proofs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MintProofsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MintProofsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MintProofs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, MintProofs::VT_MINT,"mint");
    self.fbb_.required(o, MintProofs::VT_PROOFS,"proofs");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MintProofs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MintProofs");
      ds.field("mint", &self.mint());
      ds.field("proofs", &self.proofs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MintProofsT {
  pub mint: String,
  pub proofs: Vec<ProofT>,
}
impl Default for MintProofsT {
  fn default() -> Self {
    Self {
      mint: "".to_string(),
      proofs: Default::default(),
    }
  }
}
impl MintProofsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MintProofs<'b>> {
    let mint = Some({
      let x = &self.mint;
      _fbb.create_string(x)
    });
    let proofs = Some({
      let x = &self.proofs;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MintProofs::create(_fbb, &MintProofsArgs{
      mint,
      proofs,
    })
  }
}
pub enum WorkerMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WorkerMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorkerMessage<'a> {
  type Inner = WorkerMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WorkerMessage<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorkerMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WorkerMessageArgs
  ) -> flatbuffers::WIPOffset<WorkerMessage<'bldr>> {
    let mut builder = WorkerMessageBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_type_(args.type_);
    builder.add_content_type(args.content_type);
    builder.finish()
  }

  pub fn unpack(&self) -> WorkerMessageT {
    let type_ = self.type_();
    let content = match self.content_type() {
      Message::NONE => MessageT::NONE,
      Message::ParsedEvent => MessageT::ParsedEvent(Box::new(
        self.content_as_parsed_event()
            .expect("Invalid union table, expected `Message::ParsedEvent`.")
            .unpack()
      )),
      Message::ConnectionStatus => MessageT::ConnectionStatus(Box::new(
        self.content_as_connection_status()
            .expect("Invalid union table, expected `Message::ConnectionStatus`.")
            .unpack()
      )),
      Message::CountResponse => MessageT::CountResponse(Box::new(
        self.content_as_count_response()
            .expect("Invalid union table, expected `Message::CountResponse`.")
            .unpack()
      )),
      Message::Eoce => MessageT::Eoce(Box::new(
        self.content_as_eoce()
            .expect("Invalid union table, expected `Message::Eoce`.")
            .unpack()
      )),
      Message::BufferFull => MessageT::BufferFull(Box::new(
        self.content_as_buffer_full()
            .expect("Invalid union table, expected `Message::BufferFull`.")
            .unpack()
      )),
      Message::ValidProofs => MessageT::ValidProofs(Box::new(
        self.content_as_valid_proofs()
            .expect("Invalid union table, expected `Message::ValidProofs`.")
            .unpack()
      )),
      _ => MessageT::NONE,
    };
    WorkerMessageT {
      type_,
      content,
    }
  }

  #[inline]
  pub fn type_(&self) -> MessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageType>(WorkerMessage::VT_TYPE_, Some(MessageType::ParsedNostrEvent)).unwrap()}
  }
  #[inline]
  pub fn content_type(&self) -> Message {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Message>(WorkerMessage::VT_CONTENT_TYPE, Some(Message::NONE)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(WorkerMessage::VT_CONTENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_parsed_event(&self) -> Option<ParsedEvent<'a>> {
    if self.content_type() == Message::ParsedEvent {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ParsedEvent::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_connection_status(&self) -> Option<ConnectionStatus<'a>> {
    if self.content_type() == Message::ConnectionStatus {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ConnectionStatus::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_count_response(&self) -> Option<CountResponse<'a>> {
    if self.content_type() == Message::CountResponse {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CountResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_eoce(&self) -> Option<Eoce<'a>> {
    if self.content_type() == Message::Eoce {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Eoce::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_buffer_full(&self) -> Option<BufferFull<'a>> {
    if self.content_type() == Message::BufferFull {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BufferFull::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_valid_proofs(&self) -> Option<ValidProofs<'a>> {
    if self.content_type() == Message::ValidProofs {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ValidProofs::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for WorkerMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<MessageType>("type_", Self::VT_TYPE_, false)?
     .visit_union::<Message, _>("content_type", Self::VT_CONTENT_TYPE, "content", Self::VT_CONTENT, false, |key, v, pos| {
        match key {
          Message::ParsedEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ParsedEvent>>("Message::ParsedEvent", pos),
          Message::ConnectionStatus => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConnectionStatus>>("Message::ConnectionStatus", pos),
          Message::CountResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CountResponse>>("Message::CountResponse", pos),
          Message::Eoce => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Eoce>>("Message::Eoce", pos),
          Message::BufferFull => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BufferFull>>("Message::BufferFull", pos),
          Message::ValidProofs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ValidProofs>>("Message::ValidProofs", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct WorkerMessageArgs {
    pub type_: MessageType,
    pub content_type: Message,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for WorkerMessageArgs {
  #[inline]
  fn default() -> Self {
    WorkerMessageArgs {
      type_: MessageType::ParsedNostrEvent,
      content_type: Message::NONE,
      content: None,
    }
  }
}

pub struct WorkerMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorkerMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: MessageType) {
    self.fbb_.push_slot::<MessageType>(WorkerMessage::VT_TYPE_, type_, MessageType::ParsedNostrEvent);
  }
  #[inline]
  pub fn add_content_type(&mut self, content_type: Message) {
    self.fbb_.push_slot::<Message>(WorkerMessage::VT_CONTENT_TYPE, content_type, Message::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorkerMessage::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WorkerMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WorkerMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorkerMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WorkerMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WorkerMessage");
      ds.field("type_", &self.type_());
      ds.field("content_type", &self.content_type());
      match self.content_type() {
        Message::ParsedEvent => {
          if let Some(x) = self.content_as_parsed_event() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::ConnectionStatus => {
          if let Some(x) = self.content_as_connection_status() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::CountResponse => {
          if let Some(x) = self.content_as_count_response() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::Eoce => {
          if let Some(x) = self.content_as_eoce() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::BufferFull => {
          if let Some(x) = self.content_as_buffer_full() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::ValidProofs => {
          if let Some(x) = self.content_as_valid_proofs() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("content", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WorkerMessageT {
  pub type_: MessageType,
  pub content: MessageT,
}
impl Default for WorkerMessageT {
  fn default() -> Self {
    Self {
      type_: MessageType::ParsedNostrEvent,
      content: MessageT::NONE,
    }
  }
}
impl WorkerMessageT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WorkerMessage<'b>> {
    let type_ = self.type_;
    let content_type = self.content.message_type();
    let content = self.content.pack(_fbb);
    WorkerMessage::create(_fbb, &WorkerMessageArgs{
      type_,
      content_type,
      content,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `WorkerMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_worker_message_unchecked`.
pub fn root_as_worker_message(buf: &[u8]) -> Result<WorkerMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<WorkerMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `WorkerMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_worker_message_unchecked`.
pub fn size_prefixed_root_as_worker_message(buf: &[u8]) -> Result<WorkerMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<WorkerMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `WorkerMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_worker_message_unchecked`.
pub fn root_as_worker_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WorkerMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<WorkerMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `WorkerMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_worker_message_unchecked`.
pub fn size_prefixed_root_as_worker_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WorkerMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<WorkerMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a WorkerMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `WorkerMessage`.
pub unsafe fn root_as_worker_message_unchecked(buf: &[u8]) -> WorkerMessage {
  flatbuffers::root_unchecked::<WorkerMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed WorkerMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `WorkerMessage`.
pub unsafe fn size_prefixed_root_as_worker_message_unchecked(buf: &[u8]) -> WorkerMessage {
  flatbuffers::size_prefixed_root_unchecked::<WorkerMessage>(buf)
}
#[inline]
pub fn finish_worker_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<WorkerMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_worker_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<WorkerMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fb
}  // pub mod nostr

