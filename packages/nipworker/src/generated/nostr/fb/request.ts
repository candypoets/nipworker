import { ByteString } from "src/lib/ByteString";
// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { StringVec, StringVecT } from '../../nostr/fb/string-vec.js';


export class Request implements flatbuffers.IUnpackableObject<RequestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Request {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsRequest(bb:flatbuffers.ByteBuffer, obj?:Request):Request {
  return (obj || new Request()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsRequest(bb:flatbuffers.ByteBuffer, obj?:Request):Request {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Request()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

ids(index: number): ByteString
ids(index: number,optionalEncoding:flatbuffers.Encoding): ByteString|Uint8Array
ids(index: number,optionalEncoding?:any): ByteString|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__stringByteString(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

idsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

authors(index: number): ByteString
authors(index: number,optionalEncoding:flatbuffers.Encoding): ByteString|Uint8Array
authors(index: number,optionalEncoding?:any): ByteString|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__stringByteString(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

authorsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

kinds(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint16(this.bb!.__vector(this.bb_pos + offset) + index * 2) : 0;
}

kindsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

kindsArray():Uint16Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Uint16Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

tags(index: number, obj?:StringVec):StringVec|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new StringVec()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

tagsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

limit():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

since():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

until():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

search(): ByteString|null
search(optionalEncoding:flatbuffers.Encoding): ByteString|Uint8Array|null
search(optionalEncoding?:any): ByteString|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__stringByteString(this.bb_pos + offset, optionalEncoding) : null;
}

relays(index: number): ByteString
relays(index: number,optionalEncoding:flatbuffers.Encoding): ByteString|Uint8Array
relays(index: number,optionalEncoding?:any): ByteString|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__stringByteString(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

relaysLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

closeOnEose():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

cacheFirst():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

noCache():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

maxRelays():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

static startRequest(builder:flatbuffers.Builder) {
  builder.startObject(13);
}

static addIds(builder:flatbuffers.Builder, idsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idsOffset, 0);
}

static createIdsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startIdsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addAuthors(builder:flatbuffers.Builder, authorsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, authorsOffset, 0);
}

static createAuthorsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startAuthorsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addKinds(builder:flatbuffers.Builder, kindsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, kindsOffset, 0);
}

static createKindsVector(builder:flatbuffers.Builder, data:number[]|Uint16Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createKindsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createKindsVector(builder:flatbuffers.Builder, data:number[]|Uint16Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(2, data.length, 2);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt16(data[i]!);
  }
  return builder.endVector();
}

static startKindsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(2, numElems, 2);
}

static addTags(builder:flatbuffers.Builder, tagsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, tagsOffset, 0);
}

static createTagsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTagsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLimit(builder:flatbuffers.Builder, limit:number) {
  builder.addFieldInt32(4, limit, 0);
}

static addSince(builder:flatbuffers.Builder, since:number) {
  builder.addFieldInt32(5, since, 0);
}

static addUntil(builder:flatbuffers.Builder, until:number) {
  builder.addFieldInt32(6, until, 0);
}

static addSearch(builder:flatbuffers.Builder, searchOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, searchOffset, 0);
}

static addRelays(builder:flatbuffers.Builder, relaysOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, relaysOffset, 0);
}

static createRelaysVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startRelaysVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCloseOnEose(builder:flatbuffers.Builder, closeOnEose:boolean) {
  builder.addFieldInt8(9, +closeOnEose, +false);
}

static addCacheFirst(builder:flatbuffers.Builder, cacheFirst:boolean) {
  builder.addFieldInt8(10, +cacheFirst, +false);
}

static addNoCache(builder:flatbuffers.Builder, noCache:boolean) {
  builder.addFieldInt8(11, +noCache, +false);
}

static addMaxRelays(builder:flatbuffers.Builder, maxRelays:number) {
  builder.addFieldInt16(12, maxRelays, 0);
}

static endRequest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createRequest(builder:flatbuffers.Builder, idsOffset:flatbuffers.Offset, authorsOffset:flatbuffers.Offset, kindsOffset:flatbuffers.Offset, tagsOffset:flatbuffers.Offset, limit:number, since:number, until:number, searchOffset:flatbuffers.Offset, relaysOffset:flatbuffers.Offset, closeOnEose:boolean, cacheFirst:boolean, noCache:boolean, maxRelays:number):flatbuffers.Offset {
  Request.startRequest(builder);
  Request.addIds(builder, idsOffset);
  Request.addAuthors(builder, authorsOffset);
  Request.addKinds(builder, kindsOffset);
  Request.addTags(builder, tagsOffset);
  Request.addLimit(builder, limit);
  Request.addSince(builder, since);
  Request.addUntil(builder, until);
  Request.addSearch(builder, searchOffset);
  Request.addRelays(builder, relaysOffset);
  Request.addCloseOnEose(builder, closeOnEose);
  Request.addCacheFirst(builder, cacheFirst);
  Request.addNoCache(builder, noCache);
  Request.addMaxRelays(builder, maxRelays);
  return Request.endRequest(builder);
}

unpack(): RequestT {
  return new RequestT(
    this.bb!.createScalarList<string>(this.ids.bind(this), this.idsLength()),
    this.bb!.createScalarList<string>(this.authors.bind(this), this.authorsLength()),
    this.bb!.createScalarList<number>(this.kinds.bind(this), this.kindsLength()),
    this.bb!.createObjList<StringVec, StringVecT>(this.tags.bind(this), this.tagsLength()),
    this.limit(),
    this.since(),
    this.until(),
    this.search(),
    this.bb!.createScalarList<string>(this.relays.bind(this), this.relaysLength()),
    this.closeOnEose(),
    this.cacheFirst(),
    this.noCache(),
    this.maxRelays()
  );
}


unpackTo(_o: RequestT): void {
  _o.ids = this.bb!.createScalarList<string>(this.ids.bind(this), this.idsLength());
  _o.authors = this.bb!.createScalarList<string>(this.authors.bind(this), this.authorsLength());
  _o.kinds = this.bb!.createScalarList<number>(this.kinds.bind(this), this.kindsLength());
  _o.tags = this.bb!.createObjList<StringVec, StringVecT>(this.tags.bind(this), this.tagsLength());
  _o.limit = this.limit();
  _o.since = this.since();
  _o.until = this.until();
  _o.search = this.search();
  _o.relays = this.bb!.createScalarList<string>(this.relays.bind(this), this.relaysLength());
  _o.closeOnEose = this.closeOnEose();
  _o.cacheFirst = this.cacheFirst();
  _o.noCache = this.noCache();
  _o.maxRelays = this.maxRelays();
}
}

export class RequestT implements flatbuffers.IGeneratedObject {
constructor(
  public ids: (string)[] = [],
  public authors: (string)[] = [],
  public kinds: (number)[] = [],
  public tags: (StringVecT)[] = [],
  public limit: number = 0,
  public since: number = 0,
  public until: number = 0,
  public search: ByteString|Uint8Array|null = null,
  public relays: (string)[] = [],
  public closeOnEose: boolean = false,
  public cacheFirst: boolean = false,
  public noCache: boolean = false,
  public maxRelays: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ids = Request.createIdsVector(builder, builder.createObjectOffsetList(this.ids));
  const authors = Request.createAuthorsVector(builder, builder.createObjectOffsetList(this.authors));
  const kinds = Request.createKindsVector(builder, this.kinds);
  const tags = Request.createTagsVector(builder, builder.createObjectOffsetList(this.tags));
  const search = (this.search !== null ? builder.createString(this.search!) : 0);
  const relays = Request.createRelaysVector(builder, builder.createObjectOffsetList(this.relays));

  return Request.createRequest(builder,
    ids,
    authors,
    kinds,
    tags,
    this.limit,
    this.since,
    this.until,
    search,
    relays,
    this.closeOnEose,
    this.cacheFirst,
    this.noCache,
    this.maxRelays
  );
}
}
