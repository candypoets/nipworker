// Top-level schema that includes all dependencies
include "common.fbs";
include "main.fbs";
include "kinds/kind0.fbs";
include "kinds/kind1.fbs";
include "kinds/kind3.fbs";
include "kinds/kind4.fbs";
include "kinds/kind6.fbs";
include "kinds/kind7.fbs";
include "kinds/kind17.fbs";
include "kinds/kind10002.fbs";
include "kinds/kind10019.fbs";
include "kinds/kind17375.fbs";
include "kinds/kind39089.fbs";
include "kinds/kind7374.fbs";
include "kinds/kind7375.fbs";
include "kinds/kind7376.fbs";
include "kinds/kind9321.fbs";
include "kinds/kind9735.fbs";
include "kinds/kind30023.fbs";
include "kinds/list.fbs";
include "kinds/pre_generic.fbs";

namespace nostr.fb;

// -- Union Types --
enum MessageType : uint32 {
  ParsedNostrEvent = 0,
  ConnectionStatus = 1,
  CountResponse = 2,
  Eoce = 3,
  BufferFull = 4,
  ValidProofs = 5,
  SignedEvent = 6,
  Pubkey = 7,
  Raw = 8,
  NostrEvent = 9,
}

enum ParsedDataUnion : uint32 {
  Kind0Parsed = 0,
  Kind1Parsed = 1,
  Kind3Parsed = 3,
  Kind4Parsed = 4,
  Kind6Parsed = 6,
  Kind7Parsed = 7,
  Kind17Parsed = 17,
  Kind10002Parsed = 10002,
  Kind10019Parsed = 10019,
  Kind17375Parsed = 17375,
  Kind39089Parsed = 39089,
  Kind7374Parsed = 7374,
  Kind7375Parsed = 7375,
  Kind7376Parsed = 7376,
  Kind9321Parsed = 9321,
  Kind9735Parsed = 9735,
  Kind30023Parsed = 30023,
  ListParsed = 51000,
  PreGenericParsed = 52000
}

// -- Core Structures --
union ParsedData {
  Kind0Parsed,
  Kind1Parsed,
  Kind3Parsed,
  Kind4Parsed,
  Kind6Parsed,
  Kind7Parsed,
  Kind17Parsed,
  Kind10002Parsed,
  Kind10019Parsed,
  Kind17375Parsed,
  Kind39089Parsed,
  Kind7374Parsed,
  Kind7375Parsed,
  Kind7376Parsed,
  Kind9321Parsed,
  Kind9735Parsed,
  Kind30023Parsed,
  ListParsed,
  PreGenericParsed
}

table ParsedEvent {
  id: string (required);
  pubkey: string (required);
  kind: ushort;
  created_at: uint;
  parsed: ParsedData;
  requests: [Request];
  relays: [string];
  tags: [StringVec] (required);
}

// Non-event messages
table ConnectionStatus {
  relay_url: string (required);
  status: string (required);
  message: string;
}

table CountResponse {
  count: uint;
  kind: ushort;
  you: bool;
}

table Eoce {
  subscription_id: string (required);
}

table BufferFull {
  dropped_events: ushort;
}

table ValidProofs {
  proofs: [MintProofs] (required);
}

table MintProofs {
  mint: string (required);
  proofs: [Proof] (required);
}

table Pubkey {
  pubkey: string (required);
}

table SignedEvent {
    event: NostrEvent (required);
}

// a raw string message coming from relays
table Raw {
    raw: string (required);
}

// Root union type
union Message {
  ParsedEvent,
  NostrEvent,
  ConnectionStatus,
  CountResponse,
  Eoce,
  BufferFull,
  ValidProofs,
  SignedEvent,
  Pubkey,
  Raw
}

// NEW: Wrapper table
table WorkerMessage {
  sub_id: string;
  url: string;
  type: MessageType;
  content: Message;
}

table CacheRequest {
    sub_id: string (required);
    requests: [Request];
    event: NostrEvent;
    relays: [string];
}

// Signer service messages
// These are used over the signer_service_request/signer_service_response SABs.
// Payload/result are JSON-encoded strings for flexibility; can be replaced by
// dedicated FlatBuffer tables later without breaking the union types elsewhere.
enum SignerOp : uint32 {
  GetPubkey = 0,
  SignEvent = 1,
  Nip04Encrypt = 2,
  Nip04Decrypt = 3,
  Nip44Encrypt = 4,
  Nip44Decrypt = 5
}

table SignerRequest {
  request_id: ulong;
  op: SignerOp;
  // Template, parameters, etc., encoded as JSON for now.
  payload_json: string;
}

table SignerResponse {
  request_id: ulong;
  ok: bool = true;
  // When ok=true, carries the result (e.g., signed event) as JSON.
  result_json: string;
  // When ok=false, carries an error message.
  error: string;
}

root_type WorkerMessage;
