// Top-level schema that includes all dependencies
include "common.fbs";
include "main.fbs";
include "kinds/kind0.fbs";
include "kinds/kind1.fbs";
include "kinds/kind3.fbs";
include "kinds/kind4.fbs";
include "kinds/kind6.fbs";
include "kinds/kind7.fbs";
include "kinds/kind17.fbs";
include "kinds/kind10002.fbs";
include "kinds/kind10019.fbs";
include "kinds/kind17375.fbs";
include "kinds/kind7374.fbs";
include "kinds/kind7375.fbs";
include "kinds/kind7376.fbs";
include "kinds/kind9321.fbs";
include "kinds/kind9735.fbs";
include "kinds/kind30023.fbs";
include "kinds/kind20.fbs";
include "kinds/kind22.fbs";
include "kinds/kind1111.fbs";
include "kinds/list.fbs";
include "kinds/pre_generic.fbs";

namespace nostr.fb;

// -- Union Types --
enum MessageType : uint32 {
  ParsedNostrEvent = 0,
  ConnectionStatus = 1,
  CountResponse = 2,
  Eoce = 3,
  BufferFull = 4,
  ValidProofs = 5,
  SignedEvent = 6,
  Pubkey = 7,
  Raw = 8,
  NostrEvent = 9,
}

enum ParsedDataUnion : uint32 {
  Kind0Parsed = 0,
  Kind1Parsed = 1,
  Kind3Parsed = 3,
  Kind4Parsed = 4,
  Kind6Parsed = 6,
  Kind7Parsed = 7,
  Kind17Parsed = 17,
  Kind20Parsed = 20,
  Kind22Parsed = 22,
  Kind1111Parsed = 1111,
  Kind10002Parsed = 10002,
  Kind10019Parsed = 10019,
  Kind17375Parsed = 17375,
  Kind39089Parsed = 39089,
  Kind7374Parsed = 7374,
  Kind7375Parsed = 7375,
  Kind7376Parsed = 7376,
  Kind9321Parsed = 9321,
  Kind9735Parsed = 9735,
  Kind30023Parsed = 30023,
  ListParsed = 51000,
  PreGenericParsed = 52000
}

// -- Core Structures --
union ParsedData {
  Kind0Parsed,
  Kind1Parsed,
  Kind3Parsed,
  Kind4Parsed,
  Kind6Parsed,
  Kind7Parsed,
  Kind17Parsed,
  Kind20Parsed,
  Kind22Parsed,
  Kind1111Parsed,
  Kind10002Parsed,
  Kind10019Parsed,
  Kind17375Parsed,
  Kind7374Parsed,
  Kind7375Parsed,
  Kind7376Parsed,
  Kind9321Parsed,
  Kind9735Parsed,
  Kind30023Parsed,
  ListParsed,
  PreGenericParsed
}

table ParsedEvent {
  id: string (required);
  pubkey: string (required);
  kind: ushort;
  created_at: uint;
  parsed: ParsedData;
  requests: [Request];
  relays: [string];
  tags: [StringVec] (required);
}

// Non-event messages
table ConnectionStatus {
  relay_url: string (required);
  status: string (required);
  message: string;
}

table CountResponse {
  count: uint;
  kind: ushort;
  you: bool;
}

table Eoce {
  subscription_id: string (required);
}

table BufferFull {
  dropped_events: ushort;
}

table ValidProofs {
  proofs: [MintProofs] (required);
}

table MintProofs {
  mint: string (required);
  proofs: [Proof] (required);
}

table Pubkey {
  pubkey: string (required);
}

table SignedEvent {
    event: NostrEvent (required);
}

// a raw string message coming from relays
table Raw {
    raw: string (required);
}

// Root union type
union Message {
  ParsedEvent,
  NostrEvent,
  ConnectionStatus,
  CountResponse,
  Eoce,
  BufferFull,
  ValidProofs,
  SignedEvent,
  Pubkey,
  Raw
}

table WorkerMessage {
  sub_id: string;
  url: string;
  type: MessageType;
  content: Message;
}

table CacheRequest {
    sub_id: string (required);
    requests: [Request];
    event: NostrEvent;
    relays: [string];
}

// Signer service messages
// These are used over the signer_service_request/signer_service_response SABs.
// Payload/result are raw strings. For structured data we may adopt dedicated
// FlatBuffer tables later without breaking the SAB protocol.
enum SignerOp : uint32 {
  GetPubkey = 0,
  SignEvent = 1,
  // Single-peer ops:
  // - Nip04Encrypt/Nip44Encrypt: plaintext + recipient (pubkey)
  // - Nip04Decrypt/Nip44Decrypt: ciphertext + sender (pubkey)
  Nip04Encrypt = 2,
  Nip04Decrypt = 3,
  Nip44Encrypt = 4,
  Nip44Decrypt = 5,
  // Between-ops accept both participants (sender and recipient).
  // The signer will fetch its own pubkey and choose the correct peer.
  Nip04DecryptBetween = 6,
  Nip44DecryptBetween = 7,
  VerifyProof = 8
}

table SignerRequest {
  request_id: ulong;
  op: SignerOp;

  // Raw string payload:
  // - SignEvent: template JSON
  // - Nip04/Nip44 Encrypt: plaintext
  // - Nip04/Nip44 Decrypt: ciphertext
  // - Nip04DecryptBetween/Nip44DecryptBetween: ciphertext
  payload: string;

  // For single-peer ops:
  // - Encrypt: recipient pubkey (hex)
  // - Decrypt: sender pubkey (hex)
  pubkey: string;

  // For DecryptBetween ops (required there, ignored otherwise):
  // Both participants, role-labeled for clarity.
  sender_pubkey: string;
  recipient_pubkey: string;
}

table SignerResponse {
  request_id: ulong;
  // Raw string result: pubkey hex, signed event JSON, ciphertext, or plaintext.
  result: string;
  // Error message when a request fails; empty when success.
  error: string;
}

root_type WorkerMessage;
